package Baseliner::Model::Rules;
use Moose;
BEGIN { extends 'Catalyst::Model' }

use Baseliner::Core::Registry ':dsl';
use Baseliner::Utils;
use Baseliner::Sugar;
use Baseliner::CompiledRule;
use BaselinerX::CI::variable;
use Try::Tiny;
use v5.10;
use experimental 'autoderef';

with 'Baseliner::Role::Service';

has tidy_up => qw(is rw isa Bool default 1);

register 'event.rule.failed' => {
    description => 'Rule failed',
    vars => ['rc', 'ret', 'rule', 'rule_name']
};

register 'event.rule.trap' => {
    description => 'Rule error trapped',
    vars => ['job_name','bl', 'step', 'output']
};

# generated by rule/* controller:
register 'event.ws.soap_error' => {
    description=>'Soap Error running Rule',
};

register 'event.ws.rule_error' => {
    description=>'Error Running Rule from WS',
};

register 'event.ws.wsdl_error' => {
    description=>'WSDL Error Running Rule from WS',
};

sub init_job_tasks {
    my ($self)=@_;
    return map { +{ text=>$_, key=>'statement.step', icon=>'/static/images/icons/job.png', 
            children=>[], leaf=>\0, expanded=>\1 } 
    } qw(CHECK INIT PRE RUN POST);
}

sub init_fieldlets_tasks {
    my ($self)=@_;
    return map {
        my $node;
        $node->{leaf} = \1;
        $node->{text} = _loc( $_->{name} );
        $node->{key} = $_->{key};
        $node->{icon} = $_->{icon};
        $node->{name} = $_->{name};
        $node->{data} = $_;
        $node->{data}{fieldletType} = $_->{key};
        $node->{data}{hidden} = 0;
        $node->{data}{allowBlank} = 0;
        $node->{data}{editable} = 1;
        $node->{ts} = mdb->ts;
        # $node->{who} = 'root'; # TODO get user from $c->username
        $node 
    } Baseliner->registry->get('fieldlet.system.status_new')->registry_node->raw, 
    Baseliner->registry->get('fieldlet.system.title')->registry_node->raw;
}

sub tree_format {
    my ($self, @tree_in)=@_;
    my @tree_out;
    for my $n ( @tree_in ) {
        my $chi = delete $n->{children};
        $n = $n->{attributes} if $n->{attributes};
        $chi = delete $n->{children} unless ref $chi eq 'ARRAY' && @$chi;
        delete $n->{attributes};
        delete $n->{disabled};
        delete $n->{id} unless $n && $n->{id} && $n->{id} =~/rule-/;
        $n->{active} //= 1;
        $n->{disabled} = $n->{active} ? \0 : \1;
        my @chi = $self->tree_format( _array($chi) );
        #$n->{children} = \@chi;
        if( @chi ) {
            $n->{children} = \@chi;
            $n->{leaf} = \0;
            $n->{expanded} = $n->{expanded} eq 'false' ? \0 : \1;
        } elsif( ($n->{leaf} && $n->{leaf} eq 'false') ||(! ${$n->{leaf} // \1}) ) {  # may be a folder with no children
            $n->{children} = []; 
            $n->{expanded} = $n->{expanded} eq 'false' ? \0 : \1;
        }
        delete $n->{loader};  
        delete $n->{isTarget};  # otherwise you cannot drag-drop around a node
        #_log $n;
        push @tree_out, $n;
    }
    return @tree_out;
}

sub build_tree {
    my ($self, $id_rule, $parent, %p) = @_;
    # TODO run query just once and work with a hash ->hash_for( id_parent )
    my $rule = mdb->rule->find_one({ '$or'=>[ {id=>"$id_rule"},{rule_name=>"$id_rule"} ] });
    _fail _loc 'Could not find rule %1', $id_rule unless $rule;
    my $rule_tree_json = $rule->{rule_tree};
    if( $rule_tree_json ) {
        my $rule_tree = Util->_decode_json( $rule_tree_json );
        _fail _loc 'Invalid rule tree json data: not an array' unless ref $rule_tree eq 'ARRAY';
        my @tf = $self->tree_format( @$rule_tree );
        return @tf;
    } else {
        if( $rule->{rule_type} eq 'pipeline' ) {
            return $self->init_job_tasks;
        }
        if ( $rule->{rule_type} eq 'form') {
            return $self->init_fieldlets_tasks;
        }
        _warn _loc 'Rule tree is empty for rule %1', $id_rule;
        return ();
    }
}

sub _is_true { 
    my($self,$v) = @_; 
    return (ref $v eq 'SCALAR' && !${$v}) || $v eq 'false' || !$v;
}

sub all_nodes {
    my ($self, %p )=@_;
    my @nodes = $self->build_tree( $p{id_rule} );
    my $dig; $dig = sub{ 
        map { 
          ( $_, $dig->( _array( $$_{children} ) ) ) 
        } @_;
    };
    $dig->( @nodes );
}

# called when rule is saved
sub dsl_build_and_test {
    my ($self,$stmts, %p )=@_;
    my $dsl = $self->dsl_build( $stmts, id_rule=>$p{id_rule}, %p ); 
    my $rule = Baseliner::CompiledRule->new( id_rule=>$p{id_rule}, dsl=>$dsl, ts=>$p{ts} ); # send ts so its stored as this rule save timestamp
    $rule->compile;
    die $rule->errors if $rule->errors;
    return $dsl;
}

sub dsl_build {
    my ($self,$stmts, %p )=@_;
    return '' if !$stmts || ( ref $stmts eq 'HASH' && !%$stmts );
    my $id_rule = $p{id_rule} //  '';
    my $rule_name = $p{rule_name} // do {
        my $doc = $p{doc} // ( $id_rule ?  mdb->rule->find_one({ id=>"$id_rule" }) : {} );
        $$doc{rule_name} || $id_rule || '';
    };
    #_debug $stmts;
    my @dsl;
    require Data::Dumper;
    my $spaces = sub { '   ' x $_[0] };
    my $level = 0;
    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Deparse = 1;
    local $Data::Dumper::Deepcopy = 1;
    
    for my $s ( _array $stmts ) {
        local $p{no_tidy} = 1; # just one tidy is enough
        my $children = $s->{children} || {};
        my $attr = defined $s->{attributes} ? $s->{attributes} : $s;  # attributes is for a json treepanel
        # is active ?
        next if defined $attr->{active} && !$attr->{active}; 
        #next if (ref $attr->{disabled} eq 'SCALAR' && ${$attr->{disabled}} ) || $attr->{disabled} eq 'true' || $attr->{disabled};
        delete $attr->{loader} ; # node cruft
        delete $attr->{events} ; # node cruft
        #_debug $attr;
        my $name = _strip_html( $attr->{text} );
        my $name_id = Util->_name_to_id( $name );
        my $data = $attr->{data} || {};
        # put the properties (metadata) into the data so that we see it in $config in services
        $data->{meta}{$_}= blessed($attr->{$_}) 
            ? "$attr->{$_}" 
            : $attr->{$_} 
            for grep !/^data$/, keys %$attr;
        
        my $run_forward = _bool($attr->{run_forward},1);  # if !defined, default is true
        my $run_rollback = _bool($attr->{run_rollback},1); 
        my $error_trap = $attr->{error_trap} if $attr->{error_trap} && $attr->{error_trap} ne 'none';
        my $trap_timeout = $attr->{trap_timeout} if $attr->{error_trap} && $attr->{error_trap} ne 'none';
        my $trap_timeout_action = $attr->{trap_timeout_action} if $attr->{error_trap} && $attr->{error_trap} ne 'none';
        my $trap_rollback = $attr->{trap_rollback} if $attr->{error_trap} && $attr->{error_trap} ne 'none';
        my $needs_rollback_mode = $attr->{needs_rollback_mode} // 'none'; 
        my $needs_rollback_key  = $attr->{needs_rollback_key} // '';
        my $parallel_mode = length $attr->{parallel_mode} && $attr->{parallel_mode} ne 'none' ? $attr->{parallel_mode} : '';
        my $debug_mode = length $attr->{debug_mode} && $attr->{debug_mode} ne 'none' ? $attr->{debug_mode} : '';
        push @dsl, sprintf( '%s:', $attr->{goto_label} ) . "\n" if length $attr->{goto_label};  
        push @dsl, sprintf( 'sub %s {', $attr->{sub_name} ) . "\n" if length $attr->{sub_name};  

        if( my $semaphore_key = $attr->{semaphore_key} ) {
            # consider using a hash: $stash->{_sem}{ $semaphore_key } = ...
            push @dsl, sprintf( 'local $stash->{_sem} = semaphore({ key=>parse_vars(q{%s},$stash), who=>parse_vars(q{%s},$stash) }, $stash)->take;', $semaphore_key, $name ) . "\n"; 
        }
        my $timeout = $attr->{timeout};
        my $rb_close_me = 0;
        if( !$run_forward && !$run_rollback ) {
            push @dsl, sprintf( 'if( 0 ) { # not forward or backwards ')."\n";
            $rb_close_me = 1;
        }
        elsif( !$run_forward ) {
            if ( !$needs_rollback_key || $needs_rollback_key eq '<always>') {
                push @dsl, sprintf( 'if( $$stash{rollback} ) { # only if we are going backwards ')."\n";
            } else {
                push @dsl, sprintf( 'if( $$stash{rollback} && $stash->{needs_rollback}{q{%s}} ) { # only if we are going backwards ', $needs_rollback_key)."\n";
            }
            $rb_close_me = 1;
        }
        elsif( !$run_rollback ) {
            push @dsl, sprintf( 'if( !$$stash{rollback} ) { # only if we are going forward ')."\n";
            $rb_close_me = 1;
        }
        else {
            if ( $needs_rollback_key && $needs_rollback_key ne '<always>') {
                push @dsl, sprintf( 'if( !$$stash{rollback} || ( $$stash{rollback} && $stash->{needs_rollback}{q{%s}} )) { # forward or back if rollback_key ', $needs_rollback_key)."\n";
                $rb_close_me = 1;
            } 
        }
        my ($data_key) = $attr->{data_key} =~ /^\s*(\S+)\s*$/ if $attr->{data_key};
        my $closure = $attr->{closure};
        push @dsl, sprintf( '# task: %s', $name // '') . "\n"; 
        if( $closure ) {
            push @dsl, sprintf( 'current_task($stash, q{%s}, q{%s}, q{%s}, sub{', $id_rule, $rule_name, $name )."\n";
        } elsif( ! $attr->{nested} ) {
            push @dsl, sprintf( 'current_task($stash, q{%s}, q{%s}, q{%s});', $id_rule, $rule_name, $name // '')."\n";
        }
        push @dsl, sprintf( '_debug("BEFORE STASH", $stash);' ) . "\n" if $debug_mode eq 'stash';  
        if( length $timeout && $timeout > 0 ) {
            push @dsl, sprintf( 'alarm %s;', $timeout )."\n";
        }
        push @dsl, sprintf( '_debug(q{=====| Current Rule Task: %s} );', $name)."\n" if $p{verbose}; 
        if( length $attr->{key} ) {
            push @dsl, sprintf('$stash->{needs_rollback}{q{%s}} = $stash->{job_step};', $needs_rollback_key || $name_id) if $needs_rollback_mode eq 'nb_always';
            push @dsl, sprintf('parallel_run(q{%s},q{%s},$stash,sub{', $name, $parallel_mode) if $parallel_mode;
            push @dsl, sprintf( 'error_trap($stash,"%s","%s","%s","%s", sub {',$trap_timeout || 0,$trap_timeout_action || "", $trap_rollback || '1', $error_trap) if $error_trap; 
            my $key = $attr->{key};
            use Baseliner::Model::Registry;
            my $reg = Baseliner::Model::Registry->get( $key );
            _fail _loc 'Could not find rule key `%1`', $key unless blessed $reg;
            if( $reg->isa( 'BaselinerX::Type::Service' ) ) {
                push @dsl, $spaces->($level) . '{';
                if( length $attr->{sub_name} ) {
                    push @dsl, $spaces->($level) . sprintf(q{   my $config = parse_vars +{ %{ %s || {} }, %{ delete($$stash{shortcut_config}) // {}} }, $stash;}, Data::Dumper::Dumper( $data ) );
                } else {
                    if($key eq 'service.web.request'){
                        $data->{body} = Util->_fix_utf8_to_xml_entities($data->{body});
                    }
                    push @dsl, $spaces->($level) . sprintf(q{   my $config = parse_vars %s, $stash;}, Data::Dumper::Dumper( $data ) );
                }
                push @dsl, $spaces->($level) . sprintf(q{   launch( "%s", q{%s}, $stash, $config => '%s' );}, $key, $name, ($data_key//'') );
                push @dsl, $spaces->($level) . '}';
                #push @dsl, $spaces->($level) . sprintf('merge_data($stash, $ret );', Data::Dumper::Dumper( $data ) );
            } else {
                push @dsl, _array( $reg->{dsl}->($self, { %$attr, %$data, children=>$children, data_key=>$data_key }, %p ) );
            }
            push @dsl, '});' if $error_trap; # current_task close
            push @dsl, '});' if $parallel_mode; # current_task close
            push @dsl, '});' if $closure; # current_task close
            push @dsl, sprintf( '$stash->{_sem}->release if $stash->{_sem};') if $attr->{semaphore_key};
        } else {
            _debug $s;
            _fail _loc 'Missing dsl/service key for node %1', $name;
        }
        push @dsl, "}\n" if $rb_close_me;
        if( length $attr->{sub_name} ) {
            push @dsl, "};\n";
            push @dsl, sprintf( "%s();\n", $attr->{sub_name} ) if $attr->{sub_mode} && $attr->{sub_mode} eq 'run';
        }
        push @dsl, sprintf( '_debug("AFTER STASH", $stash);' ) . "\n" if $debug_mode eq 'stash';  
    }

    my $dsl = join "\n", @dsl;
    # WTF? $self can be class name
    if(ref $self && $self->tidy_up && !$p{no_tidy} ) {
        require Perl::Tidy;
        my $tidied = '';
        Perl::Tidy::perltidy( argv => '--maximum-line-length=160 --quiet --no-log', source => \$dsl, destination => \$tidied );
        return $tidied;
    } else {
        return $dsl;
    }
}

sub dsl_run {
    my ($self, %p ) = @_;
    my $id_rule = $p{id_rule};
    local $@;
    my $ret;
    my $stash = $p{stash} // {};
    
    merge_into_stash( $stash, BaselinerX::CI::variable->default_hash ); 
    
    ## local $Baseliner::Utils::caller_level = 3;
    ############################## EVAL DSL Tasks
    my $rule = Baseliner::CompiledRule->new( ( $id_rule ? (id_rule=>$id_rule):() ), dsl=>$p{dsl} );
    $rule->compile;
    $rule->run(stash=>$stash);  # if there's a compile error it wont run
    ##############################
    
    
    if( my $err = $rule->errors ) {
        if( $p{simple_error} ) {
            _error( _loc("Error during DSL Execution: %1", $err) ) unless $p{simple_error} > 1;
            _fail $err;
        } else {
            _fail( _loc("Error during DSL Execution: %1", $err) );
        }
        _debug "DSL:\n",  $self->dsl_listing( $rule->dsl );
    } else {
        _debug "DSL:\n",  $self->dsl_listing( $rule->dsl ) if $p{logging};
    }
    return { stash=>$stash, dsl=>($rule->dsl || $rule->package) };  # TODO storing dsl everywhere maybe a waste of space
}

sub compile_rules {
    my $self = shift;
    my (%params) = @_;

    my $rule_precompile = $params{rule_precompile} // 'none';

    return if $rule_precompile eq 'none';

    my @rules = mdb->rule->find( { rule_active => mdb->true, $rule_precompile ne 'always' ? (rule_compile_mode=>'precompile') : () } )
      ->sort( mdb->ixhash( rule_seq => 1, id => 1 ) )->all;

    foreach my $rule (@rules) {
        try {
            my $cr = Baseliner::CompiledRule->new( id_rule => $rule->{id} );
            $cr->compile;
        };
    }
}

# used by events
sub run_rules {
    my ($self, %p) = @_;
    my $when = $p{when};
    local $Baseliner::_no_cache = 0;
    my @rules = 
        $p{id_rule} 
            ? ( mdb->rule->find_one({ '$or'=>[ {id=>"$p{id_rule}"},{rule_name=>"$p{id_rule}"} ] }) )
            : mdb->rule->find({ rule_event => $p{event}, rule_type => ($p{rule_type} // 'event'), rule_when => $when, rule_active => mdb->true })
              ->sort(mdb->ixhash(rule_seq=>1, id=>1))->all;
    my $stash = $p{stash};
    my @rule_log;
    local $ENV{BASELINER_LOGCOLOR} = 0;
    
    my $mid = $stash->{mid} if $stash;
    my $sem;
    if( defined $mid && @rules && $p{use_semaphore} ) {
        require Baseliner::Sem;
        $sem = Baseliner::Sem->new( key=>'event:'.$stash->{mid}, who=>"rules:$when", internal=>1 );
        $sem->take;
    }
    $stash->{rules_exec}{$p{event}}{ $when } = 0;
    for my $rule ( @rules ) {
        $stash->{rules_exec}{$p{event}}{ $when }++;
        my ($runner_output, $rc, $ret,$err);
        my $id_rule = $rule->{id};
        try {
            my $t0=[Time::HiRes::gettimeofday];

            ################### RUN THE RULE DSL ######################
            require Capture::Tiny;
            ($runner_output) = Capture::Tiny::tee_merged(sub{
                try {
                    $ret = $self->dsl_run( id_rule=>$id_rule, stash=>$stash, simple_error=>$p{simple_error} );
                } catch {
                    $err = shift // _loc('Unknown error running rule: %1', $id_rule ); 
                };
            });
            # report controlled errors
            if( $err ) {
                if ( $rule->{rule_when} !~ /online/ ) {
                    event_new 'event.rule.failed' => { username => 'internal', dsl=>$ret->{dsl}, rule=>$id_rule, rule_name=>$rule->{rule_name}, stash=>$stash, output => $runner_output } => sub {};
                }           
                if( $p{simple_error} ) {
                    _error( _loc("Error running rule '%1' (%2): %3", $rule->{rule_name}, $rule->{rule_when}, $err ) ) unless $p{simple_error} > 1; 
                    _fail $err; 
                } else {
                    _fail( _loc("Error running rule '%1' (%2): %3", $rule->{rule_name}, $rule->{rule_when}, $err ) ); 
                }
            }
        } catch {
            my $err_global = shift;
            $rc = 1;
            if( ref $p{onerror} eq 'CODE') {
                if ( $rule->{rule_when} !~ /online/ ) {
                    event_new 'event.rule.failed' => { username => 'internal', dsl=>$ret->{dsl}, rc=>$rc, ret=>$ret->{stash}, rule => $id_rule, rule_name => $rule->{rule_name}, stash => $stash, output => $runner_output } => sub {};
                }
                $p{onerror}->( { err=>$err_global, ret=>$ret->{stash}, id=>$id_rule, dsl=>$ret->{dsl}, stash=>$stash, output=>$runner_output, rc=>$rc } );
            } elsif( ! $p{onerror} ) {
                _fail "(rule $id_rule): ".$err_global;
            }
        };
        push @rule_log, { ret=>$ret->{stash}, id => $id_rule, dsl=>$ret->{dsl}, stash=>$stash, output=>$runner_output, rc=>$rc };
    }
    if( $sem ) {
        $sem->release;
    }
    return { stash=>$stash, rule_log=>\@rule_log }; 
}

# used by pipelines
sub run_single_rule {
    my ($self, %p ) = @_;
    local $Baseliner::_no_cache = 0;
    $p{stash} //= {};
    my $stash = $p{stash};
    my $rule = mdb->rule->find_one({ '$or'=>[ {id=>"$p{id_rule}"},{rule_name=>"$p{id_rule}"} ] });
    
    _fail _loc 'Rule with id `%1` not found', $p{id_rule} unless $rule;
    my $rule_id = $rule->{id};
    my @tree = $self->build_tree( $p{id_rule}, undef );
    #local $self->{tidy_up} = 0;
    my $t0=[Time::HiRes::gettimeofday];

    my $ret = try {
        ################### RUN THE RULE DSL ######################
        $self->dsl_run( id_rule=>$rule_id, stash=>$p{stash}, %p );
    } catch {
        _fail( _loc("Error running rule '%1': %2", $rule->{rule_name}, shift() ) ); 
    };
    return { ret=>$ret, dsl=>'' };
}

sub dsl_listing {
    my ($self,$dsl)=@_;
    my $lin = 1;
    return join '', map { $lin++.": ".$_."\n" } split /\n/, $dsl;
}

######################################## GLOBAL SUBS

sub merge_into_stash {
    my ($stash, $data) = @_;
    return unless ref $data eq 'HASH';
    while( my($k,$v) = each %$data ) {
        $stash->{$k} = $v;
    }
    return $stash
}

#sub project_changed {
#    my $stash = shift;
#    # for each changeset, get project and group changesets
#    my %projects;
#    for my $project ( _array( $stash->{project_changes} ) ) {
#        $cs = ci->new( $cs ) unless ref $cs;
#        for my $project ( $cs->related( does=>'Project' ) ) {
#            $projects{ $project->mid } = $project;
#        }
#    }
#    #my $project = ci->new( 6901 );  # TEF
#    return values %projects;
#}

############################## STATEMENTS

register 'statement.if.var' => {
    text => 'IF var THEN',
    type => 'if',
    form => '/forms/variable_value.js',
    data => { variable=>'', value=>'' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( $stash->{'%s'} eq '%s' ) {
                %s
            }
            
        }, $n->{variable}, $n->{value} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if_not.var' => {
    text => 'IF var ne value THEN',
    type => 'if',
    form => '/forms/variable_value.js',
    data => { variable=>'', value=>'' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( $stash->{'%s'} ne '%s' ) {
                %s
            }
            
        }, $n->{variable}, $n->{value} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.condition' => {
    text => 'IF condition THEN',
    type => 'if',
    data => { condition =>'1' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( %s ) {
                %s
            }
            
        }, $n->{condition}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.else' => {
    text => 'ELSE',
     icon => '/static/images/icons/else.gif',
    type => 'if',
    nested => 1,   # avoids a "current_task" before
    data => {},
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            else {
                %s
            }
            
        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.elsif' => {
    text => 'ELSIF condition THEN',
    icon => '/static/images/icons/if_else.gif',
    type => 'if',
    nested => 1,
    data => { condition =>'1' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            elsif( %s ) {
                %s
            }
            
        }, $n->{condition}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.var.list' => {
    text => 'IF var in LIST THEN',
    type => 'if',
    form => '/forms/variable_values.js',
    data => { variable=>'', values=>'' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        my @conditions;
        my $complete_condition;
        my @values = split /,/,$n->{values};

        for ( @values ) {
            push @conditions, sprintf(q{$stash->{'%s'} eq '%s'},$n->{variable},$_);
        }
        $complete_condition = join " || ", @conditions;

        sprintf(q/
            if( %s ) {
                %s
            }
    
        /, $complete_condition, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.try' => {
    text => 'TRY statement (without catch)', 
    type => 'if',
    data => { },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            use Try::Tiny;
            try {
                %s
            };
        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.try_with_catch' => {
    text => 'TRY statement (needs a catch)', 
    type => 'if',
    data => { },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            use Try::Tiny;
            try {
                %s
            }
        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.catch' => {
    text => 'CATCH statement (needs a try_with_catch)', 
    type => 'if',
    data => { },
    nested => 1,
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            catch {
                %s
            };
            
        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.let.merge' => {
    text => 'MERGE value INTO stash', 
    type => 'let',
    holds_children => 0, 
    data => { value=>{} },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        local $Data::Dumper::Terse = 1;
        sprintf(q{
           merge_data( $stash, %s );
        }, Data::Dumper::Dumper($n->{value}), $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.delete.key' => {
    text => 'DELETE hashkey', 
    type => 'if',
    holds_children => 0, 
    data => { key=>'' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
           delete $stash->{ '%s' } ;
        }, $n->{key}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.parallel.wait' => {
    text => 'WAIT for children',
    form => '/forms/wait_for_children.js',
    icon => '/static/images/icons/time.png',
    holds_children => 0,
    dsl => sub {
        my ($self, $n, %p ) = @_;

        local $Data::Dumper::Terse = 1;
        my $vars = Data::Dumper::Dumper($n->{data});

        my $code = '';
        if (my $data_key = $n->{data_key}) {
            $code .= qq/\$stash->{$data_key} = /;
        }

        $code .= sprintf(q{
            wait_for_children( $stash, config => %s );
        }, $vars);

        return $code;
    },
};

register 'statement.foreach' => {
    text => 'FOREACH stash[ variable ]',
    type => 'loop',
    data => { variable=>'stash_var', local_var=>'value' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $item ( Util->_array_or_commas( $stash->{'%s'} ) ) {
                local $stash->{'%s'} = $item;
                %s
            }
            
        }, $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.foreach.ci' => {
    text => 'FOREACH CI',
    type => 'loop',
    data => { variable=>'stash_var', local_var=>'value' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $ci ( map { ci->new($_) } Util->_array_or_commas( $stash->{'%s'} ) ) {
                local $stash->{'%s'} = $ci;
                %s
            }
            
        }, $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.foreach.split' => {
    text => 'FOREACH SPLIT /re/', 
    type => 'loop',
    data => { split=>',', variable=>'stash_var', local_var=>'value' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $item ( split _regex('%s'), $stash->{'%s'} ) {
                local $stash->{'%s'} = $item;
                %s
            }
            
        }, $n->{split} // ',', $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.step' => {
    text => 'JOB STEP',
    description=> 'a job step section: PRE,RUN,POST...',
    icon => '/static/images/icons/job.png',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            if( $stash->{job_step} eq q{%s} ) {
                %s
            }
        }, $n->{text}, $self->dsl_build( $n->{children}, %p ) );
    }
};

register 'statement.sub' => {
    text => 'SUB',
    sub_mode => 'declare',
    description=> 'Just group tasks under this but do not run it',
    on_drop_js => q{
        node.attributes.sub_name = new_id_for_task("SUB"); 
    },
    icon => '/static/images/icons/cog_perl.png',
    #icon => '/static/images/icons/shortcut.png',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            %s
        }, $self->dsl_build($n->{children}) );
    }
};

register 'statement.fail' => {
    text => 'FAIL',
    data => { msg => 'abort here' },
    icon => '/static/images/icons/log_e.png',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            Util->_fail( parse_vars( q{%s}, $stash ) );
        }, $n->{msg}, $self->dsl_build( $n->{children}, %p ) );
    }
};

register 'statement.shortcut' => {
    text => 'Task Shortcut',
    icon => '/static/images/icons/shortcut.png',
    form => '/forms/shortcut.js',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        my $scut = $n->{data}{call_shortcut};
        local $Data::Dumper::Terse = 1;
        my $local_stash = '';
        if( ref $n->{data}{config_data} eq 'HASH' ) {
            $n->{data}{stash_data}{shortcut_config} = $n->{data}{config_data};
        }
        if( ref $n->{data}{stash_data} eq 'HASH' ) {
            $local_stash .= sprintf('local $$stash{%s} = %s;'."\n", $_, Data::Dumper::Dumper($n->{data}{stash_data}{$_}) )
                for keys $n->{data}{stash_data};
        }
        sprintf(q{
            {
                %s
                _debug(_loc('Shortcut jumping to %%1', q{%s}) );
                if( ! do {no strict; defined &{ *{ __PACKAGE__ . '::%s' }; } } ) {
                    _fail( _loc('Missing shortcut `%%1`', q{%s} ) );
                }
                %s();
            }
        }, $local_stash, $scut, $scut,$scut,$scut );
    }
};

register 'statement.log' => {
    text => 'LOG message',
    data => { text => 'Message', level=>'info' },
    icon => '/static/images/icons/log.png',
    form => '/forms/log.js',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        my $txt = sprintf('q{%s}', $n->{data}{text} );
        sprintf(q{
            Util->_%s(
                parse_vars(%s,$stash)
            ); 
        }, $n->{data}{level}, $txt);
    }
};

register 'service.echo' => {
    data => { msg => '', args=>{}, arr=>[] },
    handler=>sub{
        my ($self, $c, $data ) = @_;
        $data->{hello} = $data->{msg} || 'world';
        _info (_loc "%1", $data->{hello});
        $data;
    }
};

register 'service.get_date' => {
    data => { date => '' },
    form => '/forms/get_date.js',
    icon => '/static/images/icons/calendar.png',
    name => 'Get date',
    handler=>sub{
        my ($self, $c, $data ) = @_;
        my $return_date;
        if ($data->{date}) {
            try {
                $return_date = "".Class::Date->new($data->{date});
            } catch {
                _fail _loc("Date %1 is not a valid date: %2",$data->{date},shift);
            }
        } else {
            $return_date = "".Class::Date->now();
        }
        $return_date;
    }
};

register 'service.fail' => {
    data => { msg => 'dummy fail' },
    handler=>sub{
        my ($self, $c, $data ) = @_;
        Baseliner::Utils::_fail( $data->{msg} || 'dummy fail' );
    }
};

register 'event.rule.tester' => {
    text => '%1 posted a comment on %2: %3',
    description => 'Dummy Event to Test a Rule',
    vars => ['hello'],
};

register 'statement.var.set' => {
    text => 'SET VAR', data => {},
    type => 'let',
    holds_children => 0, 
    form => '/forms/set_var.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = parse_vars( q{%s}, $stash ); 
        }, $n->{variable}, $n->{value}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.var.set_expr' => {
    text => 'SET EXPR', data => {},
    type => 'let',
    holds_children => 0, 
    form => '/forms/set_expr.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = do { %s };
        }, ( $n->{variable} || Util->_name_to_id($n->{text}) ), $n->{expr} );
    },
};

register 'statement.var.set_to_ci' => {
    text => 'SET VAR to CI', data => {},
    type => 'let',
    holds_children => 0, 
    data => { variable=>'my_varname', from_code=>'', prepend=>'' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = ci->new( '%s' . parse_vars( %s, $stash ) ); 
        }, $n->{variable}, $n->{prepend}, $n->{from_code} || sprintf(q{$stash->{'%s'}},$n->{variable}) );
    },
};

register 'statement.nature.block' => {
    text => 'APPLY NATURE', data => { nature=>'' },
    type => 'loop',
    form => '/forms/nature_block.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                # check if nature applies 
                my $nature = ci->new( '%s' );
                if( my $nature_items = stash_has_nature( $nature, $stash) ) {
                    # load natures config
                    my $variables = $nature->variables->{ $stash->{bl} // '*' } // {};
                    merge_data $variables, $stash, variables_for_bl( $nature, $stash->{bl} ), { _ctx => 'nature' }; 
                    $stash->{nature_items} = $nature_items;
                    
                    %s
                }
            }
        }, [ _array($n->{nature}) ]->[0], $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.stash.local' => {
    text => 'STASH LOCAL', data => {},
    type => 'loop',
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                local $stash = { %$stash };
                
                %s    
            }
        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.project.block' => {
    text => 'APPLY PROJECT', data => { project=>'', bl=>'' },
    type => 'loop',
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                my $project = ci->new( '%s' );
                my $vars = variables_for_bl( $project, $stash->{bl} );
                _info( _loc('Current project *%%1* (%%2)', $project->name, $stash->{bl} ), $vars );
                merge_data $stash, $vars, { _ctx => 'apply project' }; 

                %s    
            }
        }, $n->{project} // 'project', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.eval' => {
    text => 'EVAL', data => { code=>'' },
    form => '/forms/stmt_eval.js', 
    icon => '/static/images/icons/cog_perl.png', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                $stash->{'%s'} = eval { %s };
                if($@) {
                    _fail "ERROR in EVAL: $@";
                }
            }
        }, $n->{data_key} // '', $n->{code} // '', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.do' => {
    text => 'DO', data => { code=>'' },
    icon => '/static/images/icons/cog_perl.png', 
    form => '/forms/stmt_eval.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                my $dk = '%s';
                my $ret = do { %s };
                $stash->{$dk} = $ret if length $dk;
            }
        }, $n->{data_key} // '', $n->{code} // '', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.group' => {
    text => 'GROUP',data => { },
    icon => '/static/images/icons/cog_gears.png', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                my $dk = '%s';
                my $ret = do { 
                    %s 
                }; 
                $stash->{$dk} = $ret if length $dk;
            }
        }, $n->{data_key} // '', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.for' => {
    text => 'FOR eval', data => { varname=>'x', code=>'()' },
    type => 'loop',
    icon => '/static/images/icons/cog_perl.png', 
    form => '/forms/stmt_for.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            for( %s ) {
                local $stash->{'%s'} = $_;
                %s;
            }
        }, $n->{code} // '()', $n->{varname} // 'x',  $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.js.code' => {
    text => 'EVAL JavaScript', data => { code=>'' },
    type => 'loop',
    icon => '/static/images/icons/cog_java.png', 
    form => '/forms/stmt_for.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            require Baseliner::JS;
            Baseliner::JS->run( stash=>$stash, code=>q{%s} ); 
        }, $n->{code} // '()',  $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.code' => {
    text => 'CODE', data => { code=>'' },
    type => 'loop',
    icon => '/static/images/icons/cog_perl.png',
    holds_children => 0,
    form => '/forms/stmt_eval.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            %s;
        }, $n->{code} // '' );
    },
};

register 'statement.project.loop' => {
    text => 'FOR projects with changes DO', data => { },
    type => 'loop',
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            for my $project ( project_changes( $stash ) ) { 
                $stash->{project} = $project->name;
                $stash->{project_mid} = $project->mid;
                $stash->{project_lc} = lc $project->name;
                $stash->{project_uc} = uc $project->name;
                $stash->{current_project} = $project;

                my @project_bls = map { $_->{bl} } _array $project->bls;
                if ( !@project_bls || $stash->{bl} ~~ @project_bls ) {
                    my $vars = variables_for_bl( $project, $stash->{bl} );
                    $stash->{job}->logger->info( _loc('Current project *%%1* (%%2)', $project->name, $stash->{bl} ), $vars );
                    merge_data $stash, $vars, { _ctx => 'project_loop' }; 
                    
                    %s
                } else {
                    $stash->{job}->logger->info( _loc('Project *%%1* skipped for bl %%2', $project->name, $stash->{bl} ) );
                }
            }
        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

# needs the changeset.nature service to fill the stash with natures (create a dependency check?)
register 'statement.if.nature' => {
    text => 'IF EXISTS nature THEN',
    form => '/forms/if_nature.js',
    type => 'if',
    data => { nature=>'', },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        my ($nature) = _array($n->{nature});  # in case we accidently get an array of natures
        sprintf(q{
            if( my $nature = $stash->{natures}{ $project->mid }{'%s'} ) {
                NAT: {  
                    $stash->{current_nature} = $nature;
                    local $stash->{nature_items} = $stash->{project_items}{ $stash->{current_project}->mid }{natures}{ $nature->mid };
                    last NAT if !_array( $stash->{nature_items} );
                    my ($nat_paths, $nat_paths_del) = cut_nature_items( $stash, parse_vars(q{%s},$stash) );
                    local $stash->{ nature_item_paths } = $nat_paths;
                    local $stash->{ nature_item_paths_del } = $nat_paths_del;
                    local $stash->{ nature_items_comma } = join(',', @$nat_paths );
                    local $stash->{ nature_items_quote } = "'" . join("' '", @$nat_paths ) . "'";
                    $stash->{job}->logger->info( _loc('Nature Detected *%%1*', $nature->name ), 
                        +{ map { $_=>$stash->{$_} } qw/nature_items nature_item_paths nature_items_comma nature_items_quote/ } );

                    %s
                };
            }
        }, $nature, $n->{cut_path} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.any_nature' => {
    text => 'IF ANY nature THEN',
    form => '/forms/if_any_nature.js',
    type => 'if',
    data => { natures=>'', },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( _any { exists $stash->{natures}{ $project->mid }{$_} } split /,/, '%s' ) {
                %s
            }
        }, join(',',_array($n->{natures})), $self->dsl_build( $n->{children}, %p ) );
    },
};


register 'statement.if.rollback' => {
    text => 'IF ROLLBACK',
    type => 'if',
    data => { rollback=>'1', },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( $stash->{rollback} eq '%s' ) {
                %s
            }
        }, $n->{rollback}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.include' => {
    text => 'INCLUDE rule',
    icon => '/static/images/icons/cog_perl.png', 
    holds_children => 0,
    data => { id_rule=>'', },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        my $dsl = $self->include_rule( $n->{id_rule}, %p );
        sprintf(q{
                %s;
        }, $dsl );
    },
};

register 'statement.call' => {
    text => 'CALL rule',
    icon => '/static/images/icons/cog.png', 
    holds_children => 0,
    data => { id_rule=>'', },
    dsl => sub { 
        my ($self, $n , %p) = @_;

        sprintf(q{
            call(parse_vars({id_rule => '%s'}, $stash)->{id_rule}, $stash);
        }, $n->{id_rule});
    },
};

sub include_rule {
    my ($self, $id_rule, %p) = @_;
    my @tree = $self->build_tree( $id_rule, undef );
    my $dsl = try {
        $self->dsl_build( \@tree, id_rule=>$id_rule, %p ); 
    } catch {
        _fail( _loc("Error building DSL for rule '%1': %2", $id_rule, shift() ) ); 
    };
    return $dsl;
}

sub get_rules_info {
    my ($self,$p)=@_;
    my $where = {};
    my $sort = $p->{sort} || 'ts';
    $sort = 'name_insensitive' if $sort eq 'rule_name';
    my $dir = $p->{dir} && $p->{dir} eq 'ASC' ? 1 : -1;
    if( $p->{query} ) {
        mdb->query_build( where=>$where, query=>$p->{query}, fields=>[qw(rule_tree rule_name id rule_event rule_type rule_compile_mode username)] ); 
    }
    # my $rs = mdb->rule->find($where)->fields({ rule_tree=>0 })->sort( mdb->ixhash( $sort=>$dir ) );
    my $rs = mdb->rule->aggregate([
            { '$match'=>$where },
            { '$project'=>{ 
                    rule_name=>1, rule_type=>1, rule_compile_mode=>1, 
                    rule_when=>1, rule_event=>1, rule_active=>1, event_name=>1, username=>1, folders=>1,
                    id=>1,ts=>1, name_insensitive=> { '$toLower'=> '$rule_name' } 
                } 
            },
            { '$sort'=>mdb->ixhash( $sort=>$dir ) } 
    ],{ cursor=>1 });
    my @rules;
    while (my $rule = $rs->next) {
        $rule->{event_name} = Baseliner->registry->get( $rule->{rule_event} )->name if $rule->{rule_event};
        push @rules, $rule;
    }
    if($p->{destination} eq 'tree'){
        my $expanded = $p->{query} ? \1 : \0;
        my $ids = $p->{ids};
        my $where = {};
        $where->{id} = mdb->in($ids) if length $ids;
        my @rule_types = sort ('dashboard','form','event','report','pipeline','webservice','independent');
        my $folder_structure = [];
        for my $rule_type (@rule_types){
            my $text = uc(substr $rule_type,0,1).substr($rule_type,1);
            my $temp_structure = {
                text       => $text,
                rule_type  => $rule_type,
                leaf       => \0,
                expandable => \1,
                expanded   => $expanded,
                allowDrop  => \0,
                allowDrag  => \0,
                draggable  => \0,
                children   => []
            };
            map { push $temp_structure->{children}, 
                { text=>$_->{rule_name},
                  leaf=>\1,
                  draggable=>\1,
                  rule_id=>$_->{id},
                  rule_ts=>$_->{ts},
                  rule_type=>$rule_type,
                  rule_active=>$_->{rule_active},
                  rule_when=>$_->{rule_when},
                  rule_event=>$_->{rule_event},
                  event_name=>$_->{event_name},
                  rule_name=>$_->{rule_name},
                  username=>$_->{username}
               } if $_->{rule_type} eq $rule_type 
            } @rules;
            push $folder_structure, $temp_structure;
        }
        my $custom_folder_node = {text=>_loc('Custom Folders'), leaf => \0, expandable => \1, expanded => $expanded, children=> [], 
                is_custom_folders_node=>\1, allowDrop=>\0, allowDrag=>\0, draggable=>\0 };
        my $rs = mdb->rule_folder->find;
        while( my $rule_folder = $rs->next ) {
            my $temp_structure = {
                text           => $rule_folder->{name},
                rule_folder_id => $rule_folder->{id},
                is_folder      => \1,
                leaf           => \0,
                expandable     => \1,
                expanded       => $expanded,
                children       => [],
                allowDrop      => \1,
                allowDrag      => \0
            };
            map {
                push $temp_structure->{children}, 
                { text=>$_->{rule_name}, 
                  leaf=>\1, 
                  rule_id=>$_->{id},
                  rule_ts=>$_->{ts},
                  rule_type=>$_->{rule_type},
                  rule_active=>$_->{rule_active},
                  rule_when=>$_->{rule_when},
                  rule_event=>$_->{rule_event},
                  rule_name=>$_->{rule_name},
                  event_name=>$_->{event_name},
                  username=>$_->{username}
                } if $rule_folder->{id} ~~ $_->{folders};
            } @rules;
            push $custom_folder_node->{children}, $temp_structure;
        }
        push $folder_structure, $custom_folder_node;
        @rules = @{$folder_structure};
    }
    return @rules;
}

sub add_custom_folder {
    my ($self,$p)=@_;
    my $folder_name = $p->{folder_name};
    my $rule_folder_seq;
    die _loc('Folder already exists') if mdb->rule_folder->find({name=>$folder_name})->count();
    if(mdb->master_seq->find_one({_id=>'rule_folder'})){    
        $rule_folder_seq = mdb->master_seq->find_one({_id=>'rule_folder'})->{seq};
    }else{
        $rule_folder_seq = 1;
        mdb->master_seq->insert({_id=>'rule_folder'});
    }
    my $new_id = $rule_folder_seq+1;
    my $folder_info = { name=>$folder_name, id=>$new_id.'', username=>$p->{username}, ts=>mdb->now().'' };
    mdb->rule_folder->insert($folder_info);
    my $ret = mdb->master_seq->update({ _id => 'rule_folder', seq =>$rule_folder_seq }, { '$set' => { seq => $new_id } });
    $folder_info;  
}

sub rename_rule_folder {
    my ($self,$p)=@_;
    my $folder_name = $p->{folder_name};
    die _loc('Folder already exists') if mdb->rule_folder->find({name=>$folder_name})->count();
    my $rule_folder_id = $p->{rule_folder_id};
    my $ret = mdb->rule_folder->update({ id =>$rule_folder_id }, { '$set' => { name => $folder_name, username=>$p->{username}, ts=>mdb->now().'' } });
}

sub delete_rule_folder {
    my ($self,$p)=@_;
    my $rule_folder_id = $p->{rule_folder_id};
    mdb->rule_folder->remove({id=>$rule_folder_id});
    my $rs = mdb->rule->find({ folders=>{ '$elemMatch'=> {'$eq'=>$rule_folder_id } } })->fields({_id=>0, id=>1, folders=>1 });
    while (my $rule = $rs->next) {
        my @new_folders = grep { $_ ne $rule_folder_id } _array $rule->{folders};
        mdb->rule->update({id=>$rule->{id}}, {'$set'=>{folders=>@new_folders}} );
    }
}

sub added_rule_to_folder {
    my ($self,$p)=@_;
    my $rule_id = $p->{rule_id};
    my $rule_folder_id = $p->{rule_folder_id};
    my $folders = mdb->rule->find_one({id=>$rule_id})->{folders} // [];
    $folders = [$folders] if ref $folders ne 'ARRAY';
    push $folders, $rule_folder_id if $rule_folder_id !~ $folders;
    mdb->rule->update({id=>$rule_id}, {'$set'=>{folders=>$folders}} );
}

sub delete_rule_from_folder {
    my ($self,$p)=@_;
    my $rule_id = $p->{rule_id};
    my $rule_folder_id = $p->{rule_folder_id};
    my $folders = mdb->rule->find_one({ id=>$rule_id })->{folders};
    my @new_folders = grep { $_ ne $rule_folder_id } _array $folders;
    mdb->rule->update({id=>$rule_id}, {'$set'=>{folders=>@new_folders}});
}

no Moose;
__PACKAGE__->meta->make_immutable;

1;
