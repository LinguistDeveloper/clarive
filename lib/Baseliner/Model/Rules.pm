package Baseliner::Model::Rules;
use Baseliner::Plug;
use Baseliner::Utils;
use Baseliner::Sugar;
use Baseliner::CompiledRule;
use Try::Tiny;
use v5.10;
use utf8;

# DSL functions, export needed by "contained" mode in dsl_run
use Exporter::Tidy default => [qw( 
    current_task
    semaphore
    parallel_run
    error_trap
    merge_data
    project_changes 
    current_task
    cut_nature_items
    launch
    merge_into_stash
    stash_has_nature
    changeset_projects
    variables_for_bl
    include_rule
)];

BEGIN { extends 'Catalyst::Model' }

with 'Baseliner::Role::Service';

has tidy_up => qw(is rw isa Bool default 1);

register 'event.rule.failed' => {
    description => 'Rule failed',
    vars => ['rc', 'ret', 'rule', 'rule_name']
};

register 'event.rule.trap' => {
    description => 'Rule error trapped',
    vars => ['job_name','bl', 'step', 'output']
};

# generated by rule/* controller:
register 'event.ws.soap_error' => {
    description=>'Soap Error running Rule',
};

register 'event.ws.rule_error' => {
    description=>'Error Running Rule from WS',
};

register 'event.ws.wsdl_error' => {
    description=>'WSDL Error Running Rule from WS',
};

sub init_job_tasks {
    my ($self)=@_;
    return map { +{ text=>$_, key=>'statement.step', icon=>'/static/images/icons/job.png', 
            children=>[], leaf=>\0, expanded=>\1 } 
    } qw(CHECK INIT PRE RUN POST);
}

sub parallel_run {
    my ($name, $mode, $stash, $code)= @_;
    
    my $stash_child = Util->_clone( $stash ); # save stash completely, so that parent does not destroy something by the time fork() child is ready
     
    my $chi_pid = fork;
    if( !defined $chi_pid ) {
        # could not fork
        require Proc::ProcessTable;
        my @children;
        for my $p (_array( Proc::ProcessTable->new->table )){
            push @children, $p->pid if $p->ppid == $$;
        }
        my $msg = _loc( "Children, number=%1, list=%2", scalar(@children), join(',',@children) ); 
        _fail( _loc('Could not fork child from parent pid %1. Check max processes available with `ulimit -u`.',$$), data=>$msg );  
    } elsif( $chi_pid ) {
        # parent
        _log _loc 'Forked child task %1 with pid %2', $name, $chi_pid; 
        if( $mode eq 'fork' ) {
            # fork and wait..
            $stash->{_forked_pids}{ $chi_pid } = $name;
        }
    } else {
        # child
        mdb->disconnect;    # will reconnect later
        my ( $ret, $err );
        $stash = $stash_child;
        
        try {
            $ret = $code->();
        }
        catch {
            $err = shift;
            _error( _loc( 'Detected error in child %1 (%2): %3', $$, $mode, $err ) );
        };
        if ( $mode eq 'fork' ) {
            # fork and wait.., communicate results to parent
            my $res = { ret => $ret, err => $err };
            queue->push( msg => "rule:child:results:$$", data => $res );
        }
        exit 0;    # cannot update stash, because it would override the parent run copy
    }
}

sub error_trap {
    my ($stash, $trap_timeout,$trap_timeout_action, $trap_rollback, $mode, $code)= @_;
    my $job = $stash->{job};
    RETRY_TRAP:
    try {
        $code->();
    } catch {
        my $err = shift;
        if( !$job ) { # we're in a event rule, not a job
            _error( _loc( "Error ignored in rule: %1", $err ) );
            return;
        }
        if ( $job->rollback && !$trap_rollback ) {
            $job->logger->info( _loc "Ignoring trap errors in rollback.  Aborting task", $err );    
            _fail( $err );            
        };
        if( $mode eq 'ignore' ) {
            $job->logger->debug( _loc "Ignored error trapped in rule: %1", $err );    
            return;
        };
        $job->logger->error( _loc "Error trapped in rule: %1", $err );    
        $job->update( status=>'TRAPPED' );

        ## Avoid error if . in stash keys
        my @keys = _get_dotted_keys( $stash, '$stash');

        if ( @keys ) {
            my @complete_keys;
            for my $key ( @keys ) {
                push @complete_keys, $key->{parent}.'->{'.$key->{key}.'}';
                my $parent = eval($key->{parent});
                delete $parent->{$key->{key}};
            }
            _debug("Stash contains variables with '.' removed to avoid errors:\n\n". join(", ", @complete_keys));
        };

        event_new 'event.rule.trap' => { username=>'internal', stash=>$stash, output=>$err } => sub {} => sub{
            # catch and ignore
            my $err = shift;
            _warn( _loc('Could not store event for trapped error: %1', $err ) );
        }; 

        my $last_status;
        my $timeout = $trap_timeout;
        LOOP:
        sleep 4;
        while( 1 ) {
            if ( $last_status eq 'TRAPPED_PAUSED' ) {
                sleep 5;
            } else {
                if ( !$trap_timeout || $trap_timeout eq '0' ) {
                    sleep 5;
                } else {
                    sleep 10;
                    $timeout = $timeout - 10;
                    if ( $timeout gt 0 ) {
                        $job->logger->warn( _loc("%1 seconds remaining to cancel trap with action %2", $timeout, $trap_timeout_action) );
                    } else {
                        $job->trap_action({ action => $trap_timeout_action, comments => _loc("Trap timeout expired.  Action configured: %1", $trap_timeout_action)});
                    }
                }
            }
            $last_status = $job->load->{status};
            if ( $last_status !~ /TRAPPED/ ) {
                last;
            }
        }
        if( $last_status eq 'RETRYING' ) {
            $job->logger->info( _loc "Retrying task", $err );    
            goto RETRY_TRAP;
        } elsif( $last_status eq 'SKIPPING' ) {
            $job->logger->info( _loc "Skipping task", $err );    
            return;
        } elsif( $last_status eq 'ERROR' ) { # ERROR
            $job->logger->info( _loc "Aborting task", $err );    
            _fail( $err );
        } else {
           goto LOOP; 
        }
    };
}

sub semaphore {
    my ($data, $stash)=@_;
    require Baseliner::Sem;
    parse_vars( $data, $stash );
    my $sem = Baseliner::Sem->new( $data );
    _info( _loc 'Semaphore queued for %1', $data->{key} );
    return $sem;
}

sub tree_format {
    my ($self, @tree_in)=@_;

    my @tree_out;
    for my $n ( @tree_in ) {
        my $chi = delete $n->{children};
        $n = $n->{attributes} if $n->{attributes};
        $chi = delete $n->{children} unless ref $chi eq 'ARRAY' && @$chi;
        delete $n->{attributes};
        delete $n->{disabled};
        delete $n->{id};
        $n->{active} //= 1;
        $n->{disabled} = $n->{active} ? \0 : \1;
        my @chi = $self->tree_format( _array($chi) );
        #$n->{children} = \@chi;
        if( @chi ) {
            $n->{children} = \@chi;
            $n->{leaf} = \0;
            $n->{expanded} = $n->{expanded} eq 'false' ? \0 : \1;
        } elsif( ! ${$n->{leaf} // \1} ) {  # may be a folder with no children
            $n->{children} = []; 
            $n->{expanded} = $n->{expanded} eq 'false' ? \0 : \1;
        }
        delete $n->{loader};  
        delete $n->{isTarget};  # otherwise you cannot drag-drop around a node
        #_log $n;
        push @tree_out, $n;
    }
    return @tree_out;
}

sub build_tree {
    my ($self, $id_rule, $parent, %p) = @_;
    # TODO run query just once and work with a hash ->hash_for( id_parent )
    my $rule = mdb->rule->find_one({ '$or'=>[ {id=>"$id_rule"},{rule_name=>"$id_rule"} ] });
    _fail _loc 'Could not find rule %1', $id_rule unless $rule;
    my $rule_tree_json = $rule->{rule_tree};
    if( $rule_tree_json ) {
        my $rule_tree = Util->_decode_json( $rule_tree_json );
        _fail _loc 'Invalid rule tree json data: not an array' unless ref $rule_tree eq 'ARRAY';
        return $self->tree_format( @$rule_tree );
        return @$rule_tree;
    } else {
        if( $rule->{rule_type} eq 'chain' ) {
            return $self->init_job_tasks;
        }
        _fail _loc 'Rule tree is empty for rule %1', $id_rule;
    }
}

sub _is_true { 
    my($self,$v) = @_; 
    return (ref $v eq 'SCALAR' && !${$v}) || $v eq 'false' || !$v;
}

# called when rule is saved
sub dsl_build_and_test {
    my ($self,$stmts, %p )=@_;
    my $dsl = $self->dsl_build( $stmts, id_rule=>$p{id_rule}, %p ); 
    my $rule = Baseliner::CompiledRule->new( id_rule=>$p{id_rule}, dsl=>$dsl, ts=>$p{ts} ); # send ts so its stored as this rule save timestamp
    $rule->compile;
    die $rule->errors if $rule->errors;
    return $dsl;
}

sub dsl_build {
    my ($self,$stmts, %p )=@_;
    return '' if !$stmts || ( ref $stmts eq 'HASH' && !%$stmts );
    my $id_rule = $p{id_rule} //  '';
    my $rule_name = $p{rule_name} // do {
        my $doc = $p{doc} // ( $id_rule ?  mdb->rule->find_one({ id=>"$id_rule" }) : {} );
        $$doc{rule_name} || $id_rule || '';
    };
    #_debug $stmts;
    my @dsl;
    require Data::Dumper;
    my $spaces = sub { '   ' x $_[0] };
    my $level = 0;
    my $cnt = 0;
    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Deparse = 1;
    for my $s ( _array $stmts ) {
        local $p{no_tidy} = 1; # just one tidy is enough
        my $children = $s->{children} || {};
        my $attr = defined $s->{attributes} ? $s->{attributes} : $s;  # attributes is for a json treepanel

     #    if ( $attr->{key} eq 'statement.catalog.folder' && $attr->{text} =~ /Base/){
     # _log _dump $attr->{prueba};
     #        #_error _dump $s;    
     #    }

        # is active ?
        next if defined $attr->{active} && !$attr->{active}; 
        #next if (ref $attr->{disabled} eq 'SCALAR' && ${$attr->{disabled}} ) || $attr->{disabled} eq 'true' || $attr->{disabled};
        delete $attr->{loader} ; # node cruft
        delete $attr->{events} ; # node cruft
        #_debug $attr;
        my $name = _strip_html( $attr->{text} );
        my $name_id = Util->_name_to_id( $name );
        my $id_task = sprintf '%s-%09d', $name_id, $cnt;
        $cnt++; 
        my $data = $attr->{data} || {};
        
        my $run_forward = _bool($attr->{run_forward},1);  # if !defined, default is true
        my $run_rollback = _bool($attr->{run_rollback},1); 
        my $error_trap = $attr->{error_trap} if $attr->{error_trap} && $attr->{error_trap} ne 'none';
        my $trap_timeout = $attr->{trap_timeout} if $attr->{error_trap} && $attr->{error_trap} ne 'none';
        my $trap_timeout_action = $attr->{trap_timeout_action} if $attr->{error_trap} && $attr->{error_trap} ne 'none';
        my $trap_rollback = $attr->{trap_rollback} if $attr->{error_trap} && $attr->{error_trap} ne 'none';
        my $needs_rollback_mode = $data->{needs_rollback_mode} // 'none'; 
        my $needs_rollback_key  = $data->{needs_rollback_key} // '';
        my $parallel_mode = length $attr->{parallel_mode} && $attr->{parallel_mode} ne 'none' ? $attr->{parallel_mode} : '';
        push @dsl, sprintf( '%s:', $attr->{goto_label} ) . "\n" if length $attr->{goto_label};  
        push @dsl, sprintf( 'sub %s {', $attr->{sub_name} ) . "\n" if length $attr->{sub_name};  

        if( my $semaphore_key = $attr->{semaphore_key} ) {
            # consider using a hash: $stash->{_sem}{ $semaphore_key } = ...
            push @dsl, sprintf( 'local $stash->{_sem} = semaphore({ key=>parse_vars(q{%s},$stash), who=>parse_vars(q{%s},$stash) }, $stash)->take;', $semaphore_key, $name ) . "\n"; 
        }
        my $timeout = $attr->{timeout};
        my $rb_close_me = 0;
        if( !$run_forward && !$run_rollback ) {
            push @dsl, sprintf( 'if( 0 ) { # not forward or backwards ')."\n";
            $rb_close_me = 1;
        }
        elsif( !$run_forward ) {
            if ( !$needs_rollback_key || $needs_rollback_key eq '<always>') {
                push @dsl, sprintf( 'if( $$stash{rollback} ) { # only if we are going backwards ')."\n";
            } else {
                push @dsl, sprintf( 'if( $$stash{rollback} && $stash->{needs_rollback}{q{%s}} ) { # only if we are going backwards ', $needs_rollback_key)."\n";
            }
            $rb_close_me = 1;
        }
        elsif( !$run_rollback ) {
            push @dsl, sprintf( 'if( !$$stash{rollback} ) { # only if we are going forward ')."\n";
            $rb_close_me = 1;
        }
        else {
            if ( $needs_rollback_key && $needs_rollback_key ne '<always>') {
                push @dsl, sprintf( 'if( !$$stash{rollback} || ( $$stash{rollback} && $stash->{needs_rollback}{q{%s}} )) { # forward or back if rollback_key ', $needs_rollback_key)."\n";
                $rb_close_me = 1;
            } 
        }
        my ($data_key) = $attr->{data_key} =~ /^\s*(\S+)\s*$/ if $attr->{data_key};
        my $closure = $attr->{closure};

        #my $key_filter = $data->{task}->[0] ? $data->{task}->[0] : 1 ;
        # my $filter = $task_id; #$attr->{filter} ? $attr->{filter} : $key_filter;


        push @dsl, sprintf( '# task: %s', $name ) . "\n"; 
        

        my $key;
        my $reg;
        if( length $attr->{key} ) {
            $key = $attr->{key};
            $reg = Baseliner->registry->get( $key );
        }else{
            _debug $s;
            _fail _loc 'Missing dsl/service key for node %1', $name;            
        }
        ###############################################################################################
        if ($reg->{filter}) {
            push @dsl, sprintf( '$stash->{id_task} = q{%s};', $id_task ) . "\n"; 
            push @dsl, sprintf( 'if ( !$stash->{catalog_filter} || exists $stash->{filters}{q{%s}} ){', $id_task) . "\n";    
        }
        ###############################################################################################
        if( $closure ) {
            push @dsl, sprintf( 'current_task($stash, q{%s}, q{%s}, q{%s}, sub{', $id_rule, $rule_name, $name )."\n";
        } elsif( ! $attr->{nested} ) {
            push @dsl, sprintf( 'current_task($stash, q{%s}, q{%s}, q{%s});', $id_rule, $rule_name, $name )."\n";
        }
        if( length $timeout && $timeout > 0 ) {
            push @dsl, sprintf( 'alarm %s;', $timeout )."\n";
        }
        push @dsl, sprintf( '_debug(q{=====| Current Rule Task: %s} );', $name)."\n" if $p{verbose}; 
        if( length $attr->{key} ) {
            push @dsl, sprintf('$stash->{needs_rollback}{q{%s}} = $stash->{job_step};', $needs_rollback_key || $name_id) if $needs_rollback_mode eq 'nb_always';
            push @dsl, sprintf('parallel_run(q{%s},q{%s},$stash,sub{', $name, $parallel_mode) if $parallel_mode;
            push @dsl, sprintf( 'error_trap($stash,"%s","%s","%s","%s", sub {',$trap_timeout || 0,$trap_timeout_action || "", $trap_rollback || '1', $error_trap) if $error_trap; 
            # my $key = $attr->{key};
            # my $reg = Baseliner->registry->get( $key );
            if( $reg->isa( 'BaselinerX::Type::Service' ) ) {
                push @dsl, $spaces->($level) . '{';
                if( length $attr->{sub_name} ) {
                    push @dsl, $spaces->($level) . sprintf(q{   my $config = parse_vars +{ %{ %s || {} }, %{ delete($$stash{shortcut_config}) // {}} }, $stash;}, Data::Dumper::Dumper( $data ) );
                } else {
                    if($key eq 'service.web.request'){
                        $data->{body} = Util->_fix_utf8_to_xml_entities($data->{body});
                    }
                    push @dsl, $spaces->($level) . sprintf(q{   my $config = parse_vars %s, $stash;}, Data::Dumper::Dumper( $data ) );
                }
                push @dsl, $spaces->($level) . sprintf(q{   launch( "%s", q{%s}, $stash, $config => '%s' );}, $key, $name, ($data_key//'') );
                push @dsl, $spaces->($level) . '}';
                #push @dsl, $spaces->($level) . sprintf('merge_data($stash, $ret );', Data::Dumper::Dumper( $data ) );
            } else {
                push @dsl, _array( $reg->{dsl}->($self, { %$attr, %$data, children=>$children, data_key=>$data_key }, %p ) );
            }
            push @dsl, '});' if $error_trap; # current_task close
            push @dsl, '});' if $parallel_mode; # current_task close
            push @dsl, '});' if $closure; # current_task close
            push @dsl, sprintf( '$stash->{_sem}->release if $stash->{_sem};') if $attr->{semaphore_key};
        } else {
            _debug $s;
            _fail _loc 'Missing dsl/service key for node %1', $name;
        }
        push @dsl, "}\n" if $rb_close_me;
        if( length $attr->{sub_name} ) {
            push @dsl, "};\n";
            push @dsl, sprintf( "%s();\n", $attr->{sub_name} ) if $attr->{sub_mode} && $attr->{sub_mode} eq 'run';
        }
        ###############################################################################
        if ($reg->{filter}) {
            push @dsl, "};\n";
        }        
        ###############################################################################
    }

    my $dsl = join "\n", @dsl;
    if( $self->tidy_up && !$p{no_tidy} ) {
        require Perl::Tidy;
        my $tidied = '';
        Perl::Tidy::perltidy( argv => '--maximum-line-length=160 --quiet --no-log', source => \$dsl, destination => \$tidied );
        return $tidied;
    } else {
        return $dsl;
    }
}

sub wait_for_children {
    my ($self, $stash, %p ) = @_;
    my $chi_pids = $stash->{_forked_pids};
    if( my @pids = keys %$chi_pids ) {
        _info( _loc('Waiting for return code from children pids: %1', join(',', @pids ) ) );
        my @failed;
        my @oks;
       
        for my $pid ( @pids ) {
            waitpid $pid, 0;
            delete $chi_pids->{$pid};
            if( my $res = queue->pop( msg=>"rule:child:results:$pid" ) ) {
                if( $res->{err} ) {
                    _error( $res->{err} );
                    push @failed, $pid;
                } else {
                    push @oks, $pid;
                }
            }
        }
        if( @failed ) {
            _fail( _loc('Error detected in children, pids failed: %1. Ok: %2', join(',',@failed ), join(',',@oks) ) );
        } else {
            _info( _loc('Done waiting for return code from children pids: %1', join(',',@pids ) ) );
        }
    } else {
#        _debug( _loc('No children to wait for.') );
    }
}

sub dsl_run {
    my ($self, %p ) = @_;

    local $@;
    my $id_rule = $p{id_rule};
    
    my $ret;
    my $stash = $p{stash} // {};

    merge_into_stash( $stash, BaselinerX::CI::variable->default_hash ) unless $p{no_merge_variables}; 

    ## local $Baseliner::Utils::caller_level = 3;
    ############################## EVAL DSL Tasks
    my $rule = Baseliner::CompiledRule->new( ( $id_rule ? (id_rule=>$id_rule):() ), dsl=>$p{dsl} );
    $rule->compile;

    $rule->run(stash=>$stash);  # if there's a compile error it wont run
    ##############################

    if( my $err = $rule->errors ) {
        if( $p{simple_error} ) {
            _error( _loc("Error during DSL Execution: %1", $err) ) unless $p{simple_error} > 1;
            _fail $err;
        } else {
            _fail( _loc("Error during DSL Execution: %1", $err) );
        }
        _debug "DSL:\n",  $self->dsl_listing( $rule->dsl );
    } else {
        _debug "DSL:\n",  $self->dsl_listing( $rule->dsl ) if $p{logging};
    }
    return { stash=>$stash, dsl=>($rule->dsl || $rule->package) };  # TODO storing dsl everywhere maybe a waste of space
}

# used by events
sub run_rules {
    my ($self, %p) = @_;
    my $when = $p{when};
    local $Baseliner::_no_cache = 0;
    my @rules = 
        $p{id_rule} 
            ? ( mdb->rule->find_one({ '$or'=>[ {id=>"$p{id_rule}"},{rule_name=>"$p{id_rule}"} ] }) )
            : mdb->rule->find({ rule_event => $p{event}, rule_type => ($p{rule_type} // 'event'), rule_when => $when, rule_active => mdb->true })
              ->sort(mdb->ixhash(rule_seq=>1, id=>1))->all;
    my $stash = $p{stash};
    my @rule_log;
    local $ENV{BASELINER_LOGCOLOR} = 0;
    
    my $mid = $stash->{mid} if $stash;
    my $sem;
    if( defined $mid && @rules && $p{use_semaphore} ) {
        require Baseliner::Sem;
        $sem = Baseliner::Sem->new( key=>'event:'.$stash->{mid}, who=>"rules:$when", internal=>1 );
        $sem->take;
    }

    for my $rule ( @rules ) {
        my ($runner_output, $rc, $ret,$err);
        my $id_rule = $rule->{id};
        try {
            my $t0=[Time::HiRes::gettimeofday];

            ################### RUN THE RULE DSL ######################
            require Capture::Tiny;
            ($runner_output) = Capture::Tiny::tee_merged(sub{
                try {
                    $ret = $self->dsl_run( id_rule=>$id_rule, stash=>$stash, simple_error=>$p{simple_error} );
                } catch {
                    $err = shift // _loc('Unknown error running rule: %1', $id_rule ); 
                };
            });
            # report controlled errors
            if( $err ) {
                if ( $rule->{rule_when} !~ /online/ ) {
                    event_new 'event.rule.failed' => { username => 'internal', dsl=>$ret->{dsl}, rule=>$id_rule, rule_name=>$rule->{rule_name}, stash=>$stash, output => $runner_output } => sub {};
                }           
                if( $p{simple_error} ) {
                    _error( _loc("Error running rule '%1' (%2): %3", $rule->{rule_name}, $rule->{rule_when}, $err ) ) unless $p{simple_error} > 1; 
                    _fail $err; 
                } else {
                    _fail( _loc("Error running rule '%1' (%2): %3", $rule->{rule_name}, $rule->{rule_when}, $err ) ); 
                }
            }
        } catch {
            my $err_global = shift;
            $rc = 1;
            if( ref $p{onerror} eq 'CODE') {
                if ( $rule->{rule_when} !~ /online/ ) {
                    event_new 'event.rule.failed' => { username => 'internal', dsl=>$ret->{dsl}, rc=>$rc, ret=>$ret->{stash}, rule => $id_rule, rule_name => $rule->{rule_name}, stash => $stash, output => $runner_output } => sub {};
                }
                $p{onerror}->( { err=>$err_global, ret=>$ret->{stash}, id=>$id_rule, dsl=>$ret->{dsl}, stash=>$stash, output=>$runner_output, rc=>$rc } );
            } elsif( ! $p{onerror} ) {
                _fail "(rule $id_rule): ".$err_global;
            }
        };
        push @rule_log, { ret=>$ret->{stash}, id => $id_rule, dsl=>$ret->{dsl}, stash=>$stash, output=>$runner_output, rc=>$rc };
    }
    if( $sem ) {
        $sem->release;
    }
    return { stash=>$stash, rule_log=>\@rule_log }; 
}

# used by job_chain
sub run_single_rule {
    my ($self, %p ) = @_;
    local $Baseliner::_no_cache = 0;
    $p{stash} //= {};
    my $stash = $p{stash};
    my $rule = mdb->rule->find_one({ '$or'=>[ {id=>"$p{id_rule}"},{rule_name=>"$p{id_rule}"} ] });
    
    _fail _loc 'Rule with id `%1` not found', $p{id_rule} unless $rule;
    my $rule_id = $rule->{id};
    my @tree = $self->build_tree( $p{id_rule}, undef );
    #local $self->{tidy_up} = 0;
    my $t0=[Time::HiRes::gettimeofday];

    #my $ret = try {
        ################### RUN THE RULE DSL ######################
        $self->dsl_run( id_rule=>$rule_id, stash=>$p{stash}, %p );
    #} catch {
    #    _fail( _loc("Error running rule '%1': %2", $rule->{rule_name}, shift() ) ); 
    #};
    #return { ret=>$ret, dsl=>'' };
}

sub dsl_listing {
    my ($self,$dsl)=@_;
    my $lin = 1;
    return join '', map { $lin++.": ".$_."\n" } split /\n/, $dsl;
}

######################################## GLOBAL SUBS

sub merge_data {
    my ($dest,@hashes)=@_;
    $dest = {} unless ref $dest eq 'HASH';
    for my $hash ( @hashes ) {
        next unless ref $hash eq 'HASH';
        for my $k ( keys %$hash ) {
            $dest->{$k} = $hash->{$k};
        }
    }
    parse_vars( $dest, $dest );
}


sub project_changes {
    my ($stash)=@_;
    if( !$stash->{project_changes} ) {
        _warn _loc('No project changes detected');
        return ();
    } else {
        return map { 
            my $p = $_->{project};
            if( Util->_blessed( $p )  ) {
                $p;
            } else {
                if( $p->can('mid') ) {
                    ci->new( $p->mid );
                } else {
                    ci->new( $p );  # is a number then, or try my luck
                }
            }
        } _array( $stash->{project_changes} );
    }
}

sub current_task {
    my ($stash,$id_rule, $rule_name, $name, $code)=@_;
    $name = parse_vars( $name, $stash );  # so we can have vars in task names
    $Baseliner::_rule_current_id = $id_rule;
    $Baseliner::_rule_current_name = $rule_name;
    $stash->{current_rule_id} = $id_rule;
    $stash->{current_rule_name} = $rule_name;
    $stash->{current_task_name} = $name;

    if( my $job = $stash->{job} ) {
        $job->start_task( $name ) if $job->can('start_task');
    }
    $code->() if $code;
}

sub cut_nature_items {
    my ($stash,$tail)=@_;
    my @items = _array( $stash->{nature_items} );
    # items to write
    my @items_write = grep { $_->status ne 'D' } @items;
    my @paths_write = grep { length } map { $_->path_tail( $tail ) } @items_write;
    # items deleted
    my @items_del   = grep { $_->status eq 'D' } @items;
    my @paths_del   = grep { length } map { $_->path_tail( $tail ) } @items_del;
    
    _fail _loc 'Could not find any paths in nature items that match cut path `%1`', $tail 
        unless ( @paths_write + @paths_del );
    return ( \@paths_write, \@paths_del );
}

# launch runs service, merge return into stash and returns what the service returns
sub launch {  
    my ($key, $task, $stash, $config, $data_key )=@_;   
    my $reg = Baseliner->registry->get( $key );
    $task = parse_vars( $task, $stash ) if $reg->{parse_vars};
    #_log "running container for $key";
    my $return_data = try { 
        $reg->run_container( $stash, $config );
    } catch {
        my $err = shift;
        die _loc( 'Error running task * %1 *: %2', $task, $err ) . "\n"; # there's another catch later, so no need to _fail here
    };
    # TODO milestone for service
    #_debug $ret;
    my $refr = ref $return_data;
    my $mergeable = $refr eq 'HASH' || Scalar::Util::blessed($return_data); 
    if( $mergeable || $refr eq 'ARRAY' || !$refr ) {
        # merge into stash
        merge_into_stash( $stash, ( $data_key eq '=' && $mergeable ? $return_data : { $data_key => $return_data } ) ) if length $data_key;
        return $return_data;
    } else {
        return {};
    }
}

sub merge_into_stash {
    my ($stash, $data) = @_;
    return unless ref $data eq 'HASH';
    while( my($k,$v) = each %$data ) {
        $stash->{$k} = $v;
    }
    return $stash
}

sub stash_has_nature {
    my ($nature,$stash) = @_;
    $nature = ci->new( $nature ) unless ref $nature;
    my $nature_items = $nature->filter_items( items=>$stash->{items} ); # save => 1 ??  
    return $nature_items; 
}

sub changeset_projects {
    my $stash = shift;
    # for each changeset, get project and group changesets
    my %projects;
    for my $cs ( _array( $stash->{changesets} ) ) {
        $cs = ci->new( $cs ) unless ref $cs;
        for my $project ( $cs->related( does=>'Project' ) ) {
            $projects{ $project->mid } = $project;
        }
    }
    #my $project = ci->new( 6901 );  # TEF
    return values %projects;
}

#sub project_changed {
#    my $stash = shift;
#    # for each changeset, get project and group changesets
#    my %projects;
#    for my $project ( _array( $stash->{project_changes} ) ) {
#        $cs = ci->new( $cs ) unless ref $cs;
#        for my $project ( $cs->related( does=>'Project' ) ) {
#            $projects{ $project->mid } = $project;
#        }
#    }
#    #my $project = ci->new( 6901 );  # TEF
#    return values %projects;
#}

sub variables_for_bl {
    my ($ci, $bl) = @_; 
    my $vars = $ci->variables // { _no_vars=>1 }; 
    my $vars_common_bl = $vars->{'*'} // {};
    my $vars_for_bl = $vars->{$bl} // { _no_vars_for_bl=>$bl } if length $bl && $bl ne '*';
    +{ %$vars_common_bl, %$vars_for_bl };
}

############################## STATEMENTS

register 'statement.if.var' => {
    text => 'IF var THEN',
    type => 'if',
    form => '/forms/variable_value.js',
    data => { variable=>'', value=>'' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( $stash->{'%s'} eq '%s' ) {
                %s
            }
            
        }, $n->{variable}, $n->{value} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if_not.var' => {
    text => 'IF var ne value THEN',
    type => 'if',
    form => '/forms/variable_value.js',
    data => { variable=>'', value=>'' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( $stash->{'%s'} ne '%s' ) {
                %s
            }
            
        }, $n->{variable}, $n->{value} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.condition' => {
    text => 'IF condition THEN',
    type => 'if',
    data => { condition =>'1' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( %s ) {
                %s
            }
            
        }, $n->{condition}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.else' => {
    text => 'ELSE',
    type => 'if',
    nested => 1,   # avoids a "current_task" before
    data => {},
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            else {
                %s
            }
            
        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.elsif' => {
    text => 'ELSIF condition THEN',
    type => 'if',
    nested => 1,
    data => { condition =>'1' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            elsif( %s ) {
                %s
            }
            
        }, $n->{condition}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.var.list' => {
    text => 'IF var in LIST THEN',
    type => 'if',
    form => '/forms/variable_values.js',
    data => { variable=>'', values=>'' },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        my @conditions;
        my $complete_condition;
        my @values = split /,/,$n->{values};

        for ( @values ) {
            push @conditions, sprintf(q{$stash->{'%s'} eq '%s'},$n->{variable},$_);
        }
        $complete_condition = join " || ", @conditions;

        sprintf(q/
            if( %s ) {
                %s
            }
    
        /, $complete_condition, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.try' => {
    text => 'TRY statement', 
    type => 'if',
    data => { },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            use Try::Tiny;
            try {
                %s
            };
        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.try_with_catch' => {
    text => 'TRY statement (needs a catch)', 
    type => 'if',
    data => { },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            use Try::Tiny;
            try {
                %s
            }
        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.catch' => {
    text => 'CATCH statement (needs a try_with_catch)', 
    type => 'if',
    data => { },
    nested => 1,
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            catch {
                %s
            };
        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.let.merge' => {
    text => 'MERGE value INTO stash', 
    type => 'let',
    holds_children => 0, 
    data => { value=>{} },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        local $Data::Dumper::Terse = 1;
        sprintf(q{
           merge_data( $stash, %s );
        }, Data::Dumper::Dumper($n->{value}), $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.delete.key' => {
    text => 'DELETE hashkey', 
    type => 'if',
    holds_children => 0, 
    data => { key=>'' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
           delete $stash->{ '%s' } ;
        }, $n->{key}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.parallel.wait' => {
    text => 'WAIT for children',
    data => { variable=>'stash_var', local_var=>'value' },
    icon => '/static/images/icons/time.png',
    holds_children => 0, 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            Baseliner::Model::Rules->wait_for_children( $stash );
        });
    },
};

register 'statement.foreach' => {
    text => 'FOREACH stash[ variable ]',
    type => 'loop',
    data => { variable=>'stash_var', local_var=>'value' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $item ( Util->_array_or_commas( $stash->{'%s'} ) ) {
                local $stash->{'%s'} = $item;
                %s
            }
            
        }, $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.foreach.ci' => {
    text => 'FOREACH CI',
    type => 'loop',
    data => { variable=>'stash_var', local_var=>'value' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $ci ( map { ci->new($_) } Util->_array_or_commas( $stash->{'%s'} ) ) {
                local $stash->{'%s'} = $ci;
                %s
            }
            
        }, $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.foreach.split' => {
    text => 'FOREACH SPLIT /re/', 
    type => 'loop',
    data => { split=>',', variable=>'stash_var', local_var=>'value' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $item ( split _regex('%s'), $stash->{'%s'} ) {
                local $stash->{'%s'} = $item;
                %s
            }
            
        }, $n->{split} // ',', $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.step' => {
    text => 'JOB STEP',
    description=> 'a job step section: PRE,RUN,POST...',
    icon => '/static/images/icons/job.png',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            if( $stash->{job_step} eq q{%s} ) {
                %s
            }
        }, $n->{text}, $self->dsl_build( $n->{children}, %p ) );
    }
};

register 'statement.sub' => {
    text => 'SUB',
    sub_mode => 'declare',
    description=> 'Just group tasks under this but do not run it',
    on_drop_js => q{
        node.attributes.sub_name = new_id_for_task("SUB"); 
    },
    icon => '/static/images/icons/group.gif',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            %s
        }, $self->dsl_build($n->{children}) );
    }
};

register 'statement.fail' => {
    text => 'FAIL',
    data => { msg => 'abort here' },
    icon => '/static/images/icons/delete.gif',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            Util->_fail( q{%s} );
        }, $n->{msg}, $self->dsl_build( $n->{children}, %p ) );
    }
};

register 'statement.shortcut' => {
    text => 'Task Shortcut',
    icon => '/static/images/icons/shortcut.png',
    form => '/forms/shortcut.js',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        my $scut = $n->{data}{call_shortcut};
        local $Data::Dumper::Terse = 1;
        my $local_stash = '';
        if( ref $n->{data}{config_data} eq 'HASH' ) {
            $n->{data}{stash_data}{shortcut_config} = $n->{data}{config_data};
        }
        if( ref $n->{data}{stash_data} eq 'HASH' ) {
            $local_stash .= sprintf('local $$stash{%s} = %s;'."\n", $_, Data::Dumper::Dumper($n->{data}{stash_data}{$_}) )
                for keys $n->{data}{stash_data};
        }
        sprintf(q{
            {
                %s
                _debug(_loc('Shortcut jumping to %%1', q{%s}) );
                if( ! do {no strict; defined &{ *{ __PACKAGE__ . '::%s' }; } } ) {
                    _fail( _loc('Missing shortcut `%%1`', q{%s} ) );
                }
                %s();
            }
        }, $local_stash, $scut, $scut,$scut,$scut );
    }
};

register 'statement.log' => {
    text => 'LOG message or variable',
    data => { msg => '', level=>'info', content_type=>'literal' },
    icon => '/static/images/icons/log-msg.gif',
    form => '/forms/log.js',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        my $txt = sprintf( ($n->{data}{content_type} eq 'literal' ? 'qq{%s}' : '%s'), $n->{data}{text} );
        sprintf(q{
            Util->_%s(%s); 
        }, $n->{data}{level}, $txt);
    }
};

register 'service.echo' => {
    data => { msg => '', args=>{}, arr=>[] },
    handler=>sub{
        my ($self, $c, $data ) = @_;
        $data->{hello} = $data->{msg} || 'world';
        _info (_loc "%1", $data->{hello});
        $data;
    }
};

register 'service.fail' => {
    data => { msg => 'dummy fail' },
    handler=>sub{
        my ($self, $c, $data ) = @_;
        Baseliner::Utils::_fail( $data->{msg} || 'dummy fail' );
    }
};

register 'event.rule.tester' => {
    text => '%1 posted a comment on %2: %3',
    description => 'Dummy Event to Test a Rule',
    vars => ['hello'],
};

register 'statement.var.set' => {
    text => 'SET VAR', data => {},
    type => 'let',
    holds_children => 0, 
    form => '/forms/set_var.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = parse_vars( q{%s}, $stash ); 
        }, $n->{variable}, $n->{value}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.var.set_expr' => {
    text => 'SET EXPR', data => {},
    type => 'let',
    holds_children => 0, 
    form => '/forms/set_expr.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = do { %s };
        }, ( $n->{variable} || Util->_name_to_id($n->{text}) ), $n->{expr} );
    },
};

register 'statement.var.set_to_ci' => {
    text => 'SET VAR to CI', data => {},
    type => 'let',
    holds_children => 0, 
    data => { variable=>'my_varname', from_code=>'', prepend=>'' },
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = ci->new( '%s' . parse_vars( %s, $stash ) ); 
        }, $n->{variable}, $n->{prepend}, $n->{from_code} || sprintf(q{$stash->{'%s'}},$n->{variable}) );
    },
};

register 'statement.nature.block' => {
    text => 'APPLY NATURE', data => { nature=>'' },
    type => 'loop',
    form => '/forms/nature_block.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                # check if nature applies 
                my $nature = ci->new( '%s' );
                if( my $nature_items = stash_has_nature( $nature, $stash) ) {
                    # load natures config
                    my $variables = $nature->variables->{ $stash->{bl} // '*' } // {};
                    merge_data $variables, $stash, variables_for_bl( $nature, $stash->{bl} ), { _ctx => 'nature' }; 
                    $stash->{nature_items} = $nature_items;
                    
                    %s
                }
            }
        }, [ _array($n->{nature}) ]->[0], $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.stash.local' => {
    text => 'STASH LOCAL', data => {},
    type => 'loop',
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                local $stash = { %$stash };
                
                %s    
            }
        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.project.block' => {
    text => 'APPLY PROJECT', data => { project=>'' },
    type => 'loop',
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                my $project = '%s';
                my $variables = $stash->{$project}->variables->{ $stash->{bl} // '*' } // {};
                merge_data $stash, $variables, { _ctx => 'apply_variables' }; 
                
                %s    
            }
        }, $n->{project} // 'project', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.eval' => {
    text => 'EVAL', data => { code=>'' },
    form => '/forms/stmt_eval.js', 
    icon => '/static/images/icons/cog.png', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                $stash->{'%s'} = eval { %s };
                if($@) {
                    _fail "ERROR in EVAL: $@";
                }
            }
        }, $n->{data_key} // '', $n->{code} // '', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.do' => {
    text => 'DO', data => { code=>'' },
    icon => '/static/images/icons/cog.png', 
    form => '/forms/stmt_eval.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                my $dk = '%s';
                my $ret = do { %s };
                $stash->{$dk} = $ret if length $dk;
            }
        }, $n->{data_key} // '', $n->{code} // '', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.for' => {
    text => 'FOR eval', data => { varname=>'x', code=>'()' },
    type => 'loop',
    icon => '/static/images/icons/cog.png', 
    form => '/forms/stmt_for.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            for( %s ) {
                local $stash->{'%s'} = $_;
                %s;
            }
        }, $n->{code} // '()', $n->{varname} // 'x',  $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.js.code' => {
    text => 'EVAL JavaScript', data => { code=>'' },
    type => 'loop',
    icon => '/static/images/icons/javascript.png', 
    form => '/forms/stmt_for.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            require Baseliner::JS;
            Baseliner::JS->run( stash=>$stash, code=>q{%s} ); 
        }, $n->{code} // '()',  $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.code' => {
    text => 'CODE', data => { code=>'' },
    type => 'loop',
    icon => '/static/images/icons/cog.png',
    holds_children => 0,
    form => '/forms/stmt_eval.js', 
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            %s;
        }, $n->{code} // '' );
    },
};

register 'statement.project.loop' => {
    text => 'FOR projects with changes DO', data => { },
    type => 'loop',
    dsl => sub { 
        my ($self, $n, %p ) = @_;
        sprintf(q{
            for my $project ( project_changes( $stash ) ) { 
                $stash->{project} = $project->name;
                $stash->{project_mid} = $project->mid;
                $stash->{project_lc} = lc $project->name;
                $stash->{project_uc} = uc $project->name;
                $stash->{current_project} = $project;

                my @project_bls = map { $_->{bl} } _array $project->bls;
                if ( !@project_bls || $stash->{bl} ~~ @project_bls ) {
                    my $vars = variables_for_bl( $project, $stash->{bl} );
                    $stash->{job}->logger->info( _loc('Current project *%%1* (%%2)', $project->name, $stash->{bl} ), $vars );
                    merge_data $stash, $vars, { _ctx => 'project_loop' }; 
                    
                    %s
                } else {
                    $stash->{job}->logger->info( _loc('Project *%%1* skipped for bl %%2', $project->name, $stash->{bl} ) );
                }
            }
        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

# needs the changeset.nature service to fill the stash with natures (create a dependency check?)
register 'statement.if.nature' => {
    text => 'IF EXISTS nature THEN',
    form => '/forms/if_nature.js',
    type => 'if',
    data => { nature=>'', },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        my ($nature) = _array($n->{nature});  # in case we accidently get an array of natures
        sprintf(q{
            if( my $nature = $stash->{natures}{ $project->mid }{'%s'} ) {
                NAT: {  
                    $stash->{current_nature} = $nature;
                    local $stash->{nature_items} = $stash->{project_items}{ $stash->{current_project}->mid }{natures}{ $nature->mid };
                    last NAT if !_array( $stash->{nature_items} );
                    my ($nat_paths, $nat_paths_del) = cut_nature_items( $stash, parse_vars(q{%s},$stash) );
                    local $stash->{ nature_item_paths } = $nat_paths;
                    local $stash->{ nature_item_paths_del } = $nat_paths_del;
                    local $stash->{ nature_items_comma } = join(',', @$nat_paths );
                    local $stash->{ nature_items_quote } = "'" . join("' '", @$nat_paths ) . "'";
                    $stash->{job}->logger->info( _loc('Nature Detected *%%1*', $nature->name ), 
                        +{ map { $_=>$stash->{$_} } qw/nature_items nature_item_paths nature_items_comma nature_items_quote/ } );

                    %s
                };
            }
        }, $nature, $n->{cut_path} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.any_nature' => {
    text => 'IF ANY nature THEN',
    form => '/forms/if_any_nature.js',
    type => 'if',
    data => { natures=>'', },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( _any { exists $stash->{natures}{ $project->mid }{$_} } split /,/, '%s' ) {
                %s
            }
        }, join(',',_array($n->{natures})), $self->dsl_build( $n->{children}, %p ) );
    },
};


register 'statement.if.rollback' => {
    text => 'IF ROLLBACK',
    type => 'if',
    data => { rollback=>'1', },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( $stash->{rollback} eq '%s' ) {
                %s
            }
        }, $n->{rollback}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.include' => {
    text => 'INCLUDE rule',
    icon => '/static/images/icons/cog.png', 
    holds_children => 0,
    data => { id_rule=>'', },
    dsl => sub { 
        my ($self, $n , %p) = @_;
        my $dsl = $self->include_rule( $n->{id_rule}, %p );
        sprintf(q{
                %s;
        }, $dsl );
    },
};

sub include_rule {
    my ($self, $id_rule, %p) = @_;
    my @tree = $self->build_tree( $id_rule, undef );
    my $dsl = try {
        $self->dsl_build( \@tree, id_rule=>$id_rule, %p ); 
    } catch {
        _fail( _loc("Error building DSL for rule '%1': %2", $id_rule, shift() ) ); 
    };
    return $dsl;
}

1;
