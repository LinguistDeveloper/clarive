package Baseliner::Model::Rules;
use Baseliner::Moose;
BEGIN { extends 'Catalyst::Model' }

use Perl::Tidy ();
use Baseliner::Core::Registry ':dsl';
use Baseliner::Utils;
use Baseliner::Sugar;
use Baseliner::Model::Permissions;
use BaselinerX::CI::variable;
use Try::Tiny;
use v5.10;
use experimental 'autoderef', 'smartmatch';

with 'Baseliner::Role::Service';

has tidy_up => qw(is rw isa Bool default 1);

register 'event.rule.failed' => {
    description => _locl('Rule failed'),
    vars => ['rc', 'ret', 'rule', 'rule_name']
};

register 'event.rule.create' => {
    description => _locl('Rule created'),
    vars => ['rule_name','rule_type','username']
};

register 'event.rule.update' => {
    description => _locl('Rule updated'),
    vars => ['rule_name','rule_id','rule_type','username']
};

register 'event.rule.delete' => {
    description => _locl('Rule deleted'),
    vars => ['rule_name','rule_id','rule_type','username']
};

# generated by rule/* controller:
register 'event.ws.soap_error' => {
    description=>_locl('Soap Error running Rule'),
};

register 'event.ws.rule_error' => {
    description=>_locl('Error Running Rule from WS'),
};

register 'event.ws.wsdl_error' => {
     description=>_locl('WSDL Error Running Rule from WS'),
};

register 'event.rule.ws' => {
    description => _locl('Webservice rule call'),
    vars => ['username', 'rule_id', 'rule_name', 'ws_params', 'ws_response']
};

sub list_rules {
    my $self = shift;

    return
      map { { id => $_->{id}, title => $_->{rule_name} } }
      mdb->rule->find->fields( { _id => 0, id => 1, rule_name => 1 } )->sort( { rule_name => 1 } )->all;
}

sub init_job_tasks {
    my ($self)=@_;
    return map { +{ text=>$_, key=>'statement.step', icon=>'/static/images/icons/job.svg',
            children=>[], leaf=>\0, expanded=>\1 }
    } qw(CHECK INIT PRE RUN POST);
}

sub init_fieldlets_tasks {
    my ($self)=@_;
    return map {
        my $node;
        $node->{leaf} = \1;
        $node->{text} = _loc( $_->{name} );
        $node->{key} = $_->{key};
        $node->{icon} = $_->{icon};
        $node->{name} = $_->{name};
        $node->{data} = $_;
        $node->{data}{fieldletType} = $_->{key};
        $node->{data}{hidden} = 0;
        $node->{data}{allowBlank} = 0;
        $node->{data}{editable} = 1;
        $node->{data}{active} = 1;
        $node->{data}{colspan} = 12;
        $node->{data}{hide_from_edit_cb} = '0';
        $node->{ts} = mdb->ts;
        # $node->{who} = 'root'; # TODO get user from $c->username
        $node
    } Baseliner::Core::Registry->get('fieldlet.system.status_new')->registry_node->raw,
    Baseliner::Core::Registry->get('fieldlet.system.title')->registry_node->raw;
}

sub init_report_tasks {
    my ( $self, $rule_name, $rule_owner ) = @_;

    _fail _loc('Rule not found') unless $rule_name;
    _fail _loc('User not found') unless $rule_owner;

    $rule_name = "'" . $rule_name . "'";
    my @node;
    my @initial_elements;

    push @initial_elements, {
        title => _loc('Security'),
        code  => <<"END_MSG"
\$stash->{report_security} = sub {
    my (\%p) = \@_;
    ## For instance: Only visible for owner
    if ( \$p{username} eq '$rule_owner' ) {
      return 1;
    }
    return 0;
};
END_MSG
    };

    push @initial_elements, {
        title => 'Meta',
        code  => <<"END_MSG"
#For instance: Showing Mid and Title of topics
\$stash->{report_meta} = sub {
    {
        fields => {
            ids => [ 'id', 'title'],
            columns => [
                {id => 'id',  text => 'Mid'},
                {id => 'title',     text => 'Title'}
            ],
        },
        report_name => _loc($rule_name),
        report_type => 'custom',
        hide_tree => \\1,
    }
};
END_MSG
    };

    push @initial_elements, {
        title => _loc('Data'),
        code  => <<'END_MSG'
#Continue Same example

#In $stash->{report_params} params that come are:   $start,$limit,$sort,$dir,$query
# You can treat them as you need

$stash->{report_data} = sub{
    my $p = $stash->{report_params};
    my ( $start, $limit, $sort, $dir, $query ) = @{$p}{qw(start limit sort dir query)};

    my $where = {};
    my $rs = mdb->topic->find( $where );
    my $cnt = $rs->count;

    my @rows;
    while ( my $row = $rs->next() ) {
        push @rows,
            {
                id        => $row->{mid},
                title     => $row->{title}
            };
    }
    return { data => \@rows, cnt => $cnt };
};
END_MSG
    };

    foreach my $element (@initial_elements) {
        push @node, map {
            {
                leaf           => \1,
                text           => $element->{title},
                key            => $_->{key},
                icon           => $_->{icon},
                palette        => \0,
                run_sub        => \1,
                data           => { code => $element->{code} },
                holds_children => \0,
                nested         => \0
            }
            } Baseliner::Core::Registry->get('statement.perl.code')
            ->registry_node->raw;
    }
    return @node;
}

sub tree_format {
    my ($self, @tree_in)=@_;
    my @tree_out;
    for my $n ( @tree_in ) {
        my $chi = delete $n->{children};
        $n = $n->{attributes} if $n->{attributes};
        $chi = delete $n->{children} unless ref $chi eq 'ARRAY' && @$chi;
        delete $n->{attributes};
        delete $n->{disabled};
        delete $n->{id} unless $n && $n->{id} && $n->{id} =~/rule-/;
        $n->{active} //= 1;
        $n->{disabled} = $n->{active} ? \0 : \1;
        my @chi = $self->tree_format( _array($chi) );
        #$n->{children} = \@chi;
        if( @chi ) {
            $n->{children} = \@chi;
            $n->{leaf} = \0;
            $n->{expanded} = $n->{expanded} && $n->{expanded} eq 'false' ? \0 : \1;
        } elsif( ($n->{leaf} && $n->{leaf} eq 'false') ||(! ${$n->{leaf} // \1}) ) {  # may be a folder with no children
            $n->{children} = [];
            $n->{expanded} = $n->{expanded} eq 'false' ? \0 : \1;
        }
        delete $n->{loader};
        delete $n->{isTarget};  # otherwise you cannot drag-drop around a node
        #_log $n;
        push @tree_out, $n;
    }
    return @tree_out;
}

sub load_tree {
    my $self = shift;
    my (%params) = @_;

    my $rule = $params{rule};

    if (!$rule) {
        my $id_rule = $params{id_rule};

        my $rule = mdb->rule->find_one(
            {'$or' => [{id => "$id_rule"}, {rule_name => "$id_rule"}]});
        _fail _loc('Could not find rule %1', $id_rule) unless $rule;
    }

    my $tree = try { Util->_decode_json( $rule->{rule_tree} ) } catch { +{} };

    return $self->tree_format(@$tree);
}

sub build_tree {
    my ($self, $id_rule, $parent, %p) = @_;

    my $rule;

    # Temporary workaround
    if (ref $id_rule) {
        $rule = $id_rule;
        $id_rule = $rule->{id};
    }
    else {
        # TODO run query just once and work with a hash ->hash_for( id_parent )
        $rule = mdb->rule->find_one({ '$or'=>[ {id=>"$id_rule"},{rule_name=>"$id_rule"} ] });
        _fail _loc('Could not find rule %1', $id_rule) unless $rule;
    }

    my $rule_name = $rule->{rule_name};
    my $rule_tree_json = $rule->{rule_tree};
    my $rule_owner = $rule->{username};

    if( $rule_tree_json ) {
        my $rule_tree = Util->_decode_json( $rule_tree_json );
        _fail _loc('Invalid rule tree json data: not an array') unless ref $rule_tree eq 'ARRAY';
        my @tf = $self->tree_format( @$rule_tree );
        return @tf;
    } else {
        my @tf;
        if( $rule->{rule_type} eq 'pipeline' ) {
            @tf = $self->init_job_tasks;
        }
        if ( $rule->{rule_type} eq 'form') {
            @tf = $self->init_fieldlets_tasks;
        }
        if ( $rule->{rule_type} eq 'report') {
            @tf = $self->init_report_tasks($rule_name, $rule_owner);
        }
        $self->write_rule(
            id_rule    => $id_rule,
            stmts_json => Util->_encode_json(\@tf),
            username   => $p{username} || 'clarive',
            was        => $p{ts} || ''._ts
        );

        # _warn _loc 'Rule tree is empty for rule %1', $id_rule;
        return @tf;
    }
}

sub _is_true {
    my($self,$v) = @_;
    return (ref $v eq 'SCALAR' && !${$v}) || $v eq 'false' || !$v;
}

sub get_rule_tree {
    my ( $self, $id_rule ) = @_;

    _fail _loc("Missing id_rule") unless $id_rule;

    my $rule = mdb->rule->find_one( { id => $id_rule } );
    _fail _loc( "Rule %1 not found", $id_rule ) unless $rule;

    return $rule->{rule_tree};
}

sub all_nodes {
    my ($self, %p )=@_;
    my @nodes = $self->build_tree( $p{id_rule} );
    my $dig; $dig = sub{
        map {
          ( $_, $dig->( _array( $$_{children} ) ) )
        } @_;
    };
    $dig->( @nodes );
}

sub dsl_build {
    my ($self,$stmts, %p )=@_;
    return '' if !$stmts || ( ref $stmts eq 'HASH' && !%$stmts );
    my $id_rule = $p{id_rule} //  '';
    my $rule_name = $p{rule_name} // do {
        my $doc = $p{doc} // ( $id_rule ?  mdb->rule->find_one({ id=>"$id_rule" }) : {} );
        $$doc{rule_name} || $id_rule || '';
    };
    #_debug $stmts;
    my @dsl;
    require Data::Dumper;
    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Deparse = 1;
    local $Data::Dumper::Deepcopy = 1;

    for my $s ( _array $stmts ) {
        my $level = $s->{level} // 0;

        local $p{no_tidy} = 1; # just one tidy is enough
        my $children = $s->{children} || [];
        my $attr = defined $s->{attributes} ? $s->{attributes} : $s;  # attributes is for a json treepanel
        # is active ?
        next if defined $attr->{active} && !$attr->{active};
        #next if (ref $attr->{disabled} eq 'SCALAR' && ${$attr->{disabled}} ) || $attr->{disabled} eq 'true' || $attr->{disabled};
        delete $attr->{loader} ; # node cruft
        delete $attr->{events} ; # node cruft
        #_debug $attr;
        my $name = _strip_html( $attr->{text} );
        my $name_id = Util->_name_to_id( $name );
        my $data = $attr->{data} || {};
        # put the properties (metadata) into the data so that we see it in $config in services
        $data->{meta}{$_}= blessed($attr->{$_})
            ? "$attr->{$_}"
            : $attr->{$_}
            for grep !/^data$/, keys %$attr;

        my $run_forward = _bool($attr->{run_forward},1);  # if !defined, default is true
        my $run_rollback = _bool($attr->{run_rollback},1);

        my $is_error_trap = $attr->{error_trap} && $attr->{error_trap} ne 'none' ? 1 : 0;

        my $needs_rollback_mode = $attr->{needs_rollback_mode} // 'none';
        my $needs_rollback_key  = $attr->{needs_rollback_key} // '';
        my $parallel_mode = length $attr->{parallel_mode} && $attr->{parallel_mode} ne 'none' ? $attr->{parallel_mode} : '';
        my $debug_mode = length $attr->{debug_mode} && $attr->{debug_mode} ne 'none' ? $attr->{debug_mode} : '';
        push @dsl, sprintf( '%s:', $attr->{goto_label} ) . "\n" if length $attr->{goto_label};
        push @dsl, sprintf( 'sub %s {', $attr->{sub_name} ) . "\n" if length $attr->{sub_name};

        my $timeout = $attr->{timeout};
        my $rb_close_me = 0;
        if( !$run_forward && !$run_rollback ) {
            push @dsl, sprintf( 'if( 0 ) { # not forward or backwards ')."\n";
            $rb_close_me = 1;
        }
        elsif( !$run_forward ) {
            if ( !$needs_rollback_key || $needs_rollback_key eq '<always>') {
                push @dsl, sprintf( 'if( $$stash{rollback} ) { # only if we are going backwards ')."\n";
            } else {
                push @dsl, sprintf( 'if( $$stash{rollback} && $stash->{needs_rollback}{q{%s}} ) { # only if we are going backwards ', $needs_rollback_key)."\n";
            }
            $rb_close_me = 1;
        }
        elsif( !$run_rollback ) {
            push @dsl, sprintf( 'if( !$$stash{rollback} ) { # only if we are going forward ')."\n";
            $rb_close_me = 1;
        }
        else {
            if ( $needs_rollback_key && $needs_rollback_key ne '<always>') {
                push @dsl, sprintf( 'if( !$$stash{rollback} || ( $$stash{rollback} && $stash->{needs_rollback}{q{%s}} )) { # forward or back if rollback_key ', $needs_rollback_key)."\n";
                $rb_close_me = 1;
            }
        }
        my ($data_key) = $attr->{data_key} =~ /^\s*(\S+)\s*$/ if $attr->{data_key};
        my $closure = $attr->{closure};
        push @dsl, sprintf( '# task: %s', $name // '') . "\n";
        if( $closure ) {
            push @dsl, sprintf( 'current_task($stash, id_rule => q{%s}, rule_name => q{%s}, name => q{%s}, level => %s, cb => sub{', $id_rule, $rule_name, $name, $level )."\n";
        } elsif( ! $attr->{nested} ) {
            push @dsl, sprintf( 'current_task($stash, id_rule => q{%s}, rule_name => q{%s}, name => q{%s}, level => %s);', $id_rule, $rule_name, $name // '', $level)."\n";
        }
        push @dsl, sprintf( '_debug("BEFORE STASH", $stash);' ) . "\n" if $debug_mode eq 'stash';
        if( length $timeout && $timeout > 0 ) {
            push @dsl, sprintf( 'alarm %s;', $timeout )."\n";
        }
        push @dsl, sprintf( '_debug(q{=====| Current Rule Task: %s} );', $name)."\n" if $p{verbose};
        if( length $attr->{key} ) {
            push @dsl, sprintf('$stash->{needs_rollback}{q{%s}} = $stash->{job_step};', $needs_rollback_key || $name_id) if $needs_rollback_mode eq 'nb_always';
            push @dsl, sprintf('parallel_run(q{%s},q{%s},$stash,sub{', $name, $parallel_mode) if $parallel_mode;

            if ($is_error_trap) {
                my $error_trap          = $attr->{error_trap};
                my $trap_timeout        = $attr->{trap_timeout} || 0;
                my $trap_timeout_action = $attr->{trap_timeout_action} // '';
                my $trap_max_retry      = $attr->{trap_max_retry} // -1;
                my $trap_rollback       = $attr->{trap_rollback} // 1;

                push @dsl, sprintf(<<'EOF', $trap_timeout, $trap_timeout_action, $trap_max_retry, $trap_rollback, $error_trap );
            error_trap(
                stash => $stash,
                trap_timeout => "%s",
                trap_timeout_action => "%s",
                trap_max_retry => "%s",
                trap_rollback => "%s",
                mode => "%s",
                code => sub {
EOF
            }

            if( my $semaphore_key = $attr->{semaphore_key} ) {
                # consider using a hash: $stash->{_sem}{ $semaphore_key } = ...
                push @dsl, sprintf( 'local $stash->{_sem} = semaphore({ key=>parse_vars(q{%s},$stash), who=>parse_vars(q{%s},$stash) }, $stash)->take;', $semaphore_key, $name ) . "\n";
            }
            my $key = $attr->{key};
            use Baseliner::Model::Registry;
            my $reg = Baseliner::Model::Registry->get( $key );
            _fail _loc('Could not find rule key `%1`', $key) unless blessed $reg;
            if( $reg->isa( 'BaselinerX::Type::Service' ) ) {
                push @dsl, '{';
                if( length $attr->{sub_name} ) {
                    push @dsl, sprintf(q{   my $config = parse_vars +{ %{ %s || {} }, %{ delete($$stash{shortcut_config}) // {}} }, $stash;}, Data::Dumper::Dumper( $data ) );
                } else {
                    push @dsl, sprintf(q{   my $config = parse_vars %s, $stash;}, Data::Dumper::Dumper( $data ) );
                }
                push @dsl, sprintf(q{   launch( "%s", q{%s}, $stash, $config => '%s' );}, $key, $name, ($data_key//'') );
                push @dsl, '}';
                #push @dsl, $spaces->($level) . sprintf('merge_data($stash, $ret );', Data::Dumper::Dumper( $data ) );
            } else {
                $children = [map { {%{$_ || {}}, level => $level + 1}} _array $children];
                push @dsl, _array( $reg->{dsl}->($self, { %$attr, %$data, children=>$children, data_key=>$data_key }, %p ) );
            }
            push @dsl, sprintf( '$stash->{_sem}->release if $stash->{_sem};') if $attr->{semaphore_key};
            push @dsl, '});' if $is_error_trap; # current_task close
            push @dsl, '});' if $parallel_mode; # current_task close
            push @dsl, '});' if $closure; # current_task close
        } else {
            _debug $s;
            _fail _loc('Missing dsl/service key for node %1', $name);
        }
        push @dsl, "}\n" if $rb_close_me;
        if( length $attr->{sub_name} ) {
            push @dsl, "};\n";
            push @dsl, sprintf( "%s();\n", $attr->{sub_name} ) if $attr->{sub_mode} && $attr->{sub_mode} eq 'run';
        }
        push @dsl, sprintf( '_debug("AFTER STASH", $stash);' ) . "\n" if $debug_mode eq 'stash';
    }

    my $dsl = join "\n", @dsl;

    # WTF? $self can be class name
    if ( ref $self && $self->tidy_up && !$p{no_tidy} ) {
        my $tidied = '';
        Perl::Tidy::perltidy(
            argv        => '-npro --maximum-line-length=160 --quiet --no-log',
            source      => \$dsl,
            destination => \$tidied
        );
        $dsl = $tidied;
    }

    return $dsl;
}

sub compile_rules {
    my $self = shift;
    my (%params) = @_;

    my $rule_precompile = $params{rule_precompile} // 'none';

    return if $rule_precompile eq 'none';

    my @rules = mdb->rule->find( { rule_active => mdb->true, $rule_precompile ne 'always' ? (rule_compile_mode=>'precompile') : () } )
      ->sort( mdb->ixhash( rule_seq => 1, id => 1 ) )->all;

    require Baseliner::RuleRunner;
    foreach my $rule (@rules) {
        try {
            my $rule_runner = Baseliner::RuleRunner->new;
            $rule_runner->compile_rule(rule => $rule);
        } catch {
            my $error = shift;

            _log _loc('Error during rule precompilation: %1', $error);
        };
    }
}

sub dsl_listing {
    my ($self,$dsl)=@_;
    my $lin = 1;
    return join '', map { $lin++.": ".$_."\n" } split /\n/, $dsl;
}

######################################## GLOBAL SUBS

#sub project_changed {
#    my $stash = shift;
#    # for each changeset, get project and group changesets
#    my %projects;
#    for my $project ( _array( $stash->{project_changes} ) ) {
#        $cs = ci->new( $cs ) unless ref $cs;
#        for my $project ( $cs->related( does=>'Project' ) ) {
#            $projects{ $project->mid } = $project;
#        }
#    }
#    #my $project = ci->new( 6901 );  # TEF
#    return values %projects;
#}

############################## STATEMENTS

register 'statement.if.var' => {
    text => _locl('IF var THEN'),
    type => 'if',
    form => '/forms/variable_value.js',
    data => { variable=>'', value=>'' },
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( $stash->{'%s'} eq '%s' ) {
                %s
            }

        }, $n->{variable}, $n->{value} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.var_condition' => {
    text => 'IF var condition THEN',
    type => 'if',
    form => '/forms/if_var_condition.js',
    data => {},
    dsl  => sub {
        my ( $self, $n, %p ) = @_;

        my $conditions = [];
        foreach my $key ( keys %$n ) {
            if ( $key =~ m/^operand_a\[(\d+)\]$/ ) {
                my $i = $1;

                push @$conditions,
                  {
                    operand_a => $n->{"operand_a[$i]"},
                    operator  => $n->{"operator[$i]"},
                    options   => {
                        ignore_case => !!$n->{"options[$i].ignore_case"},
                    },
                    operand_b => $n->{"operand_b[$i]"},
                  };
            }
        }

        sprintf(
            q{
            if ( condition_check( $stash, '%s', %s ) ) {
                %s;
            }
        }, $n->{when}, Data::Dumper::Dumper($conditions),
            $self->dsl_build( $n->{children}, %p )
        );
    },
};

register 'statement.if_not.var' => {
    text => _locl('IF var ne value THEN'),
    type => 'if',
    form => '/forms/variable_value.js',
    data => { variable=>'', value=>'' },
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( $stash->{'%s'} ne '%s' ) {
                %s
            }

        }, $n->{variable}, $n->{value} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.condition' => {
    text => _locl('IF condition THEN'),
    type => 'if',
    data => { condition =>'1' },
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( %s ) {
                %s
            }

        }, $n->{condition}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.else' => {
    text => _locl('ELSE'),
    icon => '/static/images/icons/else.svg',
    type => 'if',
    nested => 1,   # avoids a "current_task" before
    data => {},
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            else {
                %s
            }

        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.elsif' => {
    text => _locl('ELSIF condition THEN'),
    icon => '/static/images/icons/if_else.svg',
    type => 'if',
    nested => 1,
    data => { condition =>'1' },
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            elsif( %s ) {
                %s
            }

        }, $n->{condition}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.var.list' => {
    text => _locl('IF var in LIST THEN'),
    type => 'if',
    form => '/forms/variable_values.js',
    data => { variable=>'', values=>'' },
    dsl => sub {
        my ($self, $n , %p) = @_;
        my @conditions;
        my $complete_condition;
        my @values = split /,/,$n->{values};

        for ( @values ) {
            push @conditions, sprintf(q{$stash->{'%s'} eq '%s'},$n->{variable},$_);
        }
        $complete_condition = join " || ", @conditions;

        sprintf(q/
            if( %s ) {
                %s
            }

        /, $complete_condition, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.try' => {
    text => _locl('TRY statement (without catch)'),
    type => 'if',
    data => { },
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            use Try::Tiny;
            try {
                %s
            };
        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.try_with_catch' => {
    text => _locl('TRY statement (needs a catch)'),
    type => 'if',
    data => { },
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            use Try::Tiny;
            try {
                %s
            }
        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.catch' => {
    text => _locl('CATCH statement (needs a try_with_catch)'),
    type => 'if',
    data => { },
    nested => 1,
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            catch {
                %s
            };

        }, $self->dsl_build( $n->{children}, %p) );
    },
};

register 'statement.retry' => {
    text => _locl('RETRY statement'),
    type => 'if',
    form => '/forms/retry.js',
    data => { attempts => 1, pause => 0 },
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            Util->_retry(sub { %s }, attempts => %s, pause => %s);
        }, $self->dsl_build( $n->{children}, %p), $n->{data}->{attempts} // 1, $n->{data}->{pause} // 0);
    },
};

register 'statement.let.merge' => {
    text => _locl('MERGE value INTO stash'),
    type => 'let',
    holds_children => 0,
    data => { value=>{} },
    dsl => sub {
        my ($self, $n, %p ) = @_;
        local $Data::Dumper::Terse = 1;
        sprintf(q{
           merge_data( $stash, %s );
        }, Data::Dumper::Dumper($n->{value}), $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.delete.key' => {
    text => _locl('DELETE hashkey'),
    type => 'if',
    holds_children => 0,
    data => { key=>'' },
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
           delete $stash->{ '%s' } ;
        }, $n->{key}, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.delete.trap_action' => {
    text => _locl('DELETE last trap action'),
    type => 'if',
    holds_children => 0,
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
           delete $stash->{_last_trap_action};
        });
    },
};

register 'statement.parallel.wait' => {
    text => _locl('WAIT for children'),
    form => '/forms/wait_for_children.js',
    icon => '/static/images/icons/slot.svg',
    holds_children => 0,
    dsl => sub {
        my ($self, $n, %p ) = @_;

        local $Data::Dumper::Terse = 1;
        my $vars = Data::Dumper::Dumper($n->{data});

        my $code = '';
        if (my $data_key = $n->{data_key}) {
            $code .= qq/\$stash->{$data_key} = /;
        }

        $code .= sprintf(q{
            wait_for_children( $stash, config => %s );
        }, $vars);

        return $code;
    },
};

register 'statement.foreach' => {
    text => _locl('FOREACH stash[ variable ]'),
    type => 'loop',
    data => { variable=>'stash_var', local_var=>'value' },
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $item ( Util->_array_or_commas( $stash->{'%s'} ) ) {
                local $stash->{'%s'} = $item;
                %s
            }

        }, $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.foreach.ci' => {
    text => _locl('FOREACH CI'),
    type => 'loop',
    data => { variable=>'stash_var', local_var=>'value' },
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $ci ( map { ci->new($_) } Util->_array_or_commas( $stash->{'%s'} ) ) {
                local $stash->{'%s'} = $ci;
                %s
            }

        }, $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.foreach.split' => {
    text => _locl('FOREACH SPLIT /re/'),
    type => 'loop',
    data => { split=>',', variable=>'stash_var', local_var=>'value' },
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            foreach my $item ( split _regex('%s'), $stash->{'%s'} ) {
                local $stash->{'%s'} = $item;
                %s
            }

        }, $n->{split} // ',', $n->{variable}, $n->{local_var} // 'value', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.step' => {
    text => _locl('JOB STEP'),
    description=> _locl('a job step section: PRE,RUN,POST...'),
    icon => '/static/images/icons/job.svg',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            if( $stash->{job_step} eq q{%s} ) {
                %s
            }
        }, $n->{text}, $self->dsl_build( $n->{children}, %p ) );
    }
};

register 'statement.sub' => {
    text => _locl('SUB'),
    sub_mode => 'declare',
    description=> _locl('Just group tasks under this but do not run it'),
    on_drop_js => q{
        node.attributes.sub_name = new_id_for_task("SUB");
    },
    icon => '/static/images/icons/cog_perl.svg',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            %s
        }, $self->dsl_build($n->{children}) );
    }
};

register 'statement.fail' => {
    text => _locl('FAIL'),
    data => { msg => 'abort here' },
    icon => '/static/images/icons/error_red.svg',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        sprintf(q{
            Util->_fail( parse_vars( q{%s}, $stash ) );
        }, $n->{msg} // 'abort here' );
    }
};

register 'statement.shortcut' => {
    text => _locl('Task Shortcut'),
    icon => '/static/images/icons/shortcut.svg',
    form => '/forms/shortcut.js',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        my $scut = $n->{data}{call_shortcut};
        local $Data::Dumper::Terse = 1;
        my $local_stash = '';
        if( ref $n->{data}{config_data} eq 'HASH' ) {
            $n->{data}{stash_data}{shortcut_config} = $n->{data}{config_data};
        }
        if( ref $n->{data}{stash_data} eq 'HASH' ) {
            $local_stash .= sprintf('local $$stash{%s} = %s;'."\n", $_, Data::Dumper::Dumper($n->{data}{stash_data}{$_}) )
                for keys $n->{data}{stash_data};
        }
        sprintf(q{
            {
                %s
                _debug(_loc('Shortcut jumping to %%1', q{%s}) );
                if( ! do {no strict; defined &{ *{ __PACKAGE__ . '::%s' }; } } ) {
                    _fail( _loc('Missing shortcut `%%1`', q{%s} ) );
                }
                %s();
            }
        }, $local_stash, $scut, $scut,$scut,$scut );
    }
};

register 'statement.log' => {
    text => _locl('LOG message'),
    data => { text => 'Message', level=>'info' },
    icon => '/static/images/icons/log.svg',
    form => '/forms/log.js',
    dsl=>sub{
        my ($self, $n, %p ) = @_;
        my $txt = sprintf('q{%s}', $n->{data}{text} );
        sprintf(q{
            Util->_%s(
                parse_vars(%s,$stash)
            );
        }, $n->{data}{level}, $txt);
    }
};

register 'service.echo' => {
    data => { msg => '', args=>{}, arr=>[] },
    handler=>sub{
        my ($self, $c, $data ) = @_;
        $data->{hello} = $data->{msg} || 'world';
        _info (_loc("%1", $data->{hello}));
        $data;
    }
};

register 'service.get_date' => {
    data => { date => '' },
    form => '/forms/get_date.js',
    icon => '/static/images/icons/calendar.svg',
    name => _locl('Get date'),
    handler=>sub{
        my ($self, $c, $data ) = @_;
        my $return_date;
        if ($data->{date}) {
            try {
                $return_date = "".Class::Date->new($data->{date});
            } catch {
                _fail _loc("Date %1 is not a valid date: %2",$data->{date},shift);
            }
        } else {
            $return_date = "".Class::Date->now();
        }
        $return_date;
    }
};

register 'service.fail' => {
    data => { msg => 'dummy fail' },
    handler=>sub{
        my ($self, $c, $data ) = @_;
        Baseliner::Utils::_fail( $data->{msg} || 'dummy fail' );
    }
};

register 'event.rule.tester' => {
    text => _locl('%1 posted a comment on %2: %3'),
    description => _locl('Dummy Event to Test a Rule'),
    vars => ['hello'],
};

register 'statement.var.set' => {
    text => _locl('SET VAR'), data => {},
    type => 'let',
    holds_children => 0,
    form => '/forms/set_var.js',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = parse_vars( q{%s}, $stash );
        }, $n->{variable}, $n->{value} );
    },
};

register 'statement.var.push' => {
    text => _locl('PUSH VAR'), data => {},
    type => 'let',
    holds_children => 0,
    form => '/forms/push_var.js',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            do {
                my $variable = '%s';
                $stash->{$variable} = [ _array $stash->{$variable} ];
                push @{ $stash->{$variable} }, parse_vars( '%s', $stash );

                if ( '%s' ) {
                    $stash->{$variable} = [ _unique _array $stash->{$variable} ];
                }
            };
        }, $n->{variable}, $n->{value}, $n->{uniq} // 1 );
    },
};

register 'statement.var.set_expr' => {
    text => _locl('SET EXPR'), data => {},
    type => 'let',
    holds_children => 0,
    form => '/forms/set_expr.js',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = do { %s };
        }, ( $n->{variable} || Util->_name_to_id($n->{text}) ), $n->{expr} );
    },
};

register 'statement.var.set_to_ci' => {
    text => _locl('SET VAR to CI'), data => {},
    type => 'let',
    holds_children => 0,
    data => { variable=>'my_varname', from_code=>'', prepend=>'' },
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            $stash->{'%s'} = ci->new( '%s' . parse_vars( %s, $stash ) );
        }, $n->{variable}, $n->{prepend}, $n->{from_code} || sprintf(q{$stash->{'%s'}},$n->{variable}) );
    },
};

register 'statement.nature.block' => {
    text => _locl('APPLY NATURE'), data => { nature=>'' },
    type => 'loop',
    form => '/forms/nature_block.js',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                # check if nature applies
                my $nature = ci->new( '%s' );
                if( my $nature_items = stash_has_nature( $nature, $stash) ) {
                    # load natures config
                    my $variables = $nature->variables->{ $stash->{bl} // '*' } // {};
                    merge_data $variables, $stash, variables_for_bl( $nature, $stash->{bl} ), { _ctx => 'nature' };
                    $stash->{nature_items} = $nature_items;

                    %s
                }
            }
        }, [ _array($n->{nature}) ]->[0], $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.stash.local' => {
    text => _locl('STASH LOCAL'), data => {},
    type => 'loop',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                local $stash = { %$stash };

                %s
            }
        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.project.block' => {
    text => _locl('APPLY PROJECT'), data => { project=>'', bl=>'' },
    type => 'loop',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                my $project = ci->new( '%s' );
                my $vars = variables_for_bl( $project, $stash->{bl} );
                _info( _loc('Current project *%%1* (%%2)', $project->name, $stash->{bl} ), $vars );
                merge_data $stash, $vars, { _ctx => 'apply project' };

                %s
            }
        }, $n->{project} // 'project', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.eval' => {
    text => _locl('EVAL'), data => { code=>'' },
    form => '/forms/stmt_eval.js',
    icon => '/static/images/icons/cog_perl.svg',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                $stash->{'%s'} = eval { %s };
                if($@) {
                    _fail "ERROR in EVAL: $@";
                }
            }
        }, $n->{data_key} // '', $n->{code} // '', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.do' => {
    text => _locl('DO'), data => { code=>'' },
    icon => '/static/images/icons/cog_perl.svg',
    form => '/forms/stmt_eval.js',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                my $dk = '%s';
                my $ret = do { %s };
                $stash->{$dk} = $ret if length $dk;
            }
        }, $n->{data_key} // '', $n->{code} // ''  );
    },
};

register 'statement.perl.group' => {
    text => _locl('GROUP'),data => { },
    icon => '/static/images/icons/cog_gears.svg',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            {
                my $dk = '%s';
                my $ret = do {
                    %s
                };
                $stash->{$dk} = $ret if length $dk;
            }
        }, $n->{data_key} // '', $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.perl.for' => {
    text => _locl('FOR eval'), data => { varname=>'x', code=>'()' },
    type => 'loop',
    icon => '/static/images/icons/cog_perl.svg',
    form => '/forms/stmt_for.js',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            for( %s ) {
                local $stash->{'%s'} = $_;
                %s;
            }
        }, $n->{code} // '()', $n->{varname} // 'x',  $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.code.server' => {
    text           => _locl('Server CODE'),
    data           => {code => ''},
    type           => 'loop',
    icon           => '/static/images/icons/cog_perl.svg',
    holds_children => 0,
    form           => '/forms/server_code.js',
    dsl            => sub {
        my ($self, $n, %p) = @_;

        my $code = $n->{code} // '';
        my $lang = $n->{lang} // '';

        my $dsl;
        if ($lang eq 'js') {
            $dsl = sprintf(q{eval_code('js', q{%s}, $stash);}, $code);
        }
        else {
            $dsl = sprintf(q{%s;}, $code);
        }

        return $dsl . "\n\n";
    },
};

register 'statement.perl.code' => {
    text => _locl('CODE (Perl)'), data => { code=>'' },
    type => 'loop',
    icon => '/static/images/icons/cog_perl.svg',
    holds_children => 0,
    form => '/forms/stmt_eval.js',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            %s;
        }, $n->{code} // '' );
    },
};

register 'statement.project.loop' => {
    text => _locl('FOR projects with changes DO'), data => { },
    type => 'loop',
    dsl => sub {
        my ($self, $n, %p ) = @_;
        sprintf(q{
            for my $project ( project_changes( $stash ) ) {
                $stash->{project} = $project->name;
                $stash->{project_mid} = $project->mid;
                $stash->{project_lc} = lc $project->name;
                $stash->{project_uc} = uc $project->name;
                $stash->{current_project} = $project;

                my @project_bls = map { $_->{bl} } _array $project->bls;
                if ( !@project_bls || $stash->{bl} ~~ @project_bls ) {
                    my $vars = variables_for_bl( $project, $stash->{bl} );
                    $stash->{job}->logger->info( _loc('Current project *%%1* (%%2)', $project->name, $stash->{bl} ), $vars );
                    merge_data $stash, $vars, { _ctx => 'project_loop' };

                    %s
                } else {
                    $stash->{job}->logger->info( _loc('Project *%%1* skipped for bl %%2', $project->name, $stash->{bl} ) );
                }
            }
        }, $self->dsl_build( $n->{children}, %p ) );
    },
};

# needs the changeset.nature service to fill the stash with natures (create a dependency check?)
register 'statement.if.nature' => {
    text => _locl('IF EXISTS nature THEN'),
    form => '/forms/if_nature.js',
    type => 'if',
    data => { nature=>'', },
    dsl => sub {
        my ($self, $n , %p) = @_;
        my ($nature) = _array($n->{nature});  # in case we accidently get an array of natures
        sprintf(q{
            if( my $nature = $stash->{natures}{ $project->mid }{'%s'} ) {
                NAT: {
                    $stash->{current_nature} = $nature;
                    local $stash->{nature_items} = $stash->{project_items}{ $stash->{current_project}->mid }{natures}{ $nature->mid };
                    last NAT if !_array( $stash->{nature_items} );
                    my ($nat_paths, $nat_paths_del) = cut_nature_items( $stash, parse_vars(q{%s},$stash) );
                    local $stash->{ nature_item_paths } = $nat_paths;
                    local $stash->{ nature_item_paths_del } = $nat_paths_del;
                    local $stash->{ nature_items_comma } = join(',', @$nat_paths );
                    local $stash->{ nature_items_quote } = "'" . join("' '", @$nat_paths ) . "'";
                    $stash->{job}->logger->info( _loc('Nature Detected *%%1*', $nature->name ),
                        +{ map { $_=>$stash->{$_} } qw/nature_items nature_item_paths nature_items_comma nature_items_quote/ } );

                    %s
                };
            }
        }, $nature, $n->{cut_path} , $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.any_nature' => {
    text => _locl('IF ANY nature THEN'),
    form => '/forms/if_any_nature.js',
    type => 'if',
    data => { natures=>'', },
    dsl => sub {
        my ($self, $n , %p) = @_;
        sprintf(q{
            if( _any { exists $stash->{natures}{ $project->mid }{$_} } split /,/, '%s' ) {
                %s
            }
        }, join(',',_array($n->{natures})), $self->dsl_build( $n->{children}, %p ) );
    },
};

register 'statement.if.last_trap_action' => {
    text => _locl('IF last trap status THEN'),
    form => '/forms/if_last_trap_action.js',
    type => 'if',
    data => { job_trap_action => 'skip', },
    dsl  => sub {
        my ( $self, $n, %p ) = @_;
        sprintf(
            q{
            if( $stash->{_last_trap_action} && $stash->{_last_trap_action} eq '%s' ) {
                %s
            }
        }, $n->{job_trap_action} // 'skip',
            $self->dsl_build( $n->{children}, %p )
        );
    },
};

register 'statement.if.rollback' => {
    text => _locl('IF ROLLBACK'),
    type => 'if',
    data => { rollback => '1', },
    dsl  => sub {
        my ( $self, $n, %p ) = @_;
        sprintf(
            q{
            if( $stash->{rollback} eq '%s' ) {
                %s
            }
        }, $n->{rollback}, $self->dsl_build( $n->{children}, %p )
        );
    },
};

register 'statement.include' => {
    text            => _locl('INCLUDE rule'),
    icon            => '/static/images/icons/cog_perl.svg',
    form            => '/forms/rule_list.js',
    holds_children  => 0,
    show_in_palette => 0,
    data            => { id_rule => '', },
    dsl             => sub {
        my ( $self, $n, %p ) = @_;
        my $dsl = $self->include_rule( $n->{id_rule}, %p );
        sprintf(
            q{
                %s;
        }, $dsl
        );
    },
};

register 'statement.call' => {
    text => _locl('CALL rule'),
    icon => '/static/images/icons/cog.svg',
    form           => '/forms/rule_list.js',
    holds_children => 0,
    data           => { id_rule => '', },
    dsl            => sub {
        my ( $self, $n, %p ) = @_;

        my ($id_rule) = _array $n->{id_rule};

        sprintf(
            q{
            call(parse_vars({id_rule => '%s'}, $stash)->{id_rule}, $stash);
        }, $id_rule
        );
    },
};

sub include_rule {
    my ($self, $id_rule, %p) = @_;
    my @tree = $self->build_tree( $id_rule, undef );
    my $dsl = try {
        $self->dsl_build( \@tree, id_rule=>$id_rule, %p );
    } catch {
        _fail( _loc("Error building DSL for rule '%1': %2", $id_rule, shift() ) );
    };
    return $dsl;
}

sub is_rule_active {
    my ( $self, %p ) = @_;
    my $rule = mdb->rule->find_one( { id => $p{id_rule}, rule_active => mdb->true }, { id => 1 } );
    return $rule ? 1 : 0;
}

sub get_rules_info {
    my ($self,$p)=@_;
    my $where = {};
    my $sort = $p->{sort} || 'ts';
    $sort = 'name_insensitive' if $sort eq 'rule_name';
    my $dir = $p->{dir} && $p->{dir} eq 'ASC' ? 1 : -1;

    my $permissions = Baseliner::Model::Permissions->new;

    my $action = $permissions->user_action($p->{username}, 'action.admin.rules', bounds => '*');
    return () unless $action;

    $permissions->inject_bounds_filters( $p->{username}, 'action.admin.rules', $where, map => { id_rule => 'id' } );

    if( $p->{query} ) {
        mdb->query_build( where=>$where, query=>$p->{query}, fields=>[qw(rule_tree rule_name id rule_event rule_type rule_compile_mode username)] );
    }
    # my $rs = mdb->rule->find($where)->fields({ rule_tree=>0 })->sort( mdb->ixhash( $sort=>$dir ) );
    my $rs = mdb->rule->aggregate([
            { '$match'=>$where },
            { '$project'=>{
                    rule_name=>1, rule_type=>1, rule_compile_mode=>1,
                    rule_when=>1, rule_event=>1, rule_active=>1, event_name=>1, username=>1, folders=>1,
                    id=>1,ts=>1, name_insensitive=> { '$toLower'=> '$rule_name' }
                }
            },
            { '$sort'=>mdb->ixhash( $sort=>$dir ) }
    ],{ cursor=>1 });
    my @rules;
    while ( my $rule = $rs->next ) {
        if ( my $ev = $rule->{rule_event} ) {
            my $reg = Baseliner->registry->get($ev);
            $rule->{event_name} = $reg->name if $reg;
        }
        push @rules, $rule;
    }

    if($p->{destination} && $p->{destination} eq 'tree'){
        my $expanded = $p->{query} ? \1 : \0;
        my $ids = $p->{ids};
        my $where = {};
        $where->{id} = mdb->in($ids) if length $ids;
        my @rule_types = sort ( 'dashboard', 'form', 'event', 'report', 'pipeline', 'webservice', 'independent', 'workflow' );
        my $folder_structure = [];
        for my $rule_type (@rule_types){
            my $text = uc(substr $rule_type,0,1).substr($rule_type,1);
            my $temp_structure = {
                text       => $text,
                rule_type  => $rule_type,
                leaf       => \0,
                expandable => \1,
                expanded   => $expanded,
                allowDrop  => \0,
                allowDrag  => \0,
                draggable  => \0,
                children   => []
            };
            map { push $temp_structure->{children},
                { text=>$_->{rule_name},
                  leaf=>\1,
                  draggable=>\1,
                  rule_id=>$_->{id},
                  rule_ts=>$_->{ts},
                  rule_type=>$rule_type,
                  rule_active=>$_->{rule_active},
                  rule_when=>$_->{rule_when},
                  rule_event=>$_->{rule_event},
                  event_name=>$_->{event_name},
                  rule_name=>$_->{rule_name},
                  username=>$_->{username}
               } if $_->{rule_type} eq $rule_type
            } @rules;
            push $folder_structure, $temp_structure;
        }
     my $custom_folder_node = {text=>_loc('Custom Folders'),  iconCls => 'default_folders', leaf => \0, expandable => \1, expanded => $expanded, children=> [],
                is_custom_folders_node=>\1, allowDrop=>\0, allowDrag=>\0, draggable=>\0 };
        my $rs = mdb->rule_folder->find;
        while( my $rule_folder = $rs->next ) {
            my $temp_structure = {
                text           => $rule_folder->{name},
                rule_folder_id => $rule_folder->{id},
                iconCls => 'default_folders',
                is_folder      => \1,
                leaf           => \0,
                expandable     => \1,
                expanded       => $expanded,
                children       => [],
                allowDrop      => \1,
                allowDrag      => \0
            };
            map {
                push $temp_structure->{children},
                { text=>$_->{rule_name},
                  iconCls => 'default_folders',
                  leaf=>\1,
                  rule_id=>$_->{id},
                  rule_ts=>$_->{ts},
                  rule_type=>$_->{rule_type},
                  rule_active=>$_->{rule_active},
                  rule_when=>$_->{rule_when},
                  rule_event=>$_->{rule_event},
                  rule_name=>$_->{rule_name},
                  event_name=>$_->{event_name},
                  username=>$_->{username}

                } if $rule_folder->{id} ~~ $_->{folders};
            } @rules;
            push $custom_folder_node->{children}, $temp_structure;
        }
        push $folder_structure, $custom_folder_node;
        @rules = @{$folder_structure};
    }
    return @rules;
}

sub add_custom_folder {
    my ($self,$p)=@_;
    my $folder_name = $p->{folder_name};
    my $rule_folder_seq;
    die _loc('Folder already exists') if mdb->rule_folder->find({name=>$folder_name})->count();
    if(mdb->master_seq->find_one({_id=>'rule_folder'})){
        $rule_folder_seq = mdb->master_seq->find_one({_id=>'rule_folder'})->{seq};
    }else{
        $rule_folder_seq = 1;
        mdb->master_seq->insert({_id=>'rule_folder'});
    }
    my $new_id = $rule_folder_seq+1;
    my $folder_info = { name=>$folder_name, id=>$new_id.'', username=>$p->{username}, ts=>mdb->now().'', iconCls => 'default_folders' };
    mdb->rule_folder->insert($folder_info);
    my $ret = mdb->master_seq->update({ _id => 'rule_folder', seq =>$rule_folder_seq }, { '$set' => { seq => $new_id } });
    $folder_info;
}

sub rename_rule_folder {
    my ($self,$p)=@_;
    my $folder_name = $p->{folder_name};
    die _loc('Folder already exists') if mdb->rule_folder->find({name=>$folder_name})->count();
    my $rule_folder_id = $p->{rule_folder_id};
    my $ret = mdb->rule_folder->update({ id =>$rule_folder_id }, { '$set' => { name => $folder_name, username=>$p->{username}, ts=>mdb->now().'' } });
}

sub delete_rule_folder {
    my ($self,$p)=@_;
    my $rule_folder_id = $p->{rule_folder_id};
    mdb->rule_folder->remove({id=>$rule_folder_id});
    my $rs = mdb->rule->find({ folders=>{ '$elemMatch'=> {'$eq'=>$rule_folder_id } } })->fields({_id=>0, id=>1, folders=>1 });
    while (my $rule = $rs->next) {
        my @new_folders = grep { $_ ne $rule_folder_id } _array $rule->{folders};
        mdb->rule->update({id=>$rule->{id}}, {'$set'=>{folders=>@new_folders}} );
    }
}

sub added_rule_to_folder {
    my ($self,$p)=@_;
    my $rule_id = $p->{rule_id};
    my $rule_folder_id = $p->{rule_folder_id};
    my $folders = mdb->rule->find_one({id=>$rule_id})->{folders} // [];
    $folders = [$folders] if ref $folders ne 'ARRAY';
    push $folders, $rule_folder_id if $rule_folder_id !~ $folders;
    mdb->rule->update({id=>$rule_id}, {'$set'=>{folders=>$folders}} );
}

sub delete_rule_from_folder {
    my ($self,$p)=@_;
    my $rule_id = $p->{rule_id};
    my $rule_folder_id = $p->{rule_folder_id};
    my $folders = mdb->rule->find_one({ id=>$rule_id })->{folders};
    my @new_folders = grep { $_ ne $rule_folder_id } _array $folders;
    mdb->rule->update({id=>$rule_id}, {'$set'=>{folders=>@new_folders}});
}

sub write_rule {
    my ($self,%p)=@_;

    my $doc = mdb->rule->find_one({ id=>"$p{id_rule}" });
    _fail _loc('Rule not found, id=%1', $p{id_rule}) unless $doc;

    my $ts_modified = 0;
    my $old_timestamp = ''.($p{old_ts} //'');
    my $actual_timestamp = $p{ts} || $doc->{ts};
    my %other_options;
    defined $p{$_} and $other_options{$_}=$p{$_} for qw(detected_errors ignore_dsl_errors);
    my $previous_user = $doc->{username};

    event_new 'event.rule.update'
        => { username=>$p{username}, rule_id=>$p{id_rule}, rule_name=>$doc->{rule_name}, rule_type=>$doc->{rule_type} }
        => sub {
            if (!$actual_timestamp and !$previous_user){
                $actual_timestamp = $old_timestamp;
                $previous_user = $p{username};
                mdb->rule->update({ id =>''.$p{id_rule} }, { '$set'=>{ ts=>$actual_timestamp, username=>$previous_user, %other_options } } );
            }
            $ts_modified = (''.$old_timestamp ne ''.$actual_timestamp) ||  ($p{username} ne $previous_user);

            $old_timestamp = $p{ts} // mdb->ts;
            mdb->rule->update({ id=>''.$p{id_rule} }, { '$set'=> { ts => $old_timestamp, username => $p{username}, rule_tree=>$p{stmts_json}, %other_options } } );

            delete $doc->{_id};
            mdb->rule_version->insert({ %$doc, ts=>mdb->ts, username=>$p{username}, id_rule=>$p{id_rule}, rule_tree=>$p{stmts_json}, was=>($p{was}//'') });
        };

    return { old_ts => $old_timestamp, actual_ts => $actual_timestamp, previous_user => $previous_user };
}

sub delete_rule {
    my ($self,%p)=@_;

    my $doc = mdb->rule->find_one({ id=>"$p{id_rule}" });
    _fail _loc('Rule not found, id=%1', $p{id_rule}) unless $doc;

    my $ts_modified = 0;
    my $old_timestamp = ''.$doc->{ts};
    my $actual_timestamp = ''.Class::Date->now();

    my $name = $doc->{rule_name};

    event_new 'event.rule.delete'
        => { username=>$p{username}, rule_id=>$p{id_rule}, rule_name=>$doc->{rule_name}, rule_type=>$doc->{rule_type} }
        => sub {

            if($doc->{rule_type} eq 'fieldlets'){
                #remove relationship between rule and category
                mdb->category->update({default_form=>"$p{id_rule}"},{'$set'=>{default_form=>''}});
            }
            mdb->rule->remove({ id=>"$p{id_rule}" },{ multiple=>1 });
            mdb->grid->remove({ id_rule=>"$p{id_rule}" });

            delete $doc->{_id};

            mdb->rule_version->insert({ %$doc, deleted=>'1', ts=>mdb->ts, username=>$p{username}, id_rule=>$p{id_rule}, was=>'' });
        };
    return $name;
}

sub restore_rule {
    my ($self,%p)=@_;

    my $rule = mdb->rule_version->find_one({ id => "$p{id_rule}", deleted => '1'});
    _fail _loc('Rule version not found for restore, id=%1', $p{id_rule}) unless $rule;

    delete $rule->{_id};
    delete $rule->{deleted};
    delete $rule->{was};

    my $ts = mdb->ts;

    $rule->{ts} = $ts;

    mdb->rule->insert($rule);
    mdb->rule_version->update({ id => $p{id_rule}, deleted => '1' }, { '$unset' => { 'deleted' => ''}, '$set' => { 'ts' => $ts }});
}

sub save_rule {
    my ($self,%params)=@_;

    my $id_rule;

    if( $params{wsdl} ) {
        # soap envelope received, precompile for errors
        $self->compile_wsdl($params{wsdl});
    }
    my $data = {
        rule_active => '1',
        rule_name   => $params{rule_name},
        rule_when   => (
              $params{rule_type} eq 'pipeline'
            ? $params{pipeline_default}
            : $params{rule_when}
        ),
        rule_event        => $params{rule_event},
        rule_type         => $params{rule_type},
        rule_compile_mode => $params{rule_compile_mode},
        rule_desc         => substr( $params{rule_desc}, 0, 2000 ),
        subtype           => $params{subtype},
        authtype          => $params{authtype},
        wsdl              => $params{wsdl},
        ts                => mdb->ts,
        username          => $params{username}
    };

    if ( exists $params{rule_tree} && ref $params{rule_tree} ) {
        $data->{rule_tree} = JSON::encode_json( $params{rule_tree} );
    }

    if ( length $params{rule_id} ) {
        $id_rule = $params{rule_id};
        event_new 'event.rule.update'
            => { username=>$params{username}, rule_id=>$params{rule_id}, rule_name=>$params{rule_name}, rule_type=>$params{rule_type}}
            => sub {
                my $doc = mdb->rule->find_one({ id=>"$params{rule_id}" });
                _fail _loc('Rule %1 not found', $params{rule_id}) unless $doc;
                mdb->rule->update({ id=>"$params{rule_id}" },{ %$doc, %$data });
            }
    } else {
        $id_rule = mdb->seq('rule');
        event_new 'event.rule.create'
            => { username=>$params{username}, rule_id=>$params{rule_id}, rule_name=>$params{rule_name}, rule_type=>$params{rule_type}}
            => sub {
                $data->{id} = $id_rule;
                $data->{rule_seq} = 0+mdb->seq('rule_seq');
                mdb->rule->insert($data);
            }
    }
    return { id_rule=>$id_rule, rule_name => $params{rule_name} };
}

sub list_versions {
    my $self = shift;
    my ($id_rule, %params) = @_;

    _fail _loc('Unknown rule `%1`', $id_rule) unless mdb->rule->find_one({id => $id_rule}, {_id => 1});

    my %cond;
    if ( $params{only_tags} ) {
        %cond = ( version_tag => { '$exists' => 1, '$ne' => undef, '$ne' => '' } );
    }

    my @versions = mdb->rule_version->find( { id_rule => $id_rule, %cond } )->sort( { ts => -1 } )->all;

    return @versions;
}

sub compile_wsdl {
    my ( $self, $wsdl ) = @_;
    return try {
        require XML::Compile::SOAP11;
        require XML::Compile::SOAP::Daemon::CGI;
        require XML::Compile::WSDL11;
        require XML::Compile::SOAP::Util;
        return XML::Compile::WSDL11->new(
            Util->parse_vars( $wsdl, { WSURL => 'http://fakeurl:8080/rule/soap/fake_for_compile' } ) );
    }
    catch {
        my $err = shift;
        _fail( _loc( 'Error compiling WSDL:' ) . '<br /><pre>' . Util->_html_escape($err) . '</pre>' );
    };
}

method find_version_by_tag(:$id_rule, :$version_tag) {
    _fail _loc('Unknown rule `%1`', $id_rule) unless mdb->rule->find_one({id => $id_rule}, {_id => 1});

    return mdb->rule_version->find_one( { id_rule => $id_rule, version_tag => $version_tag } );
}

method tag_version(:$version_id, :$version_tag) {
    my $version = mdb->rule_version->find_one( { _id => mdb->oid($version_id) } );
    _fail _loc( 'Version not found: %1', $version_id ) unless $version;

    my $exists =
      mdb->rule_version->find_one(
        { id_rule => $version->{id_rule}, _id => { '$ne' => mdb->oid($version_id) }, version_tag => $version_tag } );
    _fail _loc('Version tag already exists') if $exists;

    mdb->rule_version->update( { _id => mdb->oid($version_id) }, { '$set' => { version_tag => $version_tag } } );

    return 1;
}

method untag_version(:$version_id) {
    my $version = mdb->rule_version->find_one( { _id => mdb->oid($version_id) } );
    _fail _loc( 'Version not found: %1', $version_id ) unless $version;

    mdb->rule_version->update( { _id => mdb->oid($version_id) }, { '$unset' => { version_tag => '' } } );

    return 1;
}

method resolve_rule(:$id_rule, :$version_id = undef, :$version_tag = undef) {
    my $rule = mdb->rule->find_one( { '$or' => [ { id => "$id_rule" }, { rule_name => "$id_rule" } ] } );
    _fail _loc( 'Rule with id or name `%1` not found', $id_rule ) unless $rule;

    my $id_rule = $rule->{id};

    if ($version_id) {
        $rule = mdb->rule_version->find_one( { id_rule => $id_rule, _id => mdb->oid($version_id) } );
        _fail _loc( 'Version `%1` of rule `%2` not found', $version_id, $id_rule ) unless $rule;
    }
    elsif ($version_tag) {
        $rule = mdb->rule_version->find_one( { id_rule => $id_rule, version_tag => $version_tag } );
        _fail _loc( 'Version tag `%1` of rule `%2` not found', $version_tag, $id_rule ) unless $rule;
    }

    return $rule;
}

no Moose;
__PACKAGE__->meta->make_immutable;

1;
