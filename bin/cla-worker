#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Capture/Tiny.pm"} = <<'CAPTURE_TINY';
  use 5.006;
  use strict;
  use warnings;
  package Capture::Tiny;
  # ABSTRACT: Capture STDOUT and STDERR from Perl, XS or external programs
  our $VERSION = '0.22'; # VERSION
  use Carp ();
  use Exporter ();
  use IO::Handle ();
  use File::Spec ();
  use File::Temp qw/tempfile tmpnam/;
  use Scalar::Util qw/reftype blessed/;
  # Get PerlIO or fake it
  BEGIN {
    local $@;
    eval { require PerlIO; PerlIO->can('get_layers') }
      or *PerlIO::get_layers = sub { return () };
  }
  
  #--------------------------------------------------------------------------#
  # create API subroutines and export them
  # [do STDOUT flag, do STDERR flag, do merge flag, do tee flag]
  #--------------------------------------------------------------------------#
  
  my %api = (
    capture         => [1,1,0,0],
    capture_stdout  => [1,0,0,0],
    capture_stderr  => [0,1,0,0],
    capture_merged  => [1,1,1,0],
    tee             => [1,1,0,1],
    tee_stdout      => [1,0,0,1],
    tee_stderr      => [0,1,0,1],
    tee_merged      => [1,1,1,1],
  );
  
  for my $sub ( keys %api ) {
    my $args = join q{, }, @{$api{$sub}};
    eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"; ## no critic
  }
  
  our @ISA = qw/Exporter/;
  our @EXPORT_OK = keys %api;
  our %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  
  #--------------------------------------------------------------------------#
  # constants and fixtures
  #--------------------------------------------------------------------------#
  
  my $IS_WIN32 = $^O eq 'MSWin32';
  
  ##our $DEBUG = $ENV{PERL_CAPTURE_TINY_DEBUG};
  ##
  ##my $DEBUGFH;
  ##open $DEBUGFH, "> DEBUG" if $DEBUG;
  ##
  ##*_debug = $DEBUG ? sub(@) { print {$DEBUGFH} @_ } : sub(){0};
  
  our $TIMEOUT = 30;
  
  #--------------------------------------------------------------------------#
  # command to tee output -- the argument is a filename that must
  # be opened to signal that the process is ready to receive input.
  # This is annoying, but seems to be the best that can be done
  # as a simple, portable IPC technique
  #--------------------------------------------------------------------------#
  my @cmd = ($^X, '-C0', '-e', '$SIG{HUP}=sub{exit}; '
    . 'if( my $fn=shift ){ open my $fh, qq{>$fn}; print {$fh} $$; close $fh;} '
    . 'my $buf; while (sysread(STDIN, $buf, 2048)) { '
    . 'syswrite(STDOUT, $buf); syswrite(STDERR, $buf)}'
  );
  
  #--------------------------------------------------------------------------#
  # filehandle manipulation
  #--------------------------------------------------------------------------#
  
  sub _relayer {
    my ($fh, $layers) = @_;
    # _debug("# requested layers (@{$layers}) for @{[fileno $fh]}\n");
    my %seen = ( unix => 1, perlio => 1 ); # filter these out
    my @unique = grep { !$seen{$_}++ } @$layers;
    # _debug("# applying unique layers (@unique) to @{[fileno $fh]}\n");
    binmode($fh, join(":", ":raw", @unique));
  }
  
  sub _name {
    my $glob = shift;
    no strict 'refs'; ## no critic
    return *{$glob}{NAME};
  }
  
  sub _open {
    open $_[0], $_[1] or Carp::confess "Error from open(" . join(q{, }, @_) . "): $!";
    # _debug( "# open " . join( ", " , map { defined $_ ? _name($_) : 'undef' } @_ ) . " as " . fileno( $_[0] ) . "\n" );
  }
  
  sub _close {
    # _debug( "# closing " . ( defined $_[0] ? _name($_[0]) : 'undef' )  . " on " . fileno( $_[0] ) . "\n" );
    close $_[0] or Carp::confess "Error from close(" . join(q{, }, @_) . "): $!";
  }
  
  my %dup; # cache this so STDIN stays fd0
  my %proxy_count;
  sub _proxy_std {
    my %proxies;
    if ( ! defined fileno STDIN ) {
      $proxy_count{stdin}++;
      if (defined $dup{stdin}) {
        _open \*STDIN, "<&=" . fileno($dup{stdin});
        # _debug( "# restored proxy STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
      }
      else {
        _open \*STDIN, "<" . File::Spec->devnull;
        # _debug( "# proxied STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
        _open $dup{stdin} = IO::Handle->new, "<&=STDIN";
      }
      $proxies{stdin} = \*STDIN;
      binmode(STDIN, ':utf8') if $] >= 5.008;
    }
    if ( ! defined fileno STDOUT ) {
      $proxy_count{stdout}++;
      if (defined $dup{stdout}) {
        _open \*STDOUT, ">&=" . fileno($dup{stdout});
        # _debug( "# restored proxy STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
      }
      else {
        _open \*STDOUT, ">" . File::Spec->devnull;
         # _debug( "# proxied STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
        _open $dup{stdout} = IO::Handle->new, ">&=STDOUT";
      }
      $proxies{stdout} = \*STDOUT;
      binmode(STDOUT, ':utf8') if $] >= 5.008;
    }
    if ( ! defined fileno STDERR ) {
      $proxy_count{stderr}++;
      if (defined $dup{stderr}) {
        _open \*STDERR, ">&=" . fileno($dup{stderr});
         # _debug( "# restored proxy STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
      }
      else {
        _open \*STDERR, ">" . File::Spec->devnull;
         # _debug( "# proxied STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
        _open $dup{stderr} = IO::Handle->new, ">&=STDERR";
      }
      $proxies{stderr} = \*STDERR;
      binmode(STDERR, ':utf8') if $] >= 5.008;
    }
    return %proxies;
  }
  
  sub _unproxy {
    my (%proxies) = @_;
    # _debug( "# unproxying: " . join(" ", keys %proxies) . "\n" );
    for my $p ( keys %proxies ) {
      $proxy_count{$p}--;
      # _debug( "# unproxied " . uc($p) . " ($proxy_count{$p} left)\n" );
      if ( ! $proxy_count{$p} ) {
        _close $proxies{$p};
        _close $dup{$p} unless $] < 5.008; # 5.6 will have already closed this as dup
        delete $dup{$p};
      }
    }
  }
  
  sub _copy_std {
    my %handles;
    for my $h ( qw/stdout stderr stdin/ ) {
      next if $h eq 'stdin' && ! $IS_WIN32; # WIN32 hangs on tee without STDIN copied
      my $redir = $h eq 'stdin' ? "<&" : ">&";
      _open $handles{$h} = IO::Handle->new(), $redir . uc($h); # ">&STDOUT" or "<&STDIN"
    }
    return \%handles;
  }
  
  # In some cases we open all (prior to forking) and in others we only open
  # the output handles (setting up redirection)
  sub _open_std {
    my ($handles) = @_;
    _open \*STDIN, "<&" . fileno $handles->{stdin} if defined $handles->{stdin};
    _open \*STDOUT, ">&" . fileno $handles->{stdout} if defined $handles->{stdout};
    _open \*STDERR, ">&" . fileno $handles->{stderr} if defined $handles->{stderr};
  }
  
  #--------------------------------------------------------------------------#
  # private subs
  #--------------------------------------------------------------------------#
  
  sub _start_tee {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    # setup pipes
    $stash->{$_}{$which} = IO::Handle->new for qw/tee reader/;
    pipe $stash->{reader}{$which}, $stash->{tee}{$which};
    # _debug( "# pipe for $which\: " .  _name($stash->{tee}{$which}) . " " . fileno( $stash->{tee}{$which} ) . " => " . _name($stash->{reader}{$which}) . " " . fileno( $stash->{reader}{$which}) . "\n" );
    select((select($stash->{tee}{$which}), $|=1)[0]); # autoflush
    # setup desired redirection for parent and child
    $stash->{new}{$which} = $stash->{tee}{$which};
    $stash->{child}{$which} = {
      stdin   => $stash->{reader}{$which},
      stdout  => $stash->{old}{$which},
      stderr  => $stash->{capture}{$which},
    };
    # flag file is used to signal the child is ready
    $stash->{flag_files}{$which} = scalar tmpnam();
    # execute @cmd as a separate process
    if ( $IS_WIN32 ) {
      local $@;
      eval "use Win32API::File qw/CloseHandle GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";
      # _debug( "# Win32API::File loaded\n") unless $@;
      my $os_fhandle = GetOsFHandle( $stash->{tee}{$which} );
      # _debug( "# Couldn't get OS handle: " . fileLastError() . "\n") if ! defined $os_fhandle || $os_fhandle == INVALID_HANDLE_VALUE();
      my $result = SetHandleInformation( $os_fhandle, HANDLE_FLAG_INHERIT(), 0);
      # _debug( $result ? "# set no-inherit flag on $which tee\n" : ("# can't disable tee handle flag inherit: " . fileLastError() . "\n"));
      _open_std( $stash->{child}{$which} );
      $stash->{pid}{$which} = system(1, @cmd, $stash->{flag_files}{$which});
      # not restoring std here as it all gets redirected again shortly anyway
    }
    else { # use fork
      _fork_exec( $which, $stash );
    }
  }
  
  sub _fork_exec {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    my $pid = fork;
    if ( not defined $pid ) {
      Carp::confess "Couldn't fork(): $!";
    }
    elsif ($pid == 0) { # child
      # _debug( "# in child process ...\n" );
      untie *STDIN; untie *STDOUT; untie *STDERR;
      _close $stash->{tee}{$which};
      # _debug( "# redirecting handles in child ...\n" );
      _open_std( $stash->{child}{$which} );
      # _debug( "# calling exec on command ...\n" );
      exec @cmd, $stash->{flag_files}{$which};
    }
    $stash->{pid}{$which} = $pid
  }
  
  my $have_usleep = eval "use Time::HiRes 'usleep'; 1";
  sub _files_exist {
    return 1 if @_ == grep { -f } @_;
    Time::HiRes::usleep(1000) if $have_usleep;
    return 0;
  }
  
  sub _wait_for_tees {
    my ($stash) = @_;
    my $start = time;
    my @files = values %{$stash->{flag_files}};
    my $timeout = defined $ENV{PERL_CAPTURE_TINY_TIMEOUT}
                ? $ENV{PERL_CAPTURE_TINY_TIMEOUT} : $TIMEOUT;
    1 until _files_exist(@files) || ($timeout && (time - $start > $timeout));
    Carp::confess "Timed out waiting for subprocesses to start" if ! _files_exist(@files);
    unlink $_ for @files;
  }
  
  sub _kill_tees {
    my ($stash) = @_;
    if ( $IS_WIN32 ) {
      # _debug( "# closing handles with CloseHandle\n");
      CloseHandle( GetOsFHandle($_) ) for values %{ $stash->{tee} };
      # _debug( "# waiting for subprocesses to finish\n");
      my $start = time;
      1 until wait == -1 || (time - $start > 30);
    }
    else {
      _close $_ for values %{ $stash->{tee} };
      waitpid $_, 0 for values %{ $stash->{pid} };
    }
  }
  
  sub _slurp {
    my ($name, $stash) = @_;
    my ($fh, $pos) = map { $stash->{$_}{$name} } qw/capture pos/;
    # _debug( "# slurping captured $name from " . fileno($fh) . " at pos $pos with layers: @{[PerlIO::get_layers($fh)]}\n");
    seek( $fh, $pos, 0 ) or die "Couldn't seek on capture handle for $name\n";
    my $text = do { local $/; scalar readline $fh };
    return defined($text) ? $text : "";
  }
  
  #--------------------------------------------------------------------------#
  # _capture_tee() -- generic main sub for capturing or teeing
  #--------------------------------------------------------------------------#
  
  sub _capture_tee {
    # _debug( "# starting _capture_tee with (@_)...\n" );
    my ($do_stdout, $do_stderr, $do_merge, $do_tee, $code, @opts) = @_;
    my %do = ($do_stdout ? (stdout => 1) : (),  $do_stderr ? (stderr => 1) : ());
    Carp::confess("Custom capture options must be given as key/value pairs\n")
      unless @opts % 2 == 0;
    my $stash = { capture => { @opts } };
    for ( keys %{$stash->{capture}} ) {
      my $fh = $stash->{capture}{$_};
      Carp::confess "Custom handle for $_ must be seekable\n"
        unless ref($fh) eq 'GLOB' || (blessed($fh) && $fh->isa("IO::Seekable"));
    }
    # save existing filehandles and setup captures
    local *CT_ORIG_STDIN  = *STDIN ;
    local *CT_ORIG_STDOUT = *STDOUT;
    local *CT_ORIG_STDERR = *STDERR;
    # find initial layers
    my %layers = (
      stdin   => [PerlIO::get_layers(\*STDIN) ],
      stdout  => [PerlIO::get_layers(\*STDOUT, output => 1)],
      stderr  => [PerlIO::get_layers(\*STDERR, output => 1)],
    );
    # _debug( "# existing layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # get layers from underlying glob of tied filehandles if we can
    # (this only works for things that work like Tie::StdHandle)
    $layers{stdout} = [PerlIO::get_layers(tied *STDOUT)]
      if tied(*STDOUT) && (reftype tied *STDOUT eq 'GLOB');
    $layers{stderr} = [PerlIO::get_layers(tied *STDERR)]
      if tied(*STDERR) && (reftype tied *STDERR eq 'GLOB');
    # _debug( "# tied object corrected layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # bypass scalar filehandles and tied handles
    # localize scalar STDIN to get a proxy to pick up FD0, then restore later to CT_ORIG_STDIN
    my %localize;
    $localize{stdin}++,  local(*STDIN)
      if grep { $_ eq 'scalar' } @{$layers{stdin}};
    $localize{stdout}++, local(*STDOUT)
      if $do_stdout && grep { $_ eq 'scalar' } @{$layers{stdout}};
    $localize{stderr}++, local(*STDERR)
      if ($do_stderr || $do_merge) && grep { $_ eq 'scalar' } @{$layers{stderr}};
    $localize{stdin}++, local(*STDIN), _open( \*STDIN, "<&=0")
      if tied *STDIN && $] >= 5.008;
    $localize{stdout}++, local(*STDOUT), _open( \*STDOUT, ">&=1")
      if $do_stdout && tied *STDOUT && $] >= 5.008;
    $localize{stderr}++, local(*STDERR), _open( \*STDERR, ">&=2")
      if ($do_stderr || $do_merge) && tied *STDERR && $] >= 5.008;
    # _debug( "# localized $_\n" ) for keys %localize;
    # proxy any closed/localized handles so we don't use fds 0, 1 or 2
    my %proxy_std = _proxy_std();
    # _debug( "# proxy std: @{ [%proxy_std] }\n" );
    # update layers after any proxying
    $layers{stdout} = [PerlIO::get_layers(\*STDOUT, output => 1)] if $proxy_std{stdout};
    $layers{stderr} = [PerlIO::get_layers(\*STDERR, output => 1)] if $proxy_std{stderr};
    # _debug( "# post-proxy layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # store old handles and setup handles for capture
    $stash->{old} = _copy_std();
    $stash->{new} = { %{$stash->{old}} }; # default to originals
    for ( keys %do ) {
      $stash->{new}{$_} = ($stash->{capture}{$_} ||= File::Temp->new);
      seek( $stash->{capture}{$_}, 0, 2 ) or die "Could not seek on capture handle for $_\n";
      $stash->{pos}{$_} = tell $stash->{capture}{$_};
      # _debug("# will capture $_ on " . fileno($stash->{capture}{$_})."\n" );
      _start_tee( $_ => $stash ) if $do_tee; # tees may change $stash->{new}
    }
    _wait_for_tees( $stash ) if $do_tee;
    # finalize redirection
    $stash->{new}{stderr} = $stash->{new}{stdout} if $do_merge;
    # _debug( "# redirecting in parent ...\n" );
    _open_std( $stash->{new} );
    # execute user provided code
    my ($exit_code, $inner_error, $outer_error, @result);
    {
      local *STDIN = *CT_ORIG_STDIN if $localize{stdin}; # get original, not proxy STDIN
      # _debug( "# finalizing layers ...\n" );
      _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
      _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
      # _debug( "# running code $code ...\n" );
      local $@;
      eval { @result = $code->(); $inner_error = $@ };
      $exit_code = $?; # save this for later
      $outer_error = $@; # save this for later
    }
    # restore prior filehandles and shut down tees
    # _debug( "# restoring filehandles ...\n" );
    _open_std( $stash->{old} );
    _close( $_ ) for values %{$stash->{old}}; # don't leak fds
    # shouldn't need relayering originals, but see rt.perl.org #114404
    _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
    _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
    _unproxy( %proxy_std );
    # _debug( "# killing tee subprocesses ...\n" ) if $do_tee;
    _kill_tees( $stash ) if $do_tee;
    # return captured output, but shortcut in void context
    # unless we have to echo output to tied/scalar handles;
    my %got;
    if ( defined wantarray or ($do_tee && keys %localize) ) {
      for ( keys %do ) {
        _relayer($stash->{capture}{$_}, $layers{$_});
        $got{$_} = _slurp($_, $stash);
        # _debug("# slurped " . length($got{$_}) . " bytes from $_\n");
      }
      print CT_ORIG_STDOUT $got{stdout}
        if $do_stdout && $do_tee && $localize{stdout};
      print CT_ORIG_STDERR $got{stderr}
        if $do_stderr && $do_tee && $localize{stderr};
    }
    $? = $exit_code;
    $@ = $inner_error if $inner_error;
    die $outer_error if $outer_error;
    # _debug( "# ending _capture_tee with (@_)...\n" );
    return unless defined wantarray;
    my @return;
    push @return, $got{stdout} if $do_stdout;
    push @return, $got{stderr} if $do_stderr && ! $do_merge;
    push @return, @result;
    return wantarray ? @return : $return[0];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Capture::Tiny - Capture STDOUT and STDERR from Perl, XS or external programs
  
  =head1 VERSION
  
  version 0.22
  
  =head1 SYNOPSIS
  
     use Capture::Tiny ':all';
   
     # capture from external command
   
     ($stdout, $stderr, $exit) = capture {
       system( $cmd, @args );
     };
   
     # capture from arbitrary code (Perl or external)
   
     ($stdout, $stderr, @result) = capture {
       # your code here
     };
   
     # capture partial or merged output
   
     $stdout = capture_stdout { ... };
     $stderr = capture_stderr { ... };
     $merged = capture_merged { ... };
   
     # tee output
   
     ($stdout, $stderr) = tee {
       # your code here
     };
   
     $stdout = tee_stdout { ... };
     $stderr = tee_stderr { ... };
     $merged = tee_merged { ... };
  
  =head1 DESCRIPTION
  
  Capture::Tiny provides a simple, portable way to capture almost anything sent
  to STDOUT or STDERR, regardless of whether it comes from Perl, from XS code or
  from an external program.  Optionally, output can be teed so that it is
  captured while being passed through to the original filehandles.  Yes, it even
  works on Windows (usually).  Stop guessing which of a dozen capturing modules
  to use in any particular situation and just use this one.
  
  =head1 USAGE
  
  The following functions are available.  None are exported by default.
  
  =head2 capture
  
     ($stdout, $stderr, @result) = capture \&code;
     $stdout = capture \&code;
  
  The C<<< capture >>> function takes a code reference and returns what is sent to
  STDOUT and STDERR as well as any return values from the code reference.  In
  scalar context, it returns only STDOUT.  If no output was received for a
  filehandle, it returns an empty string for that filehandle.  Regardless of calling
  context, all output is captured -- nothing is passed to the existing filehandles.
  
  It is prototyped to take a subroutine reference as an argument. Thus, it
  can be called in block form:
  
     ($stdout, $stderr) = capture {
       # your code here ...
     };
  
  Note that the coderef is evaluated in list context.  If you wish to force
  scalar context on the return value, you must use the C<<< scalar >>> keyword.
  
     ($stdout, $stderr, $count) = capture {
       my @list = qw/one two three/;
       return scalar @list; # $count will be 3
     };
  
  Captures are normally done to an anonymous temporary filehandle.  To
  capture via a named file (e.g. to externally monitor a long-running capture),
  provide custom filehandles as a trailing list of option pairs:
  
     my $out_fh = IO::File->new("out.txt", "w+");
     my $err_fh = IO::File->new("out.txt", "w+");
     capture { ... } stdout => $out_fh, stderr => $err_fh;
  
  The filehandles must be readE<sol>write and seekable.  Modifying the files or
  filehandles during a capture operation will give unpredictable results.
  Existing IO layers on them may be changed by the capture.
  
  When called in void context, C<<< capture >>> saves memory and time by
  not reading back from the capture handles.
  
  =head2 capture_stdout
  
     ($stdout, @result) = capture_stdout \&code;
     $stdout = capture_stdout \&code;
  
  The C<<< capture_stdout >>> function works just like C<<< capture >>> except only
  STDOUT is captured.  STDERR is not captured.
  
  =head2 capture_stderr
  
     ($stderr, @result) = capture_stderr \&code;
     $stderr = capture_stderr \&code;
  
  The C<<< capture_stderr >>> function works just like C<<< capture >>> except only
  STDERR is captured.  STDOUT is not captured.
  
  =head2 capture_merged
  
     ($merged, @result) = capture_merged \&code;
     $merged = capture_merged \&code;
  
  The C<<< capture_merged >>> function works just like C<<< capture >>> except STDOUT and
  STDERR are merged. (Technically, STDERR is redirected to the same capturing
  handle as STDOUT before executing the function.)
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head2 tee
  
     ($stdout, $stderr, @result) = tee \&code;
     $stdout = tee \&code;
  
  The C<<< tee >>> function works just like C<<< capture >>>, except that output is captured
  as well as passed on to the original STDOUT and STDERR.
  
  When called in void context, C<<< tee >>> saves memory and time by
  not reading back from the capture handles, except when the
  original STDOUT OR STDERR were tied or opened to a scalar
  handle.
  
  =head2 tee_stdout
  
     ($stdout, @result) = tee_stdout \&code;
     $stdout = tee_stdout \&code;
  
  The C<<< tee_stdout >>> function works just like C<<< tee >>> except only
  STDOUT is teed.  STDERR is not teed (output goes to STDERR as usual).
  
  =head2 tee_stderr
  
     ($stderr, @result) = tee_stderr \&code;
     $stderr = tee_stderr \&code;
  
  The C<<< tee_stderr >>> function works just like C<<< tee >>> except only
  STDERR is teed.  STDOUT is not teed (output goes to STDOUT as usual).
  
  =head2 tee_merged
  
     ($merged, @result) = tee_merged \&code;
     $merged = tee_merged \&code;
  
  The C<<< tee_merged >>> function works just like C<<< capture_merged >>> except that output
  is captured as well as passed on to STDOUT.
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head1 LIMITATIONS
  
  =head2 Portability
  
  Portability is a goal, not a guarantee.  C<<< tee >>> requires fork, except on
  Windows where C<<< system(1, @cmd) >>> is used instead.  Not tested on any
  particularly esoteric platforms yet.  See the
  L<CPAN Testers Matrix|http://matrix.cpantesters.org/?dist=Capture-Tiny>
  for test result by platform.
  
  =head2 PerlIO layers
  
  Capture::Tiny does it's best to preserve PerlIO layers such as ':utf8' or
  ':crlf' when capturing (only for Perl 5.8.1+) .  Layers should be applied to
  STDOUT or STDERR I<before> the call to C<<< capture >>> or C<<< tee >>>.  This may not work
  for tied filehandles (see below).
  
  =head2 Modifying filehandles before capturing
  
  Generally speaking, you should do little or no manipulation of the standard IO
  filehandles prior to using Capture::Tiny.  In particular, closing, reopening,
  localizing or tying standard filehandles prior to capture may cause a variety of
  unexpected, undesirable andE<sol>or unreliable behaviors, as described below.
  Capture::Tiny does its best to compensate for these situations, but the
  results may not be what you desire.
  
  B<Closed filehandles>
  
  Capture::Tiny will work even if STDIN, STDOUT or STDERR have been previously
  closed.  However, since they will be reopened to capture or tee output, any
  code within the captured block that depends on finding them closed will, of
  course, not find them to be closed.  If they started closed, Capture::Tiny will
  close them again when the capture block finishes.
  
  Note that this reopening will happen even for STDIN or a filehandle not being
  captured to ensure that the filehandle used for capture is not opened to file
  descriptor 0, as this causes problems on various platforms.
  
  Prior to Perl 5.12, closed STDIN combined with PERL_UNICODE=D leaks filehandles
  and also breaks tee() for undiagnosed reasons.  So don't do that.
  
  B<Localized filehandles>
  
  If code localizes any of Perl's standard filehandles before capturing, the capture
  will affect the localized filehandles and not the original ones.  External system
  calls are not affected by localizing a filehandle in Perl and will continue
  to send output to the original filehandles (which will thus not be captured).
  
  B<Scalar filehandles>
  
  If STDOUT or STDERR are reopened to scalar filehandles prior to the call to
  C<<< capture >>> or C<<< tee >>>, then Capture::Tiny will override the output filehandle for
  the duration of the C<<< capture >>> or C<<< tee >>> call and then, for C<<< tee >>>, send captured
  output to the output filehandle after the capture is complete.  (Requires Perl
  5.8)
  
  Capture::Tiny attempts to preserve the semantics of STDIN opened to a scalar
  reference, but note that external processes will not be able to read from such
  a handle.  Capture::Tiny tries to ensure that external processes will read from
  the null device instead, but this is not guaranteed.
  
  B<Tied output filehandles>
  
  If STDOUT or STDERR are tied prior to the call to C<<< capture >>> or C<<< tee >>>, then
  Capture::Tiny will attempt to override the tie for the duration of the
  C<<< capture >>> or C<<< tee >>> call and then send captured output to the tied filehandle after
  the capture is complete.  (Requires Perl 5.8)
  
  Capture::Tiny may not succeed resending UTF-8 encoded data to a tied
  STDOUT or STDERR filehandle.  Characters may appear as bytes.  If the tied filehandle
  is based on L<Tie::StdHandle>, then Capture::Tiny will attempt to determine
  appropriate layers like C<<< :utf8 >>> from the underlying filehandle and do the right
  thing.
  
  B<Tied input filehandle>
  
  Capture::Tiny attempts to preserve the semantics of tied STDIN, but this
  requires Perl 5.8 and is not entirely predictable.  External processes
  will not be able to read from such a handle.
  
  Unless having STDIN tied is crucial, it may be safest to localize STDIN when
  capturing:
  
     my ($out, $err) = do { local *STDIN; capture { ... } };
  
  =head2 Modifying filehandles during a capture
  
  Attempting to modify STDIN, STDOUT or STDERR I<during> C<<< capture >>> or C<<< tee >>> is
  almost certainly going to cause problems.  Don't do that.
  
  =head2 No support for Perl 5.8.0
  
  It's just too buggy when it comes to layers and UTF-8.  Perl 5.8.1 or later
  is recommended.
  
  =head2 Limited support for Perl 5.6
  
  Perl 5.6 predates PerlIO.  UTF-8 data may not be captured correctly.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_CAPTURE_TINY_TIMEOUT
  
  Capture::Tiny uses subprocesses for C<<< tee >>>.  By default, Capture::Tiny will
  timeout with an error if the subprocesses are not ready to receive data within
  30 seconds (or whatever is the value of C<<< $Capture::Tiny::TIMEOUT >>>).  An
  alternate timeout may be specified by setting the C<<< PERL_CAPTURE_TINY_TIMEOUT >>>
  environment variable.  Setting it to zero will disable timeouts.
  
  =head1 SEE ALSO
  
  This module was, inspired by L<IO::CaptureOutput>, which provides
  similar functionality without the ability to tee output and with more
  complicated code and API.  L<IO::CaptureOutput> does not handle layers
  or most of the unusual cases described in the L</Limitations> section and
  I no longer recommend it.
  
  There are many other CPAN modules that provide some sort of output capture,
  albeit with various limitations that make them appropriate only in particular
  circumstances.  I'm probably missing some.  The long list is provided to show
  why I felt Capture::Tiny was necessary.
  
  =over
  
  =item *
  
  L<IO::Capture>
  
  =item *
  
  L<IO::Capture::Extended>
  
  =item *
  
  L<IO::CaptureOutput>
  
  =item *
  
  L<IPC::Capture>
  
  =item *
  
  L<IPC::Cmd>
  
  =item *
  
  L<IPC::Open2>
  
  =item *
  
  L<IPC::Open3>
  
  =item *
  
  L<IPC::Open3::Simple>
  
  =item *
  
  L<IPC::Open3::Utils>
  
  =item *
  
  L<IPC::Run>
  
  =item *
  
  L<IPC::Run::SafeHandles>
  
  =item *
  
  L<IPC::Run::Simple>
  
  =item *
  
  L<IPC::Run3>
  
  =item *
  
  L<IPC::System::Simple>
  
  =item *
  
  L<Tee>
  
  =item *
  
  L<IO::Tee>
  
  =item *
  
  L<File::Tee>
  
  =item *
  
  L<Filter::Handle>
  
  =item *
  
  L<Tie::STDERR>
  
  =item *
  
  L<Tie::STDOUT>
  
  =item *
  
  L<Test::Output>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/capture-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/capture-tiny>
  
    git clone git://github.com/dagolden/capture-tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2009 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
CAPTURE_TINY

$fatpacked{"Carp.pm"} = <<'CARP';
  package Carp;
  
  { use 5.006; }
  use strict;
  use warnings;
  
  BEGIN {
      no strict "refs";
      if(exists($::{"utf8::"}) && exists(*{$::{"utf8::"}}{HASH}->{"is_utf8"}) &&
  	    defined(*{*{$::{"utf8::"}}{HASH}->{"is_utf8"}}{CODE})) {
  	*is_utf8 = \&{"utf8::is_utf8"};
      } else {
  	*is_utf8 = sub { 0 };
      }
  }
  
  BEGIN {
      no strict "refs";
      if(exists($::{"utf8::"}) && exists(*{$::{"utf8::"}}{HASH}->{"downgrade"}) &&
  	    defined(*{*{$::{"utf8::"}}{HASH}->{"downgrade"}}{CODE})) {
  	*downgrade = \&{"utf8::downgrade"};
      } else {
  	*downgrade = sub {};
      }
  }
  
  our $VERSION = '1.26';
  
  our $MaxEvalLen = 0;
  our $Verbose    = 0;
  our $CarpLevel  = 0;
  our $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.
  our $MaxArgNums = 8;     # How many arguments to print. 0 = all.
  
  require Exporter;
  our @ISA       = ('Exporter');
  our @EXPORT    = qw(confess croak carp);
  our @EXPORT_OK = qw(cluck verbose longmess shortmess);
  our @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode
  
  # The members of %Internal are packages that are internal to perl.
  # Carp will not report errors from within these packages if it
  # can.  The members of %CarpInternal are internal to Perl's warning
  # system.  Carp will not report errors from within these packages
  # either, and will not report calls *to* these packages for carp and
  # croak.  They replace $CarpLevel, which is deprecated.    The
  # $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
  # text and function arguments should be formatted when printed.
  
  our %CarpInternal;
  our %Internal;
  
  # disable these by default, so they can live w/o require Carp
  $CarpInternal{Carp}++;
  $CarpInternal{warnings}++;
  $Internal{Exporter}++;
  $Internal{'Exporter::Heavy'}++;
  
  # if the caller specifies verbose usage ("perl -MCarp=verbose script.pl")
  # then the following method will be called by the Exporter which knows
  # to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word
  # 'verbose'.
  
  sub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }
  
  sub _cgc {
      no strict 'refs';
      return \&{"CORE::GLOBAL::caller"} if defined &{"CORE::GLOBAL::caller"};
      return;
  }
  
  sub longmess {
      # Icky backwards compatibility wrapper. :-(
      #
      # The story is that the original implementation hard-coded the
      # number of call levels to go back, so calls to longmess were off
      # by one.  Other code began calling longmess and expecting this
      # behaviour, so the replacement has to emulate that behaviour.
      my $cgc = _cgc();
      my $call_pack = $cgc ? $cgc->() : caller();
      if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {
          return longmess_heavy(@_);
      }
      else {
          local $CarpLevel = $CarpLevel + 1;
          return longmess_heavy(@_);
      }
  }
  
  our @CARP_NOT;
  
  sub shortmess {
      my $cgc = _cgc();
  
      # Icky backwards compatibility wrapper. :-(
      local @CARP_NOT = $cgc ? $cgc->() : caller();
      shortmess_heavy(@_);
  }
  
  sub croak   { die shortmess @_ }
  sub confess { die longmess @_ }
  sub carp    { warn shortmess @_ }
  sub cluck   { warn longmess @_ }
  
  BEGIN {
      if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015) ||
  	    ("$]" >= 5.012005 && "$]" < 5.013)) {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };
      } else {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };
      }
  }
  
  sub caller_info {
      my $i = shift(@_) + 1;
      my %call_info;
      my $cgc = _cgc();
      {
  	# Some things override caller() but forget to implement the
  	# @DB::args part of it, which we need.  We check for this by
  	# pre-populating @DB::args with a sentinel which no-one else
  	# has the address of, so that we can detect whether @DB::args
  	# has been properly populated.  However, on earlier versions
  	# of perl this check tickles a bug in CORE::caller() which
  	# leaks memory.  So we only check on fixed perls.
          @DB::args = \$i if CALLER_OVERRIDE_CHECK_OK;
          package DB;
          @call_info{
              qw(pack file line sub has_args wantarray evaltext is_require) }
              = $cgc ? $cgc->($i) : caller($i);
      }
  
      unless ( defined $call_info{pack} ) {
          return ();
      }
  
      my $sub_name = Carp::get_subname( \%call_info );
      if ( $call_info{has_args} ) {
          my @args;
          if (CALLER_OVERRIDE_CHECK_OK && @DB::args == 1
              && ref $DB::args[0] eq ref \$i
              && $DB::args[0] == \$i ) {
              @DB::args = ();    # Don't let anyone see the address of $i
              local $@;
              my $where = eval {
                  my $func    = $cgc or return '';
                  my $gv      =
                      *{
                          ( $::{"B::"} || return '')       # B stash
                            ->{svref_2object} || return '' # entry in stash
                       }{CODE}                             # coderef in entry
                          ->($func)->GV;
                  my $package = $gv->STASH->NAME;
                  my $subname = $gv->NAME;
                  return unless defined $package && defined $subname;
  
                  # returning CORE::GLOBAL::caller isn't useful for tracing the cause:
                  return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';
                  " in &${package}::$subname";
              } || '';
              @args
                  = "** Incomplete caller override detected$where; \@DB::args were not set **";
          }
          else {
              @args = map { Carp::format_arg($_) } @DB::args;
          }
          if ( $MaxArgNums and @args > $MaxArgNums )
          {    # More than we want to show?
              $#args = $MaxArgNums;
              push @args, '...';
          }
  
          # Push the args onto the subroutine
          $sub_name .= '(' . join( ', ', @args ) . ')';
      }
      $call_info{sub_name} = $sub_name;
      return wantarray() ? %call_info : \%call_info;
  }
  
  # Transform an argument to a function into a string.
  sub format_arg {
      my $arg = shift;
      if ( ref($arg) ) {
          $arg = defined($overload::VERSION) ? overload::StrVal($arg) : "$arg";
      }
      if ( defined($arg) ) {
          $arg =~ s/'/\\'/g;
          $arg = str_len_trim( $arg, $MaxArgLen );
  
          # Quote it?
          # Downgrade, and use [0-9] rather than \d, to avoid loading
          # Unicode tables, which would be liable to fail if we're
          # processing a syntax error.
          downgrade($arg, 1);
          $arg = "'$arg'" unless $arg =~ /^-?[0-9.]+\z/;
      }
      else {
          $arg = 'undef';
      }
  
      # The following handling of "control chars" is direct from
      # the original code - it is broken on Unicode though.
      # Suggestions?
      is_utf8($arg)
          or $arg =~ s/([[:cntrl:]]|[[:^ascii:]])/sprintf("\\x{%x}",ord($1))/eg;
      return $arg;
  }
  
  # Takes an inheritance cache and a package and returns
  # an anon hash of known inheritances and anon array of
  # inheritances which consequences have not been figured
  # for.
  sub get_status {
      my $cache = shift;
      my $pkg   = shift;
      $cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];
      return @{ $cache->{$pkg} };
  }
  
  # Takes the info from caller() and figures out the name of
  # the sub/require/eval
  sub get_subname {
      my $info = shift;
      if ( defined( $info->{evaltext} ) ) {
          my $eval = $info->{evaltext};
          if ( $info->{is_require} ) {
              return "require $eval";
          }
          else {
              $eval =~ s/([\\\'])/\\$1/g;
              return "eval '" . str_len_trim( $eval, $MaxEvalLen ) . "'";
          }
      }
  
      return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};
  }
  
  # Figures out what call (from the point of view of the caller)
  # the long error backtrace should start at.
  sub long_error_loc {
      my $i;
      my $lvl = $CarpLevel;
      {
          ++$i;
          my $cgc = _cgc();
          my $pkg = $cgc ? $cgc->($i) : caller($i);
          unless ( defined($pkg) ) {
  
              # This *shouldn't* happen.
              if (%Internal) {
                  local %Internal;
                  $i = long_error_loc();
                  last;
              }
              else {
  
                  # OK, now I am irritated.
                  return 2;
              }
          }
          redo if $CarpInternal{$pkg};
          redo unless 0 > --$lvl;
          redo if $Internal{$pkg};
      }
      return $i - 1;
  }
  
  sub longmess_heavy {
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = long_error_loc();
      return ret_backtrace( $i, @_ );
  }
  
  # Returns a full stack backtrace starting from where it is
  # told.
  sub ret_backtrace {
      my ( $i, @error ) = @_;
      my $mess;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      $mess = "$err at $i{file} line $i{line}$tid_msg";
      if( defined $. ) {
          local $@ = '';
          local $SIG{__DIE__};
          eval {
              CORE::die;
          };
          if($@ =~ /^Died at .*(, <.*?> line \d+).$/ ) {
              $mess .= $1;
          }
      }
      $mess .= "\.\n";
  
      while ( my %i = caller_info( ++$i ) ) {
          $mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
      }
  
      return $mess;
  }
  
  sub ret_summary {
      my ( $i, @error ) = @_;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      return "$err at $i{file} line $i{line}$tid_msg\.\n";
  }
  
  sub short_error_loc {
      # You have to create your (hash)ref out here, rather than defaulting it
      # inside trusts *on a lexical*, as you want it to persist across calls.
      # (You can default it on $_[2], but that gets messy)
      my $cache = {};
      my $i     = 1;
      my $lvl   = $CarpLevel;
      {
          my $cgc = _cgc();
          my $called = $cgc ? $cgc->($i) : caller($i);
          $i++;
          my $caller = $cgc ? $cgc->($i) : caller($i);
  
          return 0 unless defined($caller);    # What happened?
          redo if $Internal{$caller};
          redo if $CarpInternal{$caller};
          redo if $CarpInternal{$called};
          redo if trusts( $called, $caller, $cache );
          redo if trusts( $caller, $called, $cache );
          redo unless 0 > --$lvl;
      }
      return $i - 1;
  }
  
  sub shortmess_heavy {
      return longmess_heavy(@_) if $Verbose;
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = short_error_loc();
      if ($i) {
          ret_summary( $i, @_ );
      }
      else {
          longmess_heavy(@_);
      }
  }
  
  # If a string is too long, trims it with ...
  sub str_len_trim {
      my $str = shift;
      my $max = shift || 0;
      if ( 2 < $max and $max < length($str) ) {
          substr( $str, $max - 3 ) = '...';
      }
      return $str;
  }
  
  # Takes two packages and an optional cache.  Says whether the
  # first inherits from the second.
  #
  # Recursive versions of this have to work to avoid certain
  # possible endless loops, and when following long chains of
  # inheritance are less efficient.
  sub trusts {
      my $child  = shift;
      my $parent = shift;
      my $cache  = shift;
      my ( $known, $partial ) = get_status( $cache, $child );
  
      # Figure out consequences until we have an answer
      while ( @$partial and not exists $known->{$parent} ) {
          my $anc = shift @$partial;
          next if exists $known->{$anc};
          $known->{$anc}++;
          my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );
          my @found = keys %$anc_knows;
          @$known{@found} = ();
          push @$partial, @$anc_partial;
      }
      return exists $known->{$parent};
  }
  
  # Takes a package and gives a list of those trusted directly
  sub trusts_directly {
      my $class = shift;
      no strict 'refs';
      no warnings 'once';
      return @{"$class\::CARP_NOT"}
          ? @{"$class\::CARP_NOT"}
          : @{"$class\::ISA"};
  }
  
  if(!defined($warnings::VERSION) ||
  	do { no warnings "numeric"; $warnings::VERSION < 1.03 }) {
      # Very old versions of warnings.pm import from Carp.  This can go
      # wrong due to the circular dependency.  If Carp is invoked before
      # warnings, then Carp starts by loading warnings, then warnings
      # tries to import from Carp, and gets nothing because Carp is in
      # the process of loading and hasn't defined its import method yet.
      # So we work around that by manually exporting to warnings here.
      no strict "refs";
      *{"warnings::$_"} = \&$_ foreach @EXPORT;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Carp - alternative warn and die for modules
  
  =head1 SYNOPSIS
  
      use Carp;
  
      # warn user (from perspective of caller)
      carp "string trimmed to 80 chars";
  
      # die of errors (from perspective of caller)
      croak "We're outta here!";
  
      # die of errors with stack backtrace
      confess "not implemented";
  
      # cluck not exported by default
      use Carp qw(cluck);
      cluck "This is how we got here!";
  
  =head1 DESCRIPTION
  
  The Carp routines are useful in your own modules because
  they act like die() or warn(), but with a message which is more
  likely to be useful to a user of your module.  In the case of
  cluck, confess, and longmess that context is a summary of every
  call in the call-stack.  For a shorter message you can use C<carp>
  or C<croak> which report the error as being from where your module
  was called.  There is no guarantee that that is where the error
  was, but it is a good educated guess.
  
  You can also alter the way the output and logic of C<Carp> works, by
  changing some global variables in the C<Carp> namespace. See the
  section on C<GLOBAL VARIABLES> below.
  
  Here is a more complete description of how C<carp> and C<croak> work.
  What they do is search the call-stack for a function call stack where
  they have not been told that there shouldn't be an error.  If every
  call is marked safe, they give up and give a full stack backtrace
  instead.  In other words they presume that the first likely looking
  potential suspect is guilty.  Their rules for telling whether
  a call shouldn't generate errors work as follows:
  
  =over 4
  
  =item 1.
  
  Any call from a package to itself is safe.
  
  =item 2.
  
  Packages claim that there won't be errors on calls to or from
  packages explicitly marked as safe by inclusion in C<@CARP_NOT>, or
  (if that array is empty) C<@ISA>.  The ability to override what
  @ISA says is new in 5.8.
  
  =item 3.
  
  The trust in item 2 is transitive.  If A trusts B, and B
  trusts C, then A trusts C.  So if you do not override C<@ISA>
  with C<@CARP_NOT>, then this trust relationship is identical to,
  "inherits from".
  
  =item 4.
  
  Any call from an internal Perl module is safe.  (Nothing keeps
  user modules from marking themselves as internal to Perl, but
  this practice is discouraged.)
  
  =item 5.
  
  Any call to Perl's warning system (eg Carp itself) is safe.
  (This rule is what keeps it from reporting the error at the
  point where you call C<carp> or C<croak>.)
  
  =item 6.
  
  C<$Carp::CarpLevel> can be set to skip a fixed number of additional
  call levels.  Using this is not recommended because it is very
  difficult to get it to behave correctly.
  
  =back
  
  =head2 Forcing a Stack Trace
  
  As a debugging aid, you can force Carp to treat a croak as a confess
  and a carp as a cluck across I<all> modules. In other words, force a
  detailed stack trace to be given.  This can be very helpful when trying
  to understand why, or from where, a warning or error is being generated.
  
  This feature is enabled by 'importing' the non-existent symbol
  'verbose'. You would typically enable it by saying
  
      perl -MCarp=verbose script.pl
  
  or by including the string C<-MCarp=verbose> in the PERL5OPT
  environment variable.
  
  Alternately, you can set the global variable C<$Carp::Verbose> to true.
  See the C<GLOBAL VARIABLES> section below.
  
  =head1 GLOBAL VARIABLES
  
  =head2 $Carp::MaxEvalLen
  
  This variable determines how many characters of a string-eval are to
  be shown in the output. Use a value of C<0> to show all text.
  
  Defaults to C<0>.
  
  =head2 $Carp::MaxArgLen
  
  This variable determines how many characters of each argument to a
  function to print. Use a value of C<0> to show the full length of the
  argument.
  
  Defaults to C<64>.
  
  =head2 $Carp::MaxArgNums
  
  This variable determines how many arguments to each function to show.
  Use a value of C<0> to show all arguments to a function call.
  
  Defaults to C<8>.
  
  =head2 $Carp::Verbose
  
  This variable makes C<carp> and C<croak> generate stack backtraces
  just like C<cluck> and C<confess>.  This is how C<use Carp 'verbose'>
  is implemented internally.
  
  Defaults to C<0>.
  
  =head2 @CARP_NOT
  
  This variable, I<in your package>, says which packages are I<not> to be
  considered as the location of an error. The C<carp()> and C<cluck()>
  functions will skip over callers when reporting where an error occurred.
  
  NB: This variable must be in the package's symbol table, thus:
  
      # These work
      our @CARP_NOT; # file scope
      use vars qw(@CARP_NOT); # package scope
      @My::Package::CARP_NOT = ... ; # explicit package variable
  
      # These don't work
      sub xyz { ... @CARP_NOT = ... } # w/o declarations above
      my @CARP_NOT; # even at top-level
  
  Example of use:
  
      package My::Carping::Package;
      use Carp;
      our @CARP_NOT;
      sub bar     { .... or _error('Wrong input') }
      sub _error  {
          # temporary control of where'ness, __PACKAGE__ is implicit
          local @CARP_NOT = qw(My::Friendly::Caller);
          carp(@_)
      }
  
  This would make C<Carp> report the error as coming from a caller not
  in C<My::Carping::Package>, nor from C<My::Friendly::Caller>.
  
  Also read the L</DESCRIPTION> section above, about how C<Carp> decides
  where the error is reported from.
  
  Use C<@CARP_NOT>, instead of C<$Carp::CarpLevel>.
  
  Overrides C<Carp>'s use of C<@ISA>.
  
  =head2 %Carp::Internal
  
  This says what packages are internal to Perl.  C<Carp> will never
  report an error as being from a line in a package that is internal to
  Perl.  For example:
  
      $Carp::Internal{ (__PACKAGE__) }++;
      # time passes...
      sub foo { ... or confess("whatever") };
  
  would give a full stack backtrace starting from the first caller
  outside of __PACKAGE__.  (Unless that package was also internal to
  Perl.)
  
  =head2 %Carp::CarpInternal
  
  This says which packages are internal to Perl's warning system.  For
  generating a full stack backtrace this is the same as being internal
  to Perl, the stack backtrace will not start inside packages that are
  listed in C<%Carp::CarpInternal>.  But it is slightly different for
  the summary message generated by C<carp> or C<croak>.  There errors
  will not be reported on any lines that are calling packages in
  C<%Carp::CarpInternal>.
  
  For example C<Carp> itself is listed in C<%Carp::CarpInternal>.
  Therefore the full stack backtrace from C<confess> will not start
  inside of C<Carp>, and the short message from calling C<croak> is
  not placed on the line where C<croak> was called.
  
  =head2 $Carp::CarpLevel
  
  This variable determines how many additional call frames are to be
  skipped that would not otherwise be when reporting where an error
  occurred on a call to one of C<Carp>'s functions.  It is fairly easy
  to count these call frames on calls that generate a full stack
  backtrace.  However it is much harder to do this accounting for calls
  that generate a short message.  Usually people skip too many call
  frames.  If they are lucky they skip enough that C<Carp> goes all of
  the way through the call stack, realizes that something is wrong, and
  then generates a full stack backtrace.  If they are unlucky then the
  error is reported from somewhere misleading very high in the call
  stack.
  
  Therefore it is best to avoid C<$Carp::CarpLevel>.  Instead use
  C<@CARP_NOT>, C<%Carp::Internal> and C<%Carp::CarpInternal>.
  
  Defaults to C<0>.
  
  =head1 BUGS
  
  The Carp routines don't handle exception objects currently.
  If called with a first argument that is a reference, they simply
  call die() or warn(), as appropriate.
  
  =head1 SEE ALSO
  
  L<Carp::Always>,
  L<Carp::Clan>
  
  =head1 AUTHOR
  
  The Carp module first appeared in Larry Wall's perl 5.000 distribution.
  Since then it has been modified by several of the perl 5 porters.
  Andrew Main (Zefram) <zefram@fysh.org> divested Carp into an independent
  distribution.
  
  =head1 COPYRIGHT
  
  Copyright (C) 1994-2012 Larry Wall
  
  Copyright (C) 2011, 2012 Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
CARP

$fatpacked{"Carp/Heavy.pm"} = <<'CARP_HEAVY';
  package Carp::Heavy;
  
  use Carp ();
  
  our $VERSION = '1.26';
  
  1;
  
  # Most of the machinery of Carp used to be here.
  # It has been moved in Carp.pm now, but this placeholder remains for
  # the benefit of modules that like to preload Carp::Heavy directly.
  # This must load Carp, because some modules rely on the historical
  # behaviour of Carp::Heavy loading Carp.
CARP_HEAVY

$fatpacked{"DateTime/Tiny.pm"} = <<'DATETIME_TINY';
  package DateTime::Tiny;
  
  =pod
  
  =head1 NAME
  
  DateTime::Tiny - A date object, with as little code as possible
  
  =head1 SYNOPSIS
  
    # Create a date manually
    $christmas = DateTime::Tiny->new(
        year   => 2006,
        month  => 12,
        day    => 25,
        hour   => 10,
        minute => 45,
        second => 0,
        );
    
    # Show the current date
    my $now = DateTime::Tiny->now;
    print "Year   : " . $now->year   . "\n";
    print "Month  : " . $now->month  . "\n";
    print "Day    : " . $now->day    . "\n"; 
    print "Hour   : " . $now->hour   . "\n";
    print "Minute : " . $now->minute . "\n";
    print "Second : " . $now->second . "\n";
  
  =head1 DESCRIPTION
  
  B<DateTime::Tiny> is a most prominent member of the L<DateTime::Tiny>
  suite of time modules.
  
  It implements an extremely lightweight object that represents a datetime.
  
  =head2 The Tiny Mandate
  
  Many CPAN modules which provide the best implementation of a certain
  concepts are very large. For some reason, this generally seems to be
  about 3 megabyte of ram usage to load the module.
  
  For a lot of the situations in which these large and comprehensive
  implementations exist, some people will only need a small fraction of the
  functionality, or only need this functionality in an ancillary role.
  
  The aim of the Tiny modules is to implement an alternative to the large
  module that implements a useful subset of their functionality, using as
  little code as possible.
  
  Typically, this means a module that implements between 50% and 80% of
  the features of the larger module (although this is just a guideline),
  but using only 100 kilobytes of code, which is about 1/30th of the larger
  module.
  
  =head2 The Concept of Tiny Date and Time
  
  Due to the inherent complexity, Date and Time is intrinsically very
  difficult to implement properly.
  
  The arguably B<only> module to implement it completely correct is
  L<DateTime>. However, to implement it properly L<DateTime> is quite slow
  and requires 3-4 megabytes of memory to load.
  
  The challenge in implementing a Tiny equivalent to DateTime is to do so
  without making the functionality critically flawed, and to carefully
  select the subset of functionality to implement.
  
  If you look at where the main complexity and cost exists, you will find
  that it is relatively cheap to represent a date or time as an object,
  but much much more expensive to modify, manipulate or convert the object.
  
  As a result, B<DateTime::Tiny> provides the functionality required to
  represent a date as an object, to stringify the date and to parse it
  back in, but does B<not> allow you to modify the dates.
  
  The purpose of this is to allow for date object representations in
  situations like log parsing and fast real-time type work.
  
  The problem with this is that having no ability to modify date limits
  the usefulness greatly.
  
  To make up for this, B<if> you have L<DateTime> installed, any
  B<DateTime::Tiny> module can be inflated into the equivalent L<DateTime>
  as needing, loading L<DateTime> on the fly if necesary.
  
  This is somewhat similar to DateTime::LazyInit, but unlike that module
  B<DateTime::Tiny> is not modifiable.
  
  For the purposes of date/time logic, all B<DateTime::Tiny> objects exist
  in the "C" locale, and the "floating" time zone. This may be improved in
  the future if a suitably tiny way of handling timezones is found.
  
  When converting up to full L<DateTime> objects, these local and time
  zone settings will be applied (although an ability is provided to
  override this).
  
  In addition, the implementation is strictly correct and is intended to
  be very easily to sub-class for specific purposes of your own.
  
  =head1 METHODS
  
  In general, the intent is that the API be as close as possible to the
  API for L<DateTime>. Except, of course, that this module implements
  less of it.
  
  =cut
  
  use strict;
  BEGIN {
  	require 5.004;
  	$DateTime::Tiny::VERSION = '1.04';
  }
  use overload 'bool' => sub () { 1 };
  use overload '""'   => 'as_string';
  use overload 'eq'   => sub { "$_[0]" eq "$_[1]" };
  use overload 'ne'   => sub { "$_[0]" ne "$_[1]" };
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
    my $date = DateTime::Tiny->new(
        year   => 2006,
        month  => 12,
        day    => 31,
        hour   => 10,
        minute => 45,
        second => 32,
        );
  
  The C<new> constructor creates a new B<DateTime::Tiny> object.
  
  It takes six named params. C<day> should be the day of the month (1-31),
  C<month> should be the month of the year (1-12), C<year> as a 4 digit year.
  C<hour> should be the hour of the day (0-23), C<minute> should be the
  minute of the hour (0-59) and C<second> should be the second of the
  minute (0-59).
  
  These are the only params accepted.
  
  Returns a new B<DateTime::Tiny> object.
  
  =cut
  
  sub new {
  	my $class = shift;
  	bless { @_ }, $class;
  }
  
  =pod
  
  =head2 now
  
    my $current_date = DateTime::Tiny->now;
  
  The C<now> method creates a new date object for the current date.
  
  The date created will be based on localtime, despite the fact that
  the date is created in the floating time zone.
  
  Returns a new B<DateTime::Tiny> object.
  
  =cut
  
  sub now {
  	my @t = localtime time;
  	shift->new(
  		year   => $t[5] + 1900,
  		month  => $t[4] + 1,
  		day    => $t[3],
  		hour   => $t[2],
  		minute => $t[1],
  		second => $t[0],
  	);
  }
  
  =pod
  
  =head2 year
  
  The C<year> accessor returns the 4-digit year for the date.
  
  =cut
  
  sub year {
  	defined $_[0]->{year} ? $_[0]->{year} : 1970;
  }
  
  =pod
  
  =head2 month
  
  The C<month> accessor returns the 1-12 month of the year for the date.
  
  =cut
  
  sub month {
  	$_[0]->{month} || 1;
  }
  
  =pod
  
  =head2 day
  
  The C<day> accessor returns the 1-31 day of the month for the date.
  
  =cut
  
  sub day {
  	$_[0]->{day} || 1;
  }
  
  =pod
  
  =head2 hour
  
  The C<hour> accessor returns the hour component of the time as
  an integer from zero to twenty-three (0-23) in line with 24-hour
  time.
  
  =cut
  
  sub hour {
  	$_[0]->{hour} || 0;
  }
  
  =pod
  
  =head2 minute
  
  The C<minute> accessor returns the minute component of the time
  as an integer from zero to fifty-nine (0-59).
  
  =cut
  
  sub minute {
  	$_[0]->{minute} || 0;
  }
  
  =pod
  
  =head2 second
  
  The C<second> accessor returns the second component of the time
  as an integer from zero to fifty-nine (0-59).
  
  =cut
  
  sub second {
  	$_[0]->{second} || 0;
  }
  
  =pod
  
  =head2 ymdhms
  
  The C<ymdhms> method returns the most common and accurate stringified date
  format, which returns in the form "2006-04-12".
  
  =cut
  
  sub ymdhms {
  	sprintf( "%04u-%02u-%02uT%02u:%02u:%02u",
  		$_[0]->year,
  		$_[0]->month,
  		$_[0]->day,
  		$_[0]->hour,
  		$_[0]->minute,
  		$_[0]->second,
  	);
  }
  
  
  
  
  
  #####################################################################
  # Type Conversion
  
  =pod
  
  =head2 from_string
  
  The C<from_string> method creates a new B<DateTime::Tiny> object from a string.
  
  The string is expected to be an ISO 8601 time, with seperators.
  
    my $almost_midnight = DateTime::Tiny->from_string( '2006-12-20T23:59:59' );
  
  Returns a new B<DateTime::Tiny> object, or throws an exception on error.
  
  =cut
  
  sub from_string {
  	my $string = $_[1];
  	unless ( defined $string and ! ref $string ) {
  		Carp::croak("Did not provide a string to from_string");
  	}
  	unless ( $string =~ /^(\d\d\d\d)-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)$/ ) {
  		Carp::croak("Invalid time format (does not match ISO 8601)");
  	}
  	$_[0]->new(
  		year   => $1 + 0,
  		month  => $2 + 0,
  		day    => $3 + 0,
  		hour   => $4 + 0,
  		minute => $5 + 0,
  		second => $6 + 0,
  	);
  }
  
  =pod
  
  =head2 as_string
  
  The C<as_string> method converts the date to the default string, which
  at present is the same as that returned by the C<ymd> method above.
  
  This string matches the ISO 8601 standard for the encoding of a date as
  a string.
  
  =cut
  
  sub as_string {
  	$_[0]->ymdhms;
  }
  
  =pod
  
  =head2 DateTime
  
  The C<DateTime> method is used to create a L<DateTime> object
  that is equivalent to the B<DateTime::Tiny> object, for use in
  comversions and caluculations.
  
  As mentioned earlier, the object will be set to the 'C' locate,
  and the 'floating' time zone.
  
  If installed, the L<DateTime> module will be loaded automatically.
  
  Returns a L<DateTime> object, or throws an exception if L<DateTime>
  is not installed on the current host.
  
  =cut
  
  sub DateTime {
  	require DateTime;
  	my $self = shift;
  	DateTime->new(
  		day       => $self->day,
  		month     => $self->month,
  		year      => $self->year,
  		hour      => $self->hour,
  		minute    => $self->minute,
  		second    => $self->second,
  		locale    => 'C',
  		time_zone => 'floating',
  		@_,
  	);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=DateTime-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<DateTime>, L<Date::Tiny>, L<Time::Tiny>, L<Config::Tiny>, L<ali.as>
  
  =head1 COPYRIGHT
  
  Copyright 2006 - 2009 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
DATETIME_TINY

$fatpacked{"JSON/PP.pm"} = <<'JSON_PP';
  package JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  use base qw(Exporter);
  use overload ();
  
  use Carp ();
  use B ();
  #use Devel::Peek;
  
  $JSON::PP::VERSION = '2.27200';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enable?
      # Helper module sets @JSON::PP::_properties.
      if ($] < 5.008 ) {
          my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $flag_name = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my %encode_allow_method
       = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                            allow_blessed convert_blessed indent indent_length allow_bignum
                            as_nonblessed
                          /;
  my %decode_allow_method
       = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                            allow_barekey max_size relaxed/;
  
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent      => 0,
          FLAGS       => 0,
          fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ > 1) {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $idx = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($idx->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
                  return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
  
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  ) unless ($allow_blessed);
  
                  return 'null';
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, string_to_json( $self, $k )
                            .  $del
                            . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, $self->object_to_json($v) || $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
      }
  
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $b_obj = B::svref_2object(\$value);  # for round trip problem
          my $flags = $b_obj->FLAGS;
  
          return $value # as is 
              if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
          my $type = ref($value);
  
          if(!$type){
              return string_to_json($self, $value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          elsif ($type) {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
               if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                   return 'null';
               }
               else {
                   if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                   }
                   else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                   }
               }
  
          }
          else {
              return $self->{fallback}->($value)
                   if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
              return 'null';
          }
  
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # 1chracter
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest nubmer of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bigint;   # using Math::BigInt
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      # $opt flag
      # 0x00000001 .... decode_prefix
      # 0x10000000 .... incr_parse
  
      sub PP_decode_json {
          my ($self, $opt); # $opt is an effective flag during this decode_json.
  
          ($self, $text, $opt) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $idx = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
              = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
          }
          else {
              utf8::upgrade( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          # Currently no effect
          # should use regexp
          my @octets = unpack('C4', $text);
          $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                      : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                      : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                      : ( $octets[2]                ) ? 'UTF-16LE'
                      : (!$octets[2]                ) ? 'UTF-32LE'
                      : 'unknown';
  
          white(); # remove head white space
  
          my $valid_start = defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
  
          if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          if ( $ch ) {
              return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
              decode_error("garbage after JSON object");
          }
  
          ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my ($i, $s, $t, $u);
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          if ( $utf8 ) {
                              unless( $ch = is_valid_utf8($ch) ) {
                                  $at -= 1;
                                  decode_error("malformed UTF-8 character in JSON string");
                              }
                              else {
                                  $at += $utf8_len - 1;
                              }
                          }
                          else {
                              utf8::encode( $ch );
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch le ' '){
                  next_chr();
              }
              elsif($ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at--;
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
  
          # According to RFC4627, hex or oct digts are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              my $hex  = $peek =~ /[xX]/; # 0 or 1
  
              if($hex){
                  decode_error("malformed number (leading zero must not be followed by another digit)");
                  ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
              }
              else{ # oct
                  ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                  if (defined $n and length $n > 1) {
                      decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
              }
  
              if(defined $n and length($n)){
                  if (!$hex and length($n) == 1) {
                     decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
                  $at += length($n) + $hex;
                  next_chr;
                  return $hex ? hex($n) : oct($n);
              }
          }
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($v !~ /[.eE]/ and length $v > $max_intsize) {
              if ($allow_bigint) { # from Adam Sussman
                  require Math::BigInt;
                  return Math::BigInt->new($v);
              }
              else {
                  return "$v";
              }
          }
          elsif ($allow_bigint) {
              require Math::BigFloat;
              return Math::BigFloat->new($v);
          }
  
          return 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = $] >= 5.008           ? 'U*'
                     : $] <  5.006           ? 'C*'
                     : utf8::is_utf8( $str ) ? 'U*' # 5.6
                     : 'C*'
                     ;
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( $] >= 5.008 ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
      }
  
      if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
          package JSON::PP;
          require subs;
          subs->import('join');
          eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |;
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Sclar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamely copied and modified from JSON::XS code.
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  package JSON::PP::Boolean;
  
  use overload (
     "0+"     => sub { ${$_[0]} },
     "++"     => sub { $_[0] = ${$_[0]} + 1 },
     "--"     => sub { $_[0] = ${$_[0]} - 1 },
     fallback => 1,
  );
  
  
  ###############################
  
  package JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  $JSON::PP::IncrParser::VERSION = '1.01';
  
  my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_parsing => 0,
          incr_p       => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
  
      my $max_size = $coder->get_max_size;
  
      if ( defined wantarray ) {
  
          $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
  
          if ( wantarray ) {
              my @ret;
  
              $self->{incr_parsing} = 1;
  
              do {
                  push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
  
                  unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                  }
  
              } until ( length $self->{incr_text} >= $self->{incr_p} );
  
              $self->{incr_parsing} = 0;
  
              return @ret;
          }
          else { # in scalar context
              $self->{incr_parsing} = 1;
              my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
              $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
              return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
          }
  
      }
  
  }
  
  
  sub _incr_parse {
      my ( $self, $coder, $text, $skip ) = @_;
      my $p = $self->{incr_p};
      my $restore = $p;
  
      my @obj;
      my $len = length $text;
  
      if ( $self->{incr_mode} == INCR_M_WS ) {
          while ( $len > $p ) {
              my $s = substr( $text, $p, 1 );
              $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
              $self->{incr_mode} = INCR_M_JSON;
              last;
         }
      }
  
      while ( $len > $p ) {
          my $s = substr( $text, $p++, 1 );
  
          if ( $s eq '"' ) {
              if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                  next;
              }
  
              if ( $self->{incr_mode} != INCR_M_STR  ) {
                  $self->{incr_mode} = INCR_M_STR;
              }
              else {
                  $self->{incr_mode} = INCR_M_JSON;
                  unless ( $self->{incr_nest} ) {
                      last;
                  }
              }
          }
  
          if ( $self->{incr_mode} == INCR_M_JSON ) {
  
              if ( $s eq '[' or $s eq '{' ) {
                  if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                      Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                  }
              }
              elsif ( $s eq ']' or $s eq '}' ) {
                  last if ( --$self->{incr_nest} <= 0 );
              }
              elsif ( $s eq '#' ) {
                  while ( $len > $p ) {
                      last if substr( $text, $p++, 1 ) eq "\n";
                  }
              }
  
          }
  
      }
  
      $self->{incr_p} = $p;
  
      return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
      return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
  
      return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
  
      local $Carp::CarpLevel = 2;
  
      $self->{incr_p} = $restore;
      $self->{incr_c} = $p;
  
      my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
  
      $self->{incr_text} = substr( $self->{incr_text}, $p );
      $self->{incr_p} = 0;
  
      return $obj or '';
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
      $self->{incr_p} = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_p}       = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
      $self->{incr_parsing} = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.27200
  
  L<JSON::XS> 2.27 (~2.30) compatible.
  
  =head1 NOTE
  
  JSON::PP was inculded in JSON distribution (CPAN module).
  It comes to be a perl core module in Perl 5.14.
  
      [STEPS]
  
      * release this module as JSON::PPdev.
  
      * release other PP::* modules as JSON::PP::Compat*.
  
      * JSON distribution will inculde yet another JSON::PP modules.
        They are JSNO::backportPP. So JSON.pm should work as it did at all!
  
      * remove JSON::PP and JSON::PP::* modules from JSON distribution
         and release it as developer version.
  
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
      * release JSON distribution as stable version.
  
      * rename JSON::PPdev into JSON::PP and release on CPAN. <<<< HERE
  
  =head1 DESCRIPTION
  
  This module is L<JSON::XS> compatible pure Perl module.
  (Perl 5.8 or later is recommended)
  
  JSON::XS is the fastest and most proper JSON module on CPAN.
  It is written by Marc Lehmann in C, so must be compiled and
  installed in the used environment.
  
  JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
  
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module knows how to handle Unicode (depending on Perl version).
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and L<UNICODE HANDLING ON PERLS>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security feature).
  But when some options are set, loose chcking features are available.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::PP::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl vresion is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON::PP->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 METHODS
  
  Basically, check to L<JSON> or L<JSON::XS>.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Rturns a new JSON::PP object that can be used to de/encode JSON
  strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
  
  In Perl 5.005, there is no character having high value (more than 255).
  See to L<UNICODE HANDLING ON PERLS>.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  See to L<UNICODE HANDLING ON PERLS>.
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  (In Perl 5.005, any character outside the range 0..255 does not exist.
  See to L<UNICODE HANDLING ON PERLS>.)
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> flags in one call to generate the most readable
  (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  If you want your own sorting routine, you can give a code referece
  or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  In JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible.
  It will also try to downgrade any strings to octet-form if possible.
  
  In JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>.
  See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  When a large value (100 or more) was set and it de/encodes a deep nested object/text,
  it may raise a warning 'Deep recursion on subroutin' at the perl runtime phase.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthese
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the errornous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want ot repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP OWN METHODS
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<JSON::XS/MAPPING> aboout the normal conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But default
  JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  JSON::XS indent space length is 3 and cannot be changed.
  JSON::PP set the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used
  in encoding JSON objects.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  =head1 INTERNAL
  
  For developers.
  
  =over
  
  =item PP_encode_box
  
  Returns
  
          {
              depth        => $depth,
              indent_count => $indent_count,
          }
  
  
  =item PP_decode_box
  
  Returns
  
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
  
  =back
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON::PP>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded toa JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the leats significant bit.
  
  When C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check wether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::PP::true . "\n";
      => true
     print JSON::PP::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::PP::null> returns C<unddef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same datastructure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false, JSON::PP::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::PP::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choise is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  When C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 UNICODE HANDLING ON PERLS
  
  If you do not know about Unicode on Perl well,
  please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =head2 Perl 5.8 and later
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
  
      $json->allow_nonref->encode(chr hex 3042);
      $json->allow_nonref->encode(chr hex 12345);
  
  Reuturns C<"\u3042"> and C<"\ud808\udf45"> respectively.
  
      $json->allow_nonref->decode('"\u3042"');
      $json->allow_nonref->decode('"\ud808\udf45"');
  
  Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
  
  Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
  so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
  
  
  =head2 Perl 5.6
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work.
  
  =head2 Perl 5.005
  
  Perl 5.005 is a byte sementics world -- all strings are sequences of bytes.
  That means the unicode handling is not available.
  
  In encoding,
  
      $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
      $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
  
  Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
  as C<$value % 256>, so the above codes are equivalent to :
  
      $json->allow_nonref->encode(chr 66);
      $json->allow_nonref->encode(chr 69);
  
  In decoding,
  
      $json->decode('"\u00e3\u0081\u0082"');
  
  The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
  japanese character (C<HIRAGANA LETTER A>).
  And if it is represented in Unicode code point, C<U+3042>.
  
  Next, 
  
      $json->decode('"\u3042"');
  
  We ordinary expect the returned value is a Unicode character C<U+3042>.
  But here is 5.005 world. This is C<0xE3 0x81 0x82>.
  
      $json->decode('"\ud808\udf45"');
  
  This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
  
  
  =head1 TODO
  
  =over
  
  =item speed
  
  =item memory saving
  
  =back
  
  
  =head1 SEE ALSO
  
  Most of the document are copied and modified from JSON::XS doc.
  
  L<JSON::XS>
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2011 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = <<'JSON_PP_BOOLEAN';
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::PP> for more info about this class.
  
  =cut
  
  use JSON::PP ();
  use strict;
  
  1;
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_PP_BOOLEAN

$fatpacked{"Redis.pm"} = <<'REDIS';
  package Redis;
  
  # ABSTRACT: Perl binding for Redis database
  our $VERSION = '1.961'; # VERSION
  our $AUTHORITY = 'cpan:MELO'; # AUTHORITY
  
  use warnings;
  use strict;
  
  use IO::Socket::INET;
  use IO::Socket::UNIX;
  use IO::Select;
  use IO::Handle;
  use Fcntl qw( O_NONBLOCK F_SETFL );
  use Errno ();
  use Data::Dumper;
  use Carp qw/confess/;
  use Encode;
  use Try::Tiny;
  use Scalar::Util ();
  
  use constant WIN32       => $^O =~ /mswin32/i;
  use constant EWOULDBLOCK => eval {Errno::EWOULDBLOCK} || -1E9;
  use constant EAGAIN      => eval {Errno::EAGAIN} || -1E9;
  use constant EINTR       => eval {Errno::EINTR} || -1E9;
  
  
  sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = bless {}, $class;
  
    $self->{debug} = $args{debug} || $ENV{REDIS_DEBUG};
  
    ## default to lax utf8
    $self->{encoding} = exists $args{encoding} ? $args{encoding} : 'utf8';
  
    ## Deal with REDIS_SERVER ENV
    if ($ENV{REDIS_SERVER} && !$args{sock} && !$args{server}) {
      if ($ENV{REDIS_SERVER} =~ m!^/!) {
        $args{sock} = $ENV{REDIS_SERVER};
      }
      elsif ($ENV{REDIS_SERVER} =~ m!^unix:(.+)!) {
        $args{sock} = $1;
      }
      elsif ($ENV{REDIS_SERVER} =~ m!^(tcp:)?(.+)!) {
        $args{server} = $2;
      }
    }
  
    $self->{password}   = $args{password}   if $args{password};
    $self->{on_connect} = $args{on_connect} if $args{on_connect};
  
    if (my $name = $args{name}) {
      my $on_conn = $self->{on_connect};
      $self->{on_connect} = sub {
        my ($redis) = @_;
        try { $redis->client_setname($name) };
        $on_conn->(@_) if $on_conn;
        }
    }
  
    if ($args{sock}) {
      $self->{server} = $args{sock};
      $self->{builder} = sub { IO::Socket::UNIX->new($_[0]->{server}) };
    }
    else {
      $self->{server} = $args{server} || '127.0.0.1:6379';
      $self->{builder} = sub {
        IO::Socket::INET->new(
          PeerAddr => $_[0]->{server},
          Proto    => 'tcp',
        );
      };
    }
  
    $self->{is_subscriber} = 0;
    $self->{subscribers}   = {};
    $self->{reconnect}     = $args{reconnect} || 0;
    $self->{every}         = $args{every} || 1000;
  
    $self->__connect;
  
    return $self;
  }
  
  sub is_subscriber { $_[0]{is_subscriber} }
  
  
  ### we don't want DESTROY to fallback into AUTOLOAD
  sub DESTROY { }
  
  
  ### Deal with common, general case, Redis commands
  our $AUTOLOAD;
  
  sub AUTOLOAD {
    my $command = $AUTOLOAD;
    $command =~ s/.*://;
  
    my $method = sub { shift->__std_cmd($command, @_) };
  
    # Save this method for future calls
    no strict 'refs';
    *$AUTOLOAD = $method;
  
    goto $method;
  }
  
  sub __std_cmd {
    my $self    = shift;
    my $command = shift;
  
    $self->__is_valid_command($command);
  
    my $cb = @_ && ref $_[-1] eq 'CODE' ? pop : undef;
  
    # If this is an EXEC command, in pipelined mode, and one of the commands
    # executed in the transaction yields an error, we must collect all errors
    # from that command, rather than throwing an exception immediately.
    my $collect_errors = $cb && uc($command) eq 'EXEC';
  
    ## Fast path, no reconnect;
    return $self->__run_cmd($command, $collect_errors, undef, $cb, @_)
      unless $self->{reconnect};
  
    my @cmd_args = @_;
    $self->__with_reconnect(
      sub {
        $self->__run_cmd($command, $collect_errors, undef, $cb, @cmd_args);
      }
    );
  }
  
  sub __with_reconnect {
    my ($self, $cb) = @_;
  
    ## Fast path, no reconnect
    return $cb->() unless $self->{reconnect};
  
    return &try(
      $cb,
      catch {
        die $_ unless ref($_) eq 'Redis::X::Reconnect';
  
        $self->__connect;
        $cb->();
      }
    );
  }
  
  sub __run_cmd {
    my ($self, $command, $collect_errors, $custom_decode, $cb, @args) = @_;
  
    my $ret;
    my $wrapper = $cb && $custom_decode
      ? sub {
      my ($reply, $error) = @_;
      $cb->(scalar $custom_decode->($reply), $error);
      }
      : $cb || sub {
      my ($reply, $error) = @_;
      confess "[$command] $error, " if defined $error;
      $ret = $reply;
      };
  
    $self->__send_command($command, @args);
    push @{ $self->{queue} }, [$command, $wrapper, $collect_errors];
  
    return 1 if $cb;
  
    $self->wait_all_responses;
    return
        $custom_decode ? $custom_decode->($ret, !wantarray)
      : wantarray && ref $ret eq 'ARRAY' ? @$ret
      :                                    $ret;
  }
  
  sub wait_all_responses {
    my ($self) = @_;
  
    my $queue = $self->{queue};
    $self->wait_one_response while @$queue;
  
    return;
  }
  
  sub wait_one_response {
    my ($self) = @_;
  
    my $handler = shift @{ $self->{queue} };
    return unless $handler;
  
    my ($command, $cb, $collect_errors) = @$handler;
    $cb->($self->__read_response($command, $collect_errors));
  
    return;
  }
  
  
  ### Commands with extra logic
  sub quit {
    my ($self) = @_;
    return unless $self->{sock};
  
    confess "[quit] only works in synchronous mode, "
      if @_ && ref $_[-1] eq 'CODE';
  
    try {
      $self->wait_all_responses;
      $self->__send_command('QUIT');
    }
    catch {
      ## Ignore, we are quiting anyway...
    };
  
    close(delete $self->{sock}) if $self->{sock};
  
    return 1;
  }
  
  sub shutdown {
    my ($self) = @_;
    $self->__is_valid_command('SHUTDOWN');
  
    confess "[shutdown] only works in synchronous mode, "
      if @_ && ref $_[-1] eq 'CODE';
  
    return unless $self->{sock};
  
    $self->wait_all_responses;
    $self->__send_command('SHUTDOWN');
    close(delete $self->{sock}) || confess("Can't close socket: $!");
  
    return 1;
  }
  
  sub ping {
    my $self = shift;
    $self->__is_valid_command('PING');
  
    confess "[ping] only works in synchronous mode, "
      if @_ && ref $_[-1] eq 'CODE';
  
    return unless exists $self->{sock};
  
    $self->wait_all_responses;
    return scalar try {
      $self->__std_cmd('PING');
    }
    catch {
      close(delete $self->{sock});
      return;
    };
  }
  
  sub info {
    my $self = shift;
    $self->__is_valid_command('INFO');
  
    my $custom_decode = sub {
      my ($reply) = @_;
      return $reply if !defined $reply || ref $reply;
      return { map { split(/:/, $_, 2) } grep {/^[^#]/} split(/\r\n/, $reply) };
    };
  
    my $cb = @_ && ref $_[-1] eq 'CODE' ? pop : undef;
  
    ## Fast path, no reconnect
    return $self->__run_cmd('INFO', 0, $custom_decode, $cb, @_)
      unless $self->{reconnect};
  
    my @cmd_args = @_;
    $self->__with_reconnect(
      sub {
        $self->__run_cmd('INFO', 0, $custom_decode, $cb, @cmd_args);
      }
    );
  }
  
  sub keys {
    my $self = shift;
    $self->__is_valid_command('KEYS');
  
    my $custom_decode = sub {
      my ($reply, $synchronous_scalar) = @_;
  
      ## Support redis <= 1.2.6
      $reply = [split(/\s/, $reply)] if defined $reply && !ref $reply;
  
      return ref $reply && ($synchronous_scalar || wantarray) ? @$reply : $reply;
    };
  
    my $cb = @_ && ref $_[-1] eq 'CODE' ? pop : undef;
  
    ## Fast path, no reconnect
    return $self->__run_cmd('KEYS', 0, $custom_decode, $cb, @_)
      unless $self->{reconnect};
  
    my @cmd_args = @_;
    $self->__with_reconnect(
      sub {
        $self->__run_cmd('KEYS', 0, $custom_decode, $cb, @cmd_args);
      }
    );
  }
  
  
  ### PubSub
  sub wait_for_messages {
    my ($self, $timeout) = @_;
    my $sock = $self->{sock};
  
    my $s = IO::Select->new;
    $s->add($sock);
  
    my $count = 0;
  MESSAGE:
    while ($s->can_read($timeout)) {
      while (1) {
        my $has_stuff = __try_read_sock($sock);
        last MESSAGE unless defined $has_stuff;    ## Stop right now if EOF
        last unless $has_stuff;                    ## back to select until timeout
  
        my ($reply, $error) = $self->__read_response('WAIT_FOR_MESSAGES');
        confess "[WAIT_FOR_MESSAGES] $error, " if defined $error;
        $self->__process_pubsub_msg($reply);
        $count++;
      }
    }
  
    return $count;
  }
  
  sub __subscription_cmd {
    my $self    = shift;
    my $pr      = shift;
    my $unsub   = shift;
    my $command = shift;
    my $cb      = pop;
  
    confess("Missing required callback in call to $command(), ")
      unless ref($cb) eq 'CODE';
  
    $self->wait_all_responses;
  
    my @subs = @_;
    $self->__with_reconnect(
      sub {
        $self->__throw_reconnect('Not connected to any server')
          unless $self->{sock};
  
        @subs = $self->__process_unsubscribe_requests($cb, $pr, @subs)
          if $unsub;
        return unless @subs;
  
        $self->__send_command($command, @subs);
  
        my %cbs = map { ("${pr}message:$_" => $cb) } @subs;
        return $self->__process_subscription_changes($command, \%cbs);
      }
    );
  }
  
  sub subscribe    { shift->__subscription_cmd('',  0, subscribe    => @_) }
  sub psubscribe   { shift->__subscription_cmd('p', 0, psubscribe   => @_) }
  sub unsubscribe  { shift->__subscription_cmd('',  1, unsubscribe  => @_) }
  sub punsubscribe { shift->__subscription_cmd('p', 1, punsubscribe => @_) }
  
  sub __process_unsubscribe_requests {
    my ($self, $cb, $pr, @unsubs) = @_;
    my $subs = $self->{subscribers};
  
    my @subs_to_unsubscribe;
    for my $sub (@unsubs) {
      my $key = "${pr}message:$sub";
      my $cbs = $subs->{$key} = [grep { $_ ne $cb } @{ $subs->{$key} }];
      next if @$cbs;
  
      delete $subs->{$key};
      push @subs_to_unsubscribe, $sub;
    }
  
    return @subs_to_unsubscribe;
  }
  
  sub __process_subscription_changes {
    my ($self, $cmd, $expected) = @_;
    my $subs = $self->{subscribers};
  
    while (%$expected) {
      my ($m, $error) = $self->__read_response($cmd);
      confess "[$cmd] $error, " if defined $error;
  
      ## Deal with pending PUBLISH'ed messages
      if ($m->[0] =~ /^p?message$/) {
        $self->__process_pubsub_msg($m);
        next;
      }
  
      my ($key, $unsub) = $m->[0] =~ m/^(p)?(un)?subscribe$/;
      $key .= "message:$m->[1]";
      my $cb = delete $expected->{$key};
  
      push @{ $subs->{$key} }, $cb unless $unsub;
  
      $self->{is_subscriber} = $m->[2];
    }
  }
  
  sub __process_pubsub_msg {
    my ($self, $m) = @_;
    my $subs = $self->{subscribers};
  
    my $sub   = $m->[1];
    my $cbid  = "$m->[0]:$sub";
    my $data  = pop @$m;
    my $topic = $m->[2] || $sub;
  
    if (!exists $subs->{$cbid}) {
      warn "Message for topic '$topic' ($cbid) without expected callback, ";
      return;
    }
  
    $_->($data, $topic, $sub) for @{ $subs->{$cbid} };
  
    return 1;
  
  }
  
  
  ### Mode validation
  sub __is_valid_command {
    my ($self, $cmd) = @_;
  
    confess("Cannot use command '$cmd' while in SUBSCRIBE mode, ")
      if $self->{is_subscriber};
  }
  
  
  ### Socket operations
  sub __connect {
    my ($self) = @_;
    delete $self->{sock};
  
    # Suppose we have at least one command response pending, but we're about
    # to reconnect.  The new connection will never get a response to any of
    # the pending commands, so delete all those pending responses now.
    $self->{queue} = [];
  
    ## Fast path, no reconnect
    return $self->__build_sock() unless $self->{reconnect};
  
    ## Use precise timers on reconnections
    require Time::HiRes;
    my $t0 = [Time::HiRes::gettimeofday()];
  
    ## Reconnect...
    while (1) {
      eval { $self->__build_sock };
  
      last unless $@;    ## Connected!
      die if Time::HiRes::tv_interval($t0) > $self->{reconnect};    ## Timeout
      Time::HiRes::usleep($self->{every});                          ## Retry in...
    }
  
    return;
  }
  
  sub __build_sock {
    my ($self) = @_;
  
    $self->{sock} = $self->{builder}->($self)
      || confess("Could not connect to Redis server at $self->{server}: $!");
  
    if (exists $self->{password}) {
      try { $self->auth($self->{password}) }
      catch {
        $self->{reconnect} = 0;
        confess("Redis server refused password");
      };
    }
  
    $self->{on_connect}->($self) if exists $self->{on_connect};
  
    return;
  }
  
  sub __send_command {
    my $self = shift;
    my $cmd  = uc(shift);
    my $enc  = $self->{encoding};
    my $deb  = $self->{debug};
  
    my $sock = $self->{sock}
      || $self->__throw_reconnect('Not connected to any server');
  
    warn "[SEND] $cmd ", Dumper([@_]) if $deb;
  
    ## Encode command using multi-bulk format
    my @cmd     = split /_/, $cmd;
    my $n_elems = scalar(@_) + scalar(@cmd);
    my $buf     = "\*$n_elems\r\n";
    for my $elem (@cmd, @_) {
      my $bin = $enc ? encode($enc, $elem) : $elem;
      $buf .= defined($bin) ? '$' . length($bin) . "\r\n$bin\r\n" : "\$-1\r\n";
    }
  
    ## Check to see if socket was closed: reconnect on EOF
    my $status = __try_read_sock($sock);
    $self->__throw_reconnect('Not connected to any server')
      unless defined $status;
  
    ## Send command, take care for partial writes
    warn "[SEND RAW] $buf" if $deb;
    while ($buf) {
      my $len = syswrite $sock, $buf, length $buf;
      $self->__throw_reconnect("Could not write to Redis server: $!")
        unless defined $len;
      substr $buf, 0, $len, "";
    }
  
    return;
  }
  
  sub __read_response {
    my ($self, $cmd, $collect_errors) = @_;
  
    confess("Not connected to any server") unless $self->{sock};
  
    local $/ = "\r\n";
  
    ## no debug => fast path
    return $self->__read_response_r($cmd, $collect_errors) unless $self->{debug};
  
    my ($result, $error) = $self->__read_response_r($cmd, $collect_errors);
    warn "[RECV] $cmd ", Dumper($result, $error) if $self->{debug};
    return $result, $error;
  }
  
  sub __read_response_r {
    my ($self, $command, $collect_errors) = @_;
  
    my ($type, $result) = $self->__read_line;
  
    if ($type eq '-') {
      return undef, $result;
    }
    elsif ($type eq '+' || $type eq ':') {
      return $result, undef;
    }
    elsif ($type eq '$') {
      return undef, undef if $result < 0;
      return $self->__read_len($result + 2), undef;
    }
    elsif ($type eq '*') {
      return undef, undef if $result < 0;
  
      my @list;
      while ($result--) {
        my @nested = $self->__read_response_r($command, $collect_errors);
        if ($collect_errors) {
          push @list, \@nested;
        }
        else {
          confess "[$command] $nested[1], " if defined $nested[1];
          push @list, $nested[0];
        }
      }
      return \@list, undef;
    }
    else {
      confess "unknown answer type: $type ($result), ";
    }
  }
  
  sub __read_line {
    my $self = $_[0];
    my $sock = $self->{sock};
  
    my $data = <$sock>;
    confess("Error while reading from Redis server: $!")
      unless defined $data;
  
    chomp $data;
    warn "[RECV RAW] '$data'" if $self->{debug};
  
    my $type = substr($data, 0, 1, '');
    return ($type, $data) unless $self->{encoding};
    return ($type, decode($self->{encoding}, $data));
  }
  
  sub __read_len {
    my ($self, $len) = @_;
  
    my $data   = '';
    my $offset = 0;
    while ($len) {
      my $bytes = read $self->{sock}, $data, $len, $offset;
      confess("Error while reading from Redis server: $!")
        unless defined $bytes;
      confess("Redis server closed connection") unless $bytes;
  
      $offset += $bytes;
      $len -= $bytes;
    }
  
    chomp $data;
    warn "[RECV RAW] '$data'" if $self->{debug};
  
    return $data unless $self->{encoding};
    return decode($self->{encoding}, $data);
  }
  
  
  #
  # The reason for this code:
  #
  # IO::Select and buffered reads like <$sock> and read() dont mix
  # For example, if I receive two MESSAGE messages (from Redis PubSub),
  # the first read for the first message will probably empty to socket
  # buffer and move the data to the perl IO buffer.
  #
  # This means that IO::Select->can_read will return false (after all
  # the socket buffer is empty) but from the application point of view
  # there is still data to be read and process
  #
  # Hence this code. We try to do a non-blocking read() of 1 byte, and if
  # we succeed, we put it back and signal "yes, Virginia, there is still
  # stuff out there"
  #
  # We could just use sysread and leave the socket buffer with the second
  # message, and then use IO::Select as intended, and previous versions of
  # this code did that (check the git history for this file), but
  # performance suffers, about 20/30% slower, mostly because we do a lot
  # of "read one line", where <$sock> beats the crap of anything you can
  # write on Perl-land.
  #
  sub __try_read_sock {
    my $sock = shift;
    my $data = '';
  
    __fh_nonblocking($sock, 1);
  
    ## Lots of problems with Windows here. This is a temporary fix until I
    ## figure out what is happening there. It looks like the wrong fix
    ## because we should not mix sysread (unbuffered I/O) with ungetc()
    ## below (buffered I/O), so I do expect to revert this soon.
    ## Call it a run through the CPAN Testers Gautlet fix. If I had to
    ## guess (and until my Windows box has a new power supply I do have to
    ## guess), I would say that the problems lies with the call
    ## __fh_nonblocking(), where on Windows we don't end up with a non-
    ## blocking socket.
    ## See
    ##  * https://github.com/melo/perl-redis/issues/20
    ##  * https://github.com/melo/perl-redis/pull/21
    my $len;
    if (WIN32) {
      $len = sysread($sock, $data, 1);
    }
    else {
      $len = read($sock, $data, 1);
    }
    my $err = 0 + $!;
    __fh_nonblocking($sock, 0);
  
    if (defined($len)) {
      ## Have stuff
      if ($len > 0) {
        $sock->ungetc(ord($data));
        return 1;
      }
      ## EOF according to the docs
      elsif ($len == 0) {
        return;
      }
      else {
        confess("read()/sysread() are really bonkers on $^O, return negative values ($len)");
      }
    }
  
    ## Keep going if nothing there, but socket is alive
    return 0 if $err and ($err == EWOULDBLOCK or $err == EAGAIN or $err == EINTR);
  
    ## No errno, but result is undef?? This happens sometimes on my tests
    ## when the server timesout the client. I traced the system calls and
    ## I see the read() system call return 0 for EOF, but on this side of
    ## perl, we get undef... We should see the 0 return code for EOF, I
    ## suspect the fact that we are in non-blocking mode is the culprit
    return if $err == 0;
  
    ## For everything else, there is Mastercard...
    confess("Unexpected error condition $err/$^O, please report this as a bug");
  }
  
  
  ### Copied from AnyEvent::Util
  BEGIN {
    *__fh_nonblocking = (WIN32)
      ? sub($$) { ioctl $_[0], 0x8004667e, pack "L", $_[1]; }    # FIONBIO
      : sub($$) { fcntl $_[0], F_SETFL, $_[1] ? O_NONBLOCK : 0; };
  }
  
  
  ##########################
  # I take exception to that
  
  sub __throw_reconnect {
    my ($self, $m) = @_;
    die bless(\$m, 'Redis::X::Reconnect') if $self->{reconnect};
    die $m;
  }
  
  
  1;    # End of Redis.pm
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for :stopwords Pedro Melo ACKNOWLEDGEMENTS cpan testmatrix url annocpan anno bugtracker rt
  cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 NAME
  
  Redis - Perl binding for Redis database
  
  =head1 VERSION
  
  version 1.961
  
  =head1 SYNOPSIS
  
      ## Defaults to $ENV{REDIS_SERVER} or 127.0.0.1:6379
      my $redis = Redis->new;
  
      my $redis = Redis->new(server => 'redis.example.com:8080');
  
      ## Set the connection name (requires Redis 2.6.9)
      my $redis = Redis->new(server => 'redis.example.com:8080', name => 'my_connection_name');
  
      ## Use UNIX domain socket
      my $redis = Redis->new(sock => '/path/to/socket');
  
      ## Enable auto-reconnect
      ## Try to reconnect every 500ms up to 60 seconds until success
      ## Die if you can't after that
      my $redis = Redis->new(reconnect => 60);
  
      ## Try each 100ms upto 2 seconds (every is in milisecs)
      my $redis = Redis->new(reconnect => 2, every => 100);
  
      ## Disable the automatic utf8 encoding => much more performance
      ## !!!! This will be the default after 2.000, see ENCODING below
      my $redis = Redis->new(encoding => undef);
  
      ## Use all the regular Redis commands, they all accept a list of
      ## arguments
      ## See http://redis.io/commands for full list
      $redis->get('key');
      $redis->set('key' => 'value');
      $redis->sort('list', 'DESC');
      $redis->sort(qw{list LIMIT 0 5 ALPHA DESC});
  
      ## Add a coderef argument to run a command in the background
      $redis->sort(qw{list LIMIT 0 5 ALPHA DESC}, sub {
        my ($reply, $error) = @_;
        die "Oops, got an error: $error\n" if defined $error;
        print "$_\n" for @$reply;
      });
      long_computation();
      $redis->wait_all_responses;
      ## or
      $redis->wait_one_response();
  
      ## Or run a large batch of commands in a pipeline
      my %hash = _get_large_batch_of_commands();
      $redis->hset('h', $_, $hash{$_}, sub {}) for keys %hash;
      $redis->wait_all_responses;
  
      ## Publish/Subscribe
      $redis->subscribe(
        'topic_1',
        'topic_2',
        sub {
          my ($message, $topic, $subscribed_topic) = @_
  
            ## $subscribed_topic can be different from topic if
            ## you use psubscribe() with wildcards
        }
      );
      $redis->psubscribe('nasdaq.*', sub {...});
  
      ## Blocks and waits for messages, calls subscribe() callbacks
      ##  ... forever
      my $timeout = 10;
      $redis->wait_for_messages($timeout) while 1;
  
      ##  ... until some condition
      my $keep_going = 1; ## other code will set to false to quit
      $redis->wait_for_messages($timeout) while $keep_going;
  
      $redis->publish('topic_1', 'message');
  
  =head1 DESCRIPTION
  
  Pure perl bindings for L<http://redis.io/>
  
  This version supports protocol 2.x (multi-bulk) or later of Redis available at
  L<https://github.com/antirez/redis/>.
  
  This documentation lists commands which are exercised in test suite, but
  additional commands will work correctly since protocol specifies enough
  information to support almost all commands with same piece of code with a
  little help of C<AUTOLOAD>.
  
  =head1 PIPELINING
  
  Usually, running a command will wait for a response.  However, if you're doing
  large numbers of requests, it can be more efficient to use what Redis calls
  I<pipelining>: send multiple commands to Redis without waiting for a response,
  then wait for the responses that come in.
  
  To use pipelining, add a coderef argument as the last argument to a command
  method call:
  
    $r->set('foo', 'bar', sub {});
  
  Pending responses to pipelined commands are processed in a single batch, as
  soon as at least one of the following conditions holds:
  
  =over 4
  
  =item *
  
  A non-pipelined (synchronous) command is called on the same connection
  
  =item *
  
  A pub/sub subscription command (one of C<subscribe>, C<unsubscribe>,
  C<psubscribe>, or C<punsubscribe>) is about to be called on the same
  connection.
  
  =item *
  
  One of L</wait_all_responses> or L</wait_one_response> methods is called
  explicitly.
  
  =back
  
  The coderef you supply to a pipelined command method is invoked once the
  response is available.  It takes two arguments, C<$reply> and C<$error>.  If
  C<$error> is defined, it contains the text of an error reply sent by the Redis
  server.  Otherwise, C<$reply> is the non-error reply. For almost all commands,
  that means it's C<undef>, or a defined but non-reference scalar, or an array
  ref of any of those; but see L</keys>, L</info>, and L</exec>.
  
  Note the contrast with synchronous commands, which throw an exception on
  receipt of an error reply, or return a non-error reply directly.
  
  The fact that pipelined commands never throw an exception can be particularly
  useful for Redis transactions; see L</exec>.
  
  =head1 ENCODING
  
  B<This feature is deprecated and will be removed before 2.000>. You should
  start testing your code with C<< encoding => undef >> because that will be the
  new default with 2.000.
  
  Since Redis knows nothing about encoding, we are forcing utf-8 flag on all data
  received from Redis. This change was introduced in 1.2001 version. B<Please
  note> that this encoding option severely degrades performance.
  
  You can disable this automatic encoding by passing an option to L</new>: C<<
  encoding => undef >>.
  
  This allows us to round-trip utf-8 encoded characters correctly, but might be
  problem if you push binary junk into Redis and expect to get it back without
  utf-8 flag turned on.
  
  =head1 METHODS
  
  =head2 Constructors
  
  =head3 new
  
      my $r = Redis->new; # $ENV{REDIS_SERVER} or 127.0.0.1:6379
  
      my $r = Redis->new( server => '192.168.0.1:6379', debug => 0 );
      my $r = Redis->new( server => '192.168.0.1:6379', encoding => undef );
      my $r = Redis->new( sock => '/path/to/sock' );
      my $r = Redis->new( reconnect => 60, every => 5000 );
      my $r = Redis->new( password => 'boo' );
      my $r = Redis->new( on_connect => sub { my ($redis) = @_; ... } );
      my $r = Redis->new( name => 'my_connection_name' ); ## Redis 2.6.9 required
  
  The C<< server >> parameter specifies the Redis server we should connect to,
  via TCP. Use the 'IP:PORT' format. If no C<< server >> option is present, we
  will attempt to use the C<< REDIS_SERVER >> environment variable. If neither of
  those options are present, it defaults to '127.0.0.1:6379'.
  
  Alternatively you can use the C<< sock >> parameter to specify the path of the
  UNIX domain socket where the Redis server is listening.
  
  The C<< REDIS_SERVER >> can be used for UNIX domain sockets too. The following
  formats are supported:
  
  =over 4
  
  =item *
  
  /path/to/sock
  
  =item *
  
  unix:/path/to/sock
  
  =item *
  
  127.0.0.1:11011
  
  =item *
  
  tcp:127.0.0.1:11011
  
  =back
  
  The C<< encoding >> parameter speficies the encoding we will use to decode all
  the data we receive and encode all the data sent to the redis server. Due to
  backwards-compatibility we default to C<< utf8 >>. To disable all this
  encoding/decoding, you must use C<< encoding => undef >>. B<< This is the
  recommended option >>.
  
  B<< Warning >>: this option has several problems and it is B<deprecated>. A
  future version might add other filtering options though.
  
  The C<< reconnect >> option enables auto-reconnection mode. If we cannot
  connect to the Redis server, or if a network write fails, we enter retry mode.
  We will try a new connection every C<< every >> miliseconds (1000ms by
  default), up-to C<< reconnect >> seconds.
  
  Be aware that read errors will always thrown an exception, and will not trigger
  a retry until the new command is sent.
  
  If we cannot re-establish a connection after C<< reconnect >> seconds, an
  exception will be thrown.
  
  If your Redis server requires authentication, you can use the C<< password >>
  attribute. After each established connection (at the start or when
  reconnecting), the Redis C<< AUTH >> command will be send to the server. If the
  password is wrong, an exception will be thrown and reconnect will be disabled.
  
  You can also provide a code reference that will be immediatly after each
  sucessfull connection. The C<< on_connect >> attribute is used to provide the
  code reference, and it will be called with the first parameter being the Redis
  object.
  
  You can also set a name for each connection. This can be very useful for
  debugging purposes, using the C<< CLIENT LIST >> command. To set a connection
  name, use the C<< name >> parameter. Please note that there are restrictions on
  the name you can set, the most important of which is, no spaces. See the
  L<CLIENT SETNAME documentation|http://redis.io/commands/client-setname> for all
  the juicy details. This feature is safe to use with all versions of Redis
  servers. If C<< CLIENT SETNAME >> support is not available (Redis servers 2.6.9
  and above only), the name parameter is ignored.
  
  The C<< debug >> parameter enables debug information to STDERR, including all
  interactions with the server. You can also enable debug with the C<REDIS_DEBUG>
  environment variable.
  
  =head2 Connection Handling
  
  =head3 quit
  
    $r->quit;
  
  Closes the connection to the server. The C<quit> method does not support
  pipelined operation.
  
  =head3 ping
  
    $r->ping || die "no server?";
  
  The C<ping> method does not support pipelined operation.
  
  =head3 client_list
  
    @clients = $r->client_list;
  
  Returns list of clients connected to the server. See L<< CLIENT LIST
  documentation|http://redis.io/commands/client-list >> for a description of the
  fields and their meaning.
  
  =head3 client_getname
  
    my $connection_name = $r->client_getname;
  
  Returns the name associated with this connection. See L</client_setname> or the
  C<< name >> parameter to L</new> for ways to set this name.
  
  =head3 client_setname
  
    $r->client_setname('my_connection_name');
  
  Sets this connection name. See the L<CLIENT SETNAME
  documentation|http://redis.io/commands/client-setname> for restrictions on the
  connection name string. The most important one: no spaces.
  
  =head2 Pipeline management
  
  =head3 wait_all_responses
  
  Waits until all pending pipelined responses have been received, and invokes the
  pipeline callback for each one.  See L</PIPELINING>.
  
  =head3 wait_one_response
  
  Waits until the first pending pipelined response has been received, and invokes
  its callback.  See L</PIPELINING>.
  
  =head2 Transaction-handling commands
  
  B<Warning:> the behaviour of these commands when combined with pipelining is
  still under discussion, and you should B<NOT> use them at the same time just
  now.
  
  You can L<follow the discussion to see the open issues with
  this|https://github.com/melo/perl-redis/issues/17>.
  
  =head3 multi
  
    $r->multi;
  
  =head3 discard
  
    $r->discard;
  
  =head3 exec
  
    my @individual_replies = $r->exec;
  
  C<exec> has special behaviour when run in a pipeline: the C<$reply> argument to
  the pipeline callback is an array ref whose elements are themselves C<[$reply,
  $error]> pairs.  This means that you can accurately detect errors yielded by
  any command in the transaction, and without any exceptions being thrown.
  
  =head2 Commands operating on string values
  
  =head3 set
  
    $r->set( foo => 'bar' );
  
    $r->setnx( foo => 42 );
  
  =head3 get
  
    my $value = $r->get( 'foo' );
  
  =head3 mget
  
    my @values = $r->mget( 'foo', 'bar', 'baz' );
  
  =head3 incr
  
    $r->incr('counter');
  
    $r->incrby('tripplets', 3);
  
  =head3 decr
  
    $r->decr('counter');
  
    $r->decrby('tripplets', 3);
  
  =head3 exists
  
    $r->exists( 'key' ) && print "got key!";
  
  =head3 del
  
    $r->del( 'key' ) || warn "key doesn't exist";
  
  =head3 type
  
    $r->type( 'key' ); # = string
  
  =head2 Commands operating on the key space
  
  =head3 keys
  
    my @keys = $r->keys( '*glob_pattern*' );
    my $keys = $r->keys( '*glob_pattern*' ); # count of matching keys
  
  Note that synchronous C<keys> calls in a scalar context return the number of
  matching keys (not an array ref of matching keys as you might expect).  This
  does not apply in pipelined mode: assuming the server returns a list of keys,
  as expected, it is always passed to the pipeline callback as an array ref.
  
  =head3 randomkey
  
    my $key = $r->randomkey;
  
  =head3 rename
  
    my $ok = $r->rename( 'old-key', 'new-key', $new );
  
  =head3 dbsize
  
    my $nr_keys = $r->dbsize;
  
  =head2 Commands operating on lists
  
  See also L<Redis::List> for tie interface.
  
  =head3 rpush
  
    $r->rpush( $key, $value );
  
  =head3 lpush
  
    $r->lpush( $key, $value );
  
  =head3 llen
  
    $r->llen( $key );
  
  =head3 lrange
  
    my @list = $r->lrange( $key, $start, $end );
  
  =head3 ltrim
  
    my $ok = $r->ltrim( $key, $start, $end );
  
  =head3 lindex
  
    $r->lindex( $key, $index );
  
  =head3 lset
  
    $r->lset( $key, $index, $value );
  
  =head3 lrem
  
    my $modified_count = $r->lrem( $key, $count, $value );
  
  =head3 lpop
  
    my $value = $r->lpop( $key );
  
  =head3 rpop
  
    my $value = $r->rpop( $key );
  
  =head2 Commands operating on sets
  
  =head3 sadd
  
    my $ok = $r->sadd( $key, $member );
  
  =head3 scard
  
    my $n_elements = $r->scard( $key );
  
  =head3 sdiff
  
    my @elements = $r->sdiff( $key1, $key2, ... );
    my $elements = $r->sdiff( $key1, $key2, ... ); # ARRAY ref
  
  =head3 sdiffstore
  
    my $ok = $r->sdiffstore( $dstkey, $key1, $key2, ... );
  
  =head3 sinter
  
    my @elements = $r->sinter( $key1, $key2, ... );
    my $elements = $r->sinter( $key1, $key2, ... ); # ARRAY ref
  
  =head3 sinterstore
  
    my $ok = $r->sinterstore( $dstkey, $key1, $key2, ... );
  
  =head3 sismember
  
    my $bool = $r->sismember( $key, $member );
  
  =head3 smembers
  
    my @elements = $r->smembers( $key );
    my $elements = $r->smembers( $key ); # ARRAY ref
  
  =head3 smove
  
    my $ok = $r->smove( $srckey, $dstkey, $element );
  
  =head3 spop
  
    my $element = $r->spop( $key );
  
  =head3 spop
  
    my $element = $r->srandmember( $key );
  
  =head3 srem
  
    $r->srem( $key, $member );
  
  =head3 sunion
  
    my @elements = $r->sunion( $key1, $key2, ... );
    my $elements = $r->sunion( $key1, $key2, ... ); # ARRAY ref
  
  =head3 sunionstore
  
    my $ok = $r->sunionstore( $dstkey, $key1, $key2, ... );
  
  =head2 Sorting
  
  =head3 sort
  
    $r->sort("key BY pattern LIMIT start end GET pattern ASC|DESC ALPHA');
  
  =head2 Publish/Subscribe commands
  
  When one of L</subscribe> or L</psubscribe> is used, the Redis object will
  enter I<PubSub> mode. When in I<PubSub> mode only commands in this section,
  plus L</quit>, will be accepted.
  
  If you plan on using PubSub and other Redis functions, you should use two Redis
  objects, one dedicated to PubSub and the other for regular commands.
  
  All Pub/Sub commands receive a callback as the last parameter. This callback
  receives three arguments:
  
  =over 4
  
  =item *
  
  The published message.
  
  =item *
  
  The topic over which the message was sent.
  
  =item *
  
  The subscribed topic that matched the topic for the message. With L</subscribe>
  these last two are the same, always. But with L</psubscribe>, this parameter
  tells you the pattern that matched.
  
  =back
  
  See the L<Pub/Sub notes|http://redis.io/topics/pubsub> for more information
  about the messages you will receive on your callbacks after each L</subscribe>,
  L</unsubscribe>, L</psubscribe> and L</punsubscribe>.
  
  =head3 publish
  
    $r->publish($topic, $message);
  
  Publishes the C<< $message >> to the C<< $topic >>.
  
  =head3 subscribe
  
    $r->subscribe(
        @topics_to_subscribe_to,
        sub {
          my ($message, $topic, $subscribed_topic) = @_;
          ...
        },
    );
  
  Subscribe one or more topics. Messages published into one of them will be
  received by Redis, and the specificed callback will be executed.
  
  =head3 unsubscribe
  
    $r->unsubscribe(@topic_list, sub { my ($m, $t, $s) = @_; ... });
  
  Stops receiving messages for all the topics in C<@topic_list>.
  
  =head3 psubscribe
  
    my @topic_matches = ('prefix1.*', 'prefix2.*');
    $r->psubscribe(@topic_matches, sub { my ($m, $t, $s) = @_; ... });
  
  Subscribes a pattern of topics. All messages to topics that match the pattern
  will be delivered to the callback.
  
  =head3 punsubscribe
  
    my @topic_matches = ('prefix1.*', 'prefix2.*');
    $r->punsubscribe(@topic_matches, sub { my ($m, $t, $s) = @_; ... });
  
  Stops receiving messages for all the topics pattern matches in C<@topic_list>.
  
  =head3 is_subscriber
  
    if ($r->is_subscriber) { say "We are in Pub/Sub mode!" }
  
  Returns true if we are in I<Pub/Sub> mode.
  
  =head3 wait_for_messages
  
    my $keep_going = 1; ## Set to false somewhere to leave the loop
    my $timeout = 5;
    $r->wait_for_messages($timeout) while $keep_going;
  
  Blocks, waits for incoming messages and delivers them to the appropriate
  callbacks.
  
  Requires a single parameter, the number of seconds to wait for messages. Use 0
  to wait for ever. If a positive non-zero value is used, it will return after
  that ammount of seconds without a single notification.
  
  Please note that the timeout is not a commitement to return control to the
  caller at most each C<timeout> seconds, but more a idle timeout, were control
  will return to the caller if Redis is idle (as in no messages were received
  during the timeout period) for more than C<timeout> seconds.
  
  The L</wait_for_messages> call returns the number of messages processed during
  the run.
  
  =head2 Persistence control commands
  
  =head3 save
  
    $r->save;
  
  =head3 bgsave
  
    $r->bgsave;
  
  =head3 lastsave
  
    $r->lastsave;
  
  =head2 Scripting commands
  
  =head3 eval
  
    $r->eval($lua_script, $num_keys, $key1, ..., $arg1, $arg2);
  
  Executes a Lua script server side.
  
  Note that this commands sends the Lua script every time you call it. See
  L</evalsha> and L</script_load> for an alternative.
  
  =head3 evalsha
  
    $r->eval($lua_script_sha1, $num_keys, $key1, ..., $arg1, $arg2);
  
  Executes a Lua script cached on the server side by its SHA1 digest.
  
  See L</script_load>.
  
  =head3 script_load
  
    my ($sha1) = $r->script_load($lua_script);
  
  Cache Lua script, returns SHA1 digest that can be used with L</evalsha>.
  
  =head3 script_exists
  
    my ($exists1, $exists2, ...) = $r->script_exists($scrip1_sha, $script2_sha, ...);
  
  Given a list of SHA1 digests, returns a list of booleans, one for each SHA1,
  that report the existence of each script in the server cache.
  
  =head3 script_kill
  
    $r->script_kill;
  
  Kills the currently running script.
  
  =head3 script_flush
  
    $r->script_flush;
  
  Flush the Lua scripts cache.
  
  =head2 Remote server control commands
  
  =head3 info
  
    my $info_hash = $r->info;
  
  The C<info> method is unique in that it decodes the server's response into a
  hashref, if possible. This decoding happens in both synchronous and pipelined
  modes.
  
  =head3 shutdown
  
    $r->shutdown;
  
  The C<shutdown> method does not support pipelined operation.
  
  =head2 Multiple databases handling commands
  
  =head3 select
  
    $r->select( $dbindex ); # 0 for new clients
  
  =head3 move
  
    $r->move( $key, $dbindex );
  
  =head3 flushdb
  
    $r->flushdb;
  
  =head3 flushall
  
    $r->flushall;
  
  =head1 SUPPORT
  
  =head2 Perldoc
  
  You can find documentation for this module with the perldoc command.
  
    perldoc Redis
  
  =head2 Websites
  
  The following websites have more information about this module, and may be of help to you. As always,
  in addition to those websites please use your favorite search engine to discover more resources.
  
  =over 4
  
  =item *
  
  MetaCPAN
  
  A modern, open-source CPAN search engine, useful to view POD in HTML format.
  
  L<http://metacpan.org/release/Redis>
  
  =item *
  
  CPAN Testers
  
  The CPAN Testers is a network of smokers who run automated tests on uploaded CPAN distributions.
  
  L<http://www.cpantesters.org/distro/R/Redis>
  
  =item *
  
  CPAN Testers Matrix
  
  The CPAN Testers Matrix is a website that provides a visual overview of the test results for a distribution on various Perls/platforms.
  
  L<http://matrix.cpantesters.org/?dist=Redis>
  
  =item *
  
  CPAN Testers Dependencies
  
  The CPAN Testers Dependencies is a website that shows a chart of the test results of all dependencies for a distribution.
  
  L<http://deps.cpantesters.org/?module=Redis>
  
  =item *
  
  CPAN Ratings
  
  The CPAN Ratings is a website that allows community ratings and reviews of Perl modules.
  
  L<http://cpanratings.perl.org/d/Redis>
  
  =back
  
  =head2 Email
  
  You can email the author of this module at C<MELO at cpan.org> asking for help with any problems you have.
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the web interface at L<https://github.com/melo/perl-redis/issues>. You will be automatically notified of any progress on the request by the system.
  
  =head2 Source Code
  
  The code is open to the world, and available for you to hack on. Please feel free to browse it and play
  with it, or whatever. If you want to contribute patches, please send me a diff or prod me to pull
  from your repository :)
  
  L<https://github.com/melo/perl-redis>
  
    git clone git://github.com/melo/perl-redis.git
  
  =head1 ACKNOWLEDGEMENTS
  
  The following persons contributed to this project (alphabetical order):
  
  =over 4
  
  =item *
  
  Aaron Crane (pipelining and AUTOLOAD caching support)
  
  =item *
  
  Dirk Vleugels
  
  =item *
  
  Flavio Poletti
  
  =item *
  
  Jeremy Zawodny
  
  =item *
  
  sunnavy at bestpractical.com
  
  =item *
  
  Thiago Berlitz Rondon
  
  =item *
  
  Ulrich Habel
  
  =back
  
  =head1 AUTHOR
  
  Pedro Melo <melo@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 by Pedro Melo.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
REDIS

$fatpacked{"Redis/Hash.pm"} = <<'REDIS_HASH';
  package Redis::Hash;
  
  # ABSTRACT: tie Perl hashes to Redis hashes
  our $VERSION = '1.961'; # VERSION
  our $AUTHORITY = 'cpan:MELO'; # AUTHORITY
  
  use strict;
  use warnings;
  use Tie::Hash;
  use base qw/Redis Tie::StdHash/;
  
  
  sub TIEHASH {
    my ($class, $prefix, @rest) = @_;
    my $self = $class->new(@rest);
  
    $self->{prefix} = $prefix ? "$prefix:" : '';
  
    return $self;
  }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    $self->set($self->{prefix} . $key, $value);
  }
  
  sub FETCH {
    my ($self, $key) = @_;
    $self->get($self->{prefix} . $key);
  }
  
  sub FIRSTKEY {
    my $self = shift;
    $self->{prefix_keys} = [$self->keys($self->{prefix} . '*')];
    $self->NEXTKEY;
  }
  
  sub NEXTKEY {
    my $self = shift;
  
    my $key = shift @{ $self->{prefix_keys} };
    return unless defined $key;
  
    my $p = $self->{prefix};
    $key =~ s/^$p// if $p;
    return $key;
  }
  
  sub EXISTS {
    my ($self, $key) = @_;
    $self->exists($self->{prefix} . $key);
  }
  
  sub DELETE {
    my ($self, $key) = @_;
    $self->del($self->{prefix} . $key);
  }
  
  sub CLEAR {
    my ($self) = @_;
    $self->del($_) for $self->keys($self->{prefix} . '*');
    $self->{prefix_keys} = [];
  }
  
  
  1;    ## End of Redis::Hash
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for :stopwords Pedro Melo ACKNOWLEDGEMENTS
  
  =head1 NAME
  
  Redis::Hash - tie Perl hashes to Redis hashes
  
  =head1 VERSION
  
  version 1.961
  
  =head1 DESCRIPTION
  
  Ties a Perl hash to Redis. Note that it doesn't use Redis Hashes, but
  implements a fake hash using regular keys like "prefix:KEY".
  
  If no C<prefix> is given, it will tie the entire Redis database as a hash.
  
  Future versions will also allow you to use real Redis hash structures.
  
  =head1 SYNOPSYS
  
      ## Create fake hash using keys like 'hash_prefix:KEY'
      tie %my_hash, 'Redis::Hash', 'hash_prefix', @Redis_new_parameters;
  
      ## Treat the entire Redis database as a hash
      tie %my_hash, 'Redis::Hash', undef, @Redis_new_parameters;
  
      $value = $my_hash{$key};
      $my_hash{$key} = $value;
  
      @keys   = keys %my_hash;
      @values = values %my_hash;
  
      %my_hash = reverse %my_hash;
  
      %my_hash = ();
  
  =head1 AUTHOR
  
  Pedro Melo <melo@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 by Pedro Melo.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
REDIS_HASH

$fatpacked{"Redis/List.pm"} = <<'REDIS_LIST';
  package Redis::List;
  
  # ABSTRACT: tie Perl arrays to Redis lists
  our $VERSION = '1.961'; # VERSION
  our $AUTHORITY = 'cpan:MELO'; # AUTHORITY
  
  use strict;
  use warnings;
  use base qw/Redis Tie::Array/;
  
  
  sub TIEARRAY {
    my ($class, $list, @rest) = @_;
    my $self = $class->new(@rest);
  
    $self->{list} = $list;
  
    return $self;
  }
  
  sub FETCH {
    my ($self, $index) = @_;
    $self->lindex($self->{list}, $index);
  }
  
  sub FETCHSIZE {
    my ($self) = @_;
    $self->llen($self->{list});
  }
  
  sub STORE {
    my ($self, $index, $value) = @_;
    $self->lset($self->{list}, $index, $value);
  }
  
  sub STORESIZE {
    my ($self, $count) = @_;
    $self->ltrim($self->{list}, 0, $count);
  
  #		if $count > $self->FETCHSIZE;
  }
  
  sub CLEAR {
    my ($self) = @_;
    $self->del($self->{list});
  }
  
  sub PUSH {
    my $self = shift;
    my $list = $self->{list};
  
    $self->rpush($list, $_) for @_;
  }
  
  sub POP {
    my $self = shift;
    $self->rpop($self->{list});
  }
  
  sub SHIFT {
    my ($self) = @_;
    $self->lpop($self->{list});
  }
  
  sub UNSHIFT {
    my $self = shift;
    my $list = $self->{list};
  
    $self->lpush($list, $_) for @_;
  }
  
  sub SPLICE {
    my ($self, $offset, $length) = @_;
    $self->lrange($self->{list}, $offset, $length);
  
    # FIXME rest of @_ ?
  }
  
  sub EXTEND {
    my ($self, $count) = @_;
    $self->rpush($self->{list}, '') for ($self->FETCHSIZE .. ($count - 1));
  }
  
  sub DESTROY { $_[0]->quit }
  
  1;    ## End of Redis::List
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for :stopwords Pedro Melo ACKNOWLEDGEMENTS
  
  =head1 NAME
  
  Redis::List - tie Perl arrays to Redis lists
  
  =head1 VERSION
  
  version 1.961
  
  =head1 SYNOPSYS
  
      tie @my_list, 'Redis::List', 'list_name', @Redis_new_parameters;
  
      $value = $my_list[$index];
      $my_list[$index] = $value;
  
      $count = @my_list;
  
      push @my_list, 'values';
      $value = pop @my_list;
      unshift @my_list, 'values';
      $value = shift @my_list;
  
      ## NOTE: fourth parameter of splice is *NOT* supported for now
      @other_list = splice(@my_list, 2, 3);
  
      @my_list = ();
  
  =head1 AUTHOR
  
  Pedro Melo <melo@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 by Pedro Melo.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
REDIS_LIST

$fatpacked{"Term/ANSIColor.pm"} = <<'TERM_ANSICOLOR';
  # Term::ANSIColor -- Color screen output using ANSI escape sequences.
  #
  # Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010,
  #     2011, 2012, 2013 Russ Allbery <rra@stanford.edu>
  # Copyright 1996 Zenin
  # Copyright 2012 Kurt Starsinic <kstarsinic@gmail.com>
  #
  # This program is free software; you may redistribute it and/or modify it
  # under the same terms as Perl itself.
  #
  # PUSH/POP support submitted 2007 by openmethods.com voice solutions
  #
  # Ah, September, when the sysadmins turn colors and fall off the trees....
  #                               -- Dave Van Domelen
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Term::ANSIColor;
  
  use 5.006;
  use strict;
  use warnings;
  
  use Carp qw(croak);
  use Exporter ();
  
  # use Exporter plus @ISA instead of use base for 5.6 compatibility.
  ## no critic (ClassHierarchies::ProhibitExplicitISA)
  
  # Declare variables that should be set in BEGIN for robustness.
  ## no critic (Modules::ProhibitAutomaticExportation)
  our (@EXPORT, @EXPORT_OK, %EXPORT_TAGS, @ISA, $VERSION);
  
  # We use autoloading, which sets this variable to the name of the called sub.
  our $AUTOLOAD;
  
  # Set $VERSION and everything export-related in a BEGIN block for robustness
  # against circular module loading (not that we load any modules, but
  # consistency is good).
  BEGIN {
      $VERSION = '4.02';
  
      # All of the basic supported constants, used in %EXPORT_TAGS.
      my @colorlist = qw(
        CLEAR           RESET             BOLD            DARK
        FAINT           ITALIC            UNDERLINE       UNDERSCORE
        BLINK           REVERSE           CONCEALED
  
        BLACK           RED               GREEN           YELLOW
        BLUE            MAGENTA           CYAN            WHITE
        ON_BLACK        ON_RED            ON_GREEN        ON_YELLOW
        ON_BLUE         ON_MAGENTA        ON_CYAN         ON_WHITE
  
        BRIGHT_BLACK    BRIGHT_RED        BRIGHT_GREEN    BRIGHT_YELLOW
        BRIGHT_BLUE     BRIGHT_MAGENTA    BRIGHT_CYAN     BRIGHT_WHITE
        ON_BRIGHT_BLACK ON_BRIGHT_RED     ON_BRIGHT_GREEN ON_BRIGHT_YELLOW
        ON_BRIGHT_BLUE  ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN  ON_BRIGHT_WHITE
      );
  
      # 256-color constants, used in %EXPORT_TAGS.
      ## no critic (ValuesAndExpressions::ProhibitMagicNumbers)
      my @colorlist256 = (
          (map { ("ANSI$_", "ON_ANSI$_") } 0 .. 15),
          (map { ("GREY$_", "ON_GREY$_") } 0 .. 23),
      );
      for my $r (0 .. 5) {
          for my $g (0 .. 5) {
              push @colorlist256, map { ("RGB$r$g$_", "ON_RGB$r$g$_") } 0 .. 5;
          }
      }
  
      # Exported symbol configuration.
      @ISA         = qw(Exporter);
      @EXPORT      = qw(color colored);
      @EXPORT_OK   = qw(uncolor colorstrip colorvalid coloralias);
      %EXPORT_TAGS = (
          constants    => \@colorlist,
          constants256 => \@colorlist256,
          pushpop      => [@colorlist, qw(PUSHCOLOR POPCOLOR LOCALCOLOR)],
      );
      Exporter::export_ok_tags('pushpop', 'constants256');
  }
  
  ##############################################################################
  # Package variables
  ##############################################################################
  
  # If this is set, any color changes will implicitly push the current color
  # onto the stack and then pop it at the end of the constant sequence, just as
  # if LOCALCOLOR were used.
  our $AUTOLOCAL;
  
  # Caller sets this to force a reset at the end of each constant sequence.
  our $AUTORESET;
  
  # Caller sets this to force colors to be reset at the end of each line.
  our $EACHLINE;
  
  ##############################################################################
  # Internal data structures
  ##############################################################################
  
  # This module does quite a bit of initialization at the time it is first
  # loaded, primarily to set up the package-global %ATTRIBUTES hash.  The
  # entries for 256-color names are easier to handle programmatically, and
  # custom colors are also imported from the environment if any are set.
  
  # All basic supported attributes, including aliases.
  #<<<
  our %ATTRIBUTES = (
      'clear'          => 0,
      'reset'          => 0,
      'bold'           => 1,
      'dark'           => 2,
      'faint'          => 2,
      'italic'         => 3,
      'underline'      => 4,
      'underscore'     => 4,
      'blink'          => 5,
      'reverse'        => 7,
      'concealed'      => 8,
  
      'black'          => 30,   'on_black'          => 40,
      'red'            => 31,   'on_red'            => 41,
      'green'          => 32,   'on_green'          => 42,
      'yellow'         => 33,   'on_yellow'         => 43,
      'blue'           => 34,   'on_blue'           => 44,
      'magenta'        => 35,   'on_magenta'        => 45,
      'cyan'           => 36,   'on_cyan'           => 46,
      'white'          => 37,   'on_white'          => 47,
  
      'bright_black'   => 90,   'on_bright_black'   => 100,
      'bright_red'     => 91,   'on_bright_red'     => 101,
      'bright_green'   => 92,   'on_bright_green'   => 102,
      'bright_yellow'  => 93,   'on_bright_yellow'  => 103,
      'bright_blue'    => 94,   'on_bright_blue'    => 104,
      'bright_magenta' => 95,   'on_bright_magenta' => 105,
      'bright_cyan'    => 96,   'on_bright_cyan'    => 106,
      'bright_white'   => 97,   'on_bright_white'   => 107,
  );
  #>>>
  
  # Generating the 256-color codes involves a lot of codes and offsets that are
  # not helped by turning them into constants.
  ## no critic (ValuesAndExpressions::ProhibitMagicNumbers)
  
  # The first 16 256-color codes are duplicates of the 16 ANSI colors,
  # included for completeness.
  for my $code (0 .. 15) {
      $ATTRIBUTES{"ansi$code"}    = "38;5;$code";
      $ATTRIBUTES{"on_ansi$code"} = "48;5;$code";
  }
  
  # 256-color RGB colors.  Red, green, and blue can each be values 0 through 5,
  # and the resulting 216 colors start with color 16.
  for my $r (0 .. 5) {
      for my $g (0 .. 5) {
          for my $b (0 .. 5) {
              my $code = 16 + (6 * 6 * $r) + (6 * $g) + $b;
              $ATTRIBUTES{"rgb$r$g$b"}    = "38;5;$code";
              $ATTRIBUTES{"on_rgb$r$g$b"} = "48;5;$code";
          }
      }
  }
  
  # The last 256-color codes are 24 shades of grey.
  for my $n (0 .. 23) {
      my $code = $n + 232;
      $ATTRIBUTES{"grey$n"}    = "38;5;$code";
      $ATTRIBUTES{"on_grey$n"} = "48;5;$code";
  }
  
  ## use critic (ValuesAndExpressions::ProhibitMagicNumbers)
  
  # Reverse lookup.  Alphabetically first name for a sequence is preferred.
  our %ATTRIBUTES_R;
  for my $attr (reverse sort keys %ATTRIBUTES) {
      $ATTRIBUTES_R{ $ATTRIBUTES{$attr} } = $attr;
  }
  
  # Import any custom colors set in the environment.
  our %ALIASES;
  if (exists $ENV{ANSI_COLORS_ALIASES}) {
      my $spec = $ENV{ANSI_COLORS_ALIASES};
      $spec =~ s{\s+}{}xmsg;
  
      # Error reporting here is an interesting question.  Use warn rather than
      # carp because carp would report the line of the use or require, which
      # doesn't help anyone understand what's going on, whereas seeing this code
      # will be more helpful.
      ## no critic (ErrorHandling::RequireCarping)
      for my $definition (split m{,}xms, $spec) {
          my ($new, $old) = split m{=}xms, $definition, 2;
          if (!$new || !$old) {
              warn qq{Bad color mapping "$definition"};
          } else {
              my $result = eval { coloralias($new, $old) };
              if (!$result) {
                  my $error = $@;
                  $error =~ s{ [ ] at [ ] .* }{}xms;
                  warn qq{$error in "$definition"};
              }
          }
      }
  }
  
  # Stores the current color stack maintained by PUSHCOLOR and POPCOLOR.  This
  # is global and therefore not threadsafe.
  our @COLORSTACK;
  
  ##############################################################################
  # Implementation (constant form)
  ##############################################################################
  
  # Time to have fun!  We now want to define the constant subs, which are named
  # the same as the attributes above but in all caps.  Each constant sub needs
  # to act differently depending on whether $AUTORESET is set.  Without
  # autoreset:
  #
  #     BLUE "text\n"  ==>  "\e[34mtext\n"
  #
  # If $AUTORESET is set, we should instead get:
  #
  #     BLUE "text\n"  ==>  "\e[34mtext\n\e[0m"
  #
  # The sub also needs to handle the case where it has no arguments correctly.
  # Maintaining all of this as separate subs would be a major nightmare, as well
  # as duplicate the %ATTRIBUTES hash, so instead we define an AUTOLOAD sub to
  # define the constant subs on demand.  To do that, we check the name of the
  # called sub against the list of attributes, and if it's an all-caps version
  # of one of them, we define the sub on the fly and then run it.
  #
  # If the environment variable ANSI_COLORS_DISABLED is set to a true value,
  # just return the arguments without adding any escape sequences.  This is to
  # make it easier to write scripts that also work on systems without any ANSI
  # support, like Windows consoles.
  #
  ## no critic (ClassHierarchies::ProhibitAutoloading)
  ## no critic (Subroutines::RequireArgUnpacking)
  sub AUTOLOAD {
      my ($sub, $attr) = $AUTOLOAD =~ m{ \A ([\w:]*::([[:upper:]\d_]+)) \z }xms;
  
      # Check if we were called with something that doesn't look like an
      # attribute.
      if (!$attr || !defined $ATTRIBUTES{ lc $attr }) {
          croak("undefined subroutine &$AUTOLOAD called");
      }
  
      # If colors are disabled, just return the input.  Do this without
      # installing a sub for (marginal, unbenchmarked) speed.
      if ($ENV{ANSI_COLORS_DISABLED}) {
          return join q{}, @_;
      }
  
      # We've untainted the name of the sub.
      $AUTOLOAD = $sub;
  
      # Figure out the ANSI string to set the desired attribute.
      my $escape = "\e[" . $ATTRIBUTES{ lc $attr } . 'm';
  
      # Save the current value of $@.  We can't just use local since we want to
      # restore it before dispatching to the newly-created sub.  (The caller may
      # be colorizing output that includes $@.)
      my $eval_err = $@;
  
      # Generate the constant sub, which should still recognize some of our
      # package variables.  Use string eval to avoid a dependency on
      # Sub::Install, even though it makes it somewhat less readable.
      ## no critic (BuiltinFunctions::ProhibitStringyEval)
      ## no critic (ValuesAndExpressions::ProhibitImplicitNewlines)
      my $eval_result = eval qq{
          sub $AUTOLOAD {
              if (\$ENV{ANSI_COLORS_DISABLED}) {
                  return join q{}, \@_;
              } elsif (\$AUTOLOCAL && \@_) {
                  return PUSHCOLOR('$escape') . join(q{}, \@_) . POPCOLOR;
              } elsif (\$AUTORESET && \@_) {
                  return '$escape' . join(q{}, \@_) . "\e[0m";
              } else {
                  return '$escape' . join q{}, \@_;
              }
          }
          1;
      };
  
      # Failure is an internal error, not a problem with the caller.
      ## no critic (ErrorHandling::RequireCarping)
      if (!$eval_result) {
          die "failed to generate constant $attr: $@";
      }
  
      # Restore $@.
      ## no critic (Variables::RequireLocalizedPunctuationVars)
      $@ = $eval_err;
  
      # Dispatch to the newly-created sub.
      ## no critic (References::ProhibitDoubleSigils)
      goto &$AUTOLOAD;
  }
  ## use critic (Subroutines::RequireArgUnpacking)
  
  # Append a new color to the top of the color stack and return the top of
  # the stack.
  #
  # $text - Any text we're applying colors to, with color escapes prepended
  #
  # Returns: The text passed in
  sub PUSHCOLOR {
      my (@text) = @_;
      my $text = join q{}, @text;
  
      # Extract any number of color-setting escape sequences from the start of
      # the string.
      my ($color) = $text =~ m{ \A ( (?:\e\[ [\d;]+ m)+ ) }xms;
  
      # If we already have a stack, append these escapes to the set from the top
      # of the stack.  This way, each position in the stack stores the complete
      # enabled colors for that stage, at the cost of some potential
      # inefficiency.
      if (@COLORSTACK) {
          $color = $COLORSTACK[-1] . $color;
      }
  
      # Push the color onto the stack.
      push @COLORSTACK, $color;
      return $text;
  }
  
  # Pop the color stack and return the new top of the stack (or reset, if
  # the stack is empty).
  #
  # @text - Any text we're applying colors to
  #
  # Returns: The concatenation of @text prepended with the new stack color
  sub POPCOLOR {
      my (@text) = @_;
      pop @COLORSTACK;
      if (@COLORSTACK) {
          return $COLORSTACK[-1] . join q{}, @text;
      } else {
          return RESET(@text);
      }
  }
  
  # Surround arguments with a push and a pop.  The effect will be to reset the
  # colors to whatever was on the color stack before this sequence of colors was
  # applied.
  #
  # @text - Any text we're applying colors to
  #
  # Returns: The concatenation of the text and the proper color reset sequence.
  sub LOCALCOLOR {
      my (@text) = @_;
      return PUSHCOLOR(join q{}, @text) . POPCOLOR();
  }
  
  ##############################################################################
  # Implementation (attribute string form)
  ##############################################################################
  
  # Return the escape code for a given set of color attributes.
  #
  # @codes - A list of possibly space-separated color attributes
  #
  # Returns: The escape sequence setting those color attributes
  #          undef if no escape sequences were given
  #  Throws: Text exception for any invalid attribute
  sub color {
      my (@codes) = @_;
      @codes = map { split } @codes;
  
      # Return the empty string if colors are disabled.
      if ($ENV{ANSI_COLORS_DISABLED}) {
          return q{};
      }
  
      # Build the attribute string from semicolon-separated numbers.
      my $attribute = q{};
      for my $code (@codes) {
          $code = lc $code;
          if (defined $ATTRIBUTES{$code}) {
              $attribute .= $ATTRIBUTES{$code} . q{;};
          } elsif (defined $ALIASES{$code}) {
              $attribute .= $ALIASES{$code} . q{;};
          } else {
              croak("Invalid attribute name $code");
          }
      }
  
      # We added one too many semicolons for simplicity.  Remove the last one.
      chop $attribute;
  
      # Return undef if there were no attributes.
      return ($attribute ne q{}) ? "\e[${attribute}m" : undef;
  }
  
  # Return a list of named color attributes for a given set of escape codes.
  # Escape sequences can be given with or without enclosing "\e[" and "m".  The
  # empty escape sequence '' or "\e[m" gives an empty list of attrs.
  #
  # There is one special case.  256-color codes start with 38 or 48, followed by
  # a 5 and then the 256-color code.
  #
  # @escapes - A list of escape sequences or escape sequence numbers
  #
  # Returns: An array of attribute names corresponding to those sequences
  #  Throws: Text exceptions on invalid escape sequences or unknown colors
  sub uncolor {
      my (@escapes) = @_;
      my (@nums, @result);
  
      # Walk the list of escapes and build a list of attribute numbers.
      for my $escape (@escapes) {
          $escape =~ s{ \A \e\[ }{}xms;
          $escape =~ s{ m \z }   {}xms;
          my ($attrs) = $escape =~ m{ \A ((?:\d+;)* \d*) \z }xms;
          if (!defined $attrs) {
              croak("Bad escape sequence $escape");
          }
  
          # Pull off 256-color codes (38;5;n or 48;5;n) as a unit.
          push @nums, $attrs =~ m{ ( 0*[34]8;0*5;\d+ | \d+ ) (?: ; | \z ) }xmsg;
      }
  
      # Now, walk the list of numbers and convert them to attribute names.
      # Strip leading zeroes from any of the numbers.  (xterm, at least, allows
      # leading zeroes to be added to any number in an escape sequence.)
      for my $num (@nums) {
          $num =~ s{ ( \A | ; ) 0+ (\d) }{$1$2}xmsg;
          my $name = $ATTRIBUTES_R{$num};
          if (!defined $name) {
              croak("No name for escape sequence $num");
          }
          push @result, $name;
      }
  
      # Return the attribute names.
      return @result;
  }
  
  # Given a string and a set of attributes, returns the string surrounded by
  # escape codes to set those attributes and then clear them at the end of the
  # string.  The attributes can be given either as an array ref as the first
  # argument or as a list as the second and subsequent arguments.
  #
  # If $EACHLINE is set, insert a reset before each occurrence of the string
  # $EACHLINE and the starting attribute code after the string $EACHLINE, so
  # that no attribute crosses line delimiters (this is often desirable if the
  # output is to be piped to a pager or some other program).
  #
  # $first - An anonymous array of attributes or the text to color
  # @rest  - The text to color or the list of attributes
  #
  # Returns: The text, concatenated if necessary, surrounded by escapes to set
  #          the desired colors and reset them afterwards
  #  Throws: Text exception on invalid attributes
  sub colored {
      my ($first, @rest) = @_;
      my ($string, @codes);
      if (ref($first) && ref($first) eq 'ARRAY') {
          @codes = @{$first};
          $string = join q{}, @rest;
      } else {
          $string = $first;
          @codes  = @rest;
      }
  
      # Return the string unmolested if colors are disabled.
      if ($ENV{ANSI_COLORS_DISABLED}) {
          return $string;
      }
  
      # Find the attribute string for our colors.
      my $attr = color(@codes);
  
      # If $EACHLINE is defined, split the string on line boundaries, suppress
      # empty segments, and then colorize each of the line sections.
      if (defined $EACHLINE) {
          my @text = map { ($_ ne $EACHLINE) ? $attr . $_ . "\e[0m" : $_ }
            grep { length($_) > 0 }
            split m{ (\Q$EACHLINE\E) }xms, $string;
          return join q{}, @text;
      } else {
          return $attr . $string . "\e[0m";
      }
  }
  
  # Define a new color alias, or return the value of an existing alias.
  #
  # $alias - The color alias to define
  # $color - The standard color the alias will correspond to (optional)
  #
  # Returns: The standard color value of the alias
  #          undef if one argument was given and the alias was not recognized
  #  Throws: Text exceptions for invalid alias names, attempts to use a
  #          standard color name as an alias, or an unknown standard color name
  sub coloralias {
      my ($alias, $color) = @_;
      if (!defined $color) {
          if (!exists $ALIASES{$alias}) {
              return;
          } else {
              return $ATTRIBUTES_R{ $ALIASES{$alias} };
          }
      }
      if ($alias !~ m{ \A [\w._-]+ \z }xms) {
          croak(qq{Invalid alias name "$alias"});
      } elsif ($ATTRIBUTES{$alias}) {
          croak(qq{Cannot alias standard color "$alias"});
      } elsif (!exists $ATTRIBUTES{$color}) {
          croak(qq{Invalid attribute name "$color"});
      }
      $ALIASES{$alias} = $ATTRIBUTES{$color};
      return $color;
  }
  
  # Given a string, strip the ANSI color codes out of that string and return the
  # result.  This removes only ANSI color codes, not movement codes and other
  # escape sequences.
  #
  # @string - The list of strings to sanitize
  #
  # Returns: (array)  The strings stripped of ANSI color escape sequences
  #          (scalar) The same, concatenated
  sub colorstrip {
      my (@string) = @_;
      for my $string (@string) {
          $string =~ s{ \e\[ [\d;]* m }{}xmsg;
      }
      return wantarray ? @string : join q{}, @string;
  }
  
  # Given a list of color attributes (arguments for color, for instance), return
  # true if they're all valid or false if any of them are invalid.
  #
  # @codes - A list of color attributes, possibly space-separated
  #
  # Returns: True if all the attributes are valid, false otherwise.
  sub colorvalid {
      my (@codes) = @_;
      @codes = map { split q{ }, lc $_ } @codes;
      for my $code (@codes) {
          if (!defined $ATTRIBUTES{$code} && !defined $ALIASES{$code}) {
              return;
          }
      }
      return 1;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  # Ensure we evaluate to true.
  1;
  __END__
  
  =head1 NAME
  
  Term::ANSIColor - Color screen output using ANSI escape sequences
  
  =for stopwords
  cyan colorize namespace runtime TMTOWTDI cmd.exe 4nt.exe command.com NT
  ESC Delvare SSH OpenSSH aixterm ECMA-048 Fraktur overlining Zenin
  reimplemented Allbery PUSHCOLOR POPCOLOR LOCALCOLOR openmethods.com
  grey ATTR urxvt mistyped prepending Bareword filehandle Cygwin Starsinic
  aterm rxvt CPAN RGB Solarized Whitespace alphanumerics undef
  
  =head1 SYNOPSIS
  
      use Term::ANSIColor;
      print color 'bold blue';
      print "This text is bold blue.\n";
      print color 'reset';
      print "This text is normal.\n";
      print colored("Yellow on magenta.", 'yellow on_magenta'), "\n";
      print "This text is normal.\n";
      print colored ['yellow on_magenta'], 'Yellow on magenta.', "\n";
      print colored ['red on_bright_yellow'], 'Red on bright yellow.', "\n";
      print colored ['bright_red on_black'], 'Bright red on black.', "\n";
      print "\n";
  
      # Map escape sequences back to color names.
      use Term::ANSIColor 1.04 qw(uncolor);
      my $names = uncolor('01;31');
      print join(q{ }, @{$names}), "\n";
  
      # Strip all color escape sequences.
      use Term::ANSIColor 2.01 qw(colorstrip);
      print colorstrip '\e[1mThis is bold\e[0m', "\n";
  
      # Determine whether a color is valid.
      use Term::ANSIColor 2.02 qw(colorvalid);
      my $valid = colorvalid('blue bold', 'on_magenta');
      print "Color string is ", $valid ? "valid\n" : "invalid\n";
  
      # Create new aliases for colors.
      use Term::ANSIColor 4.00 qw(coloralias);
      coloralias('alert', 'red');
      print "Alert is ", coloralias('alert'), "\n";
      print colored("This is in red.", 'alert'), "\n";
  
      use Term::ANSIColor qw(:constants);
      print BOLD, BLUE, "This text is in bold blue.\n", RESET;
  
      use Term::ANSIColor qw(:constants);
      {
          local $Term::ANSIColor::AUTORESET = 1;
          print BOLD BLUE "This text is in bold blue.\n";
          print "This text is normal.\n";
      }
  
      use Term::ANSIColor 2.00 qw(:pushpop);
      print PUSHCOLOR RED ON_GREEN "This text is red on green.\n";
      print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\n";
      print RESET BRIGHT_BLUE "This text is just bright blue.\n";
      print POPCOLOR "Back to red on green.\n";
      print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\n";
      print "This text is red on green.\n";
      {
          local $Term::ANSIColor::AUTOLOCAL = 1;
          print ON_BLUE "This text is red on blue.\n";
          print "This text is red on green.\n";
      }
      print POPCOLOR "Back to whatever we started as.\n";
  
  =head1 DESCRIPTION
  
  This module has two interfaces, one through color() and colored() and the
  other through constants.  It also offers the utility functions uncolor(),
  colorstrip(), colorvalid(), and coloralias(), which have to be explicitly
  imported to be used (see L</SYNOPSIS>).
  
  See L</COMPATIBILITY> for the versions of Term::ANSIColor that introduced
  particular features and the versions of Perl that included them.
  
  =head2 Supported Colors
  
  Terminal emulators that support color divide into two types: ones that
  support only eight colors, ones that support sixteen, and ones that
  support 256.  This module provides the ANSI escape codes all of them.
  These colors are referred to as ANSI colors 0 through 7 (normal), 8
  through 15 (16-color), and 16 through 255 (256-color).
  
  Unfortunately, interpretation of colors 0 through 7 often depends on
  whether the emulator supports eight colors or sixteen colors.  Emulators
  that only support eight colors (such as the Linux console) will display
  colors 0 through 7 with normal brightness and ignore colors 8 through 15,
  treating them the same as white.  Emulators that support 16 colors, such
  as gnome-terminal, normally display colors 0 through 7 as dim or darker
  versions and colors 8 through 15 as normal brightness.  On such emulators,
  the "normal" white (color 7) usually is shown as pale grey, requiring
  bright white (15) to be used to get a real white color.  Bright black
  usually is a dark grey color, although some terminals display it as pure
  black.  Some sixteen-color terminal emulators also treat normal yellow
  (color 3) as orange or brown, and bright yellow (color 11) as yellow.
  
  Following the normal convention of sixteen-color emulators, this module
  provides a pair of attributes for each color.  For every normal color (0
  through 7), the corresponding bright color (8 through 15) is obtained by
  prepending the string C<bright_> to the normal color name.  For example,
  C<red> is color 1 and C<bright_red> is color 9.  The same applies for
  background colors: C<on_red> is the normal color and C<on_bright_red> is
  the bright color.  Capitalize these strings for the constant interface.
  
  For 256-color emulators, this module additionally provides C<ansi0>
  through C<ansi15>, which are the same as colors 0 through 15 in
  sixteen-color emulators but use the 256-color escape syntax, C<grey0>
  through C<grey23> ranging from nearly black to nearly white, and a set of
  RGB colors.  The RGB colors are of the form C<rgbI<RGB>> where I<R>, I<G>,
  and I<B> are numbers from 0 to 5 giving the intensity of red, green, and
  blue.  C<on_> variants of all of these colors are also provided.  These
  colors may be ignored completely on non-256-color terminals or may be
  misinterpreted and produce random behavior.  Additional attributes such as
  blink, italic, or bold may not work with the 256-color palette.
  
  There is unfortunately no way to know whether the current emulator
  supports more than eight colors, which makes the choice of colors
  difficult.  The most conservative choice is to use only the regular
  colors, which are at least displayed on all emulators.  However, they will
  appear dark in sixteen-color terminal emulators, including most common
  emulators in UNIX X environments.  If you know the display is one of those
  emulators, you may wish to use the bright variants instead.  Even better,
  offer the user a way to configure the colors for a given application to
  fit their terminal emulator.
  
  =head2 Function Interface
  
  The function interface uses attribute strings to describe the colors and
  text attributes to assign to text.  The recognized non-color attributes
  are clear, reset, bold, dark, faint, italic, underline, underscore, blink,
  reverse, and concealed.  Clear and reset (reset to default attributes),
  dark and faint (dim and saturated), and underline and underscore are
  equivalent, so use whichever is the most intuitive to you.
  
  Note that not all attributes are supported by all terminal types, and some
  terminals may not support any of these sequences.  Dark and faint, italic,
  blink, and concealed in particular are frequently not implemented.
  
  The recognized normal foreground color attributes (colors 0 to 7) are:
  
    black  red  green  yellow  blue  magenta  cyan  white
  
  The corresponding bright foreground color attributes (colors 8 to 15) are:
  
    bright_black  bright_red      bright_green  bright_yellow
    bright_blue   bright_magenta  bright_cyan   bright_white
  
  The recognized normal background color attributes (colors 0 to 7) are:
  
    on_black  on_red      on_green  on yellow
    on_blue   on_magenta  on_cyan   on_white
  
  The recognized bright background color attributes (colors 8 to 15) are:
  
    on_bright_black  on_bright_red      on_bright_green  on_bright_yellow
    on_bright_blue   on_bright_magenta  on_bright_cyan   on_bright_white
  
  For 256-color terminals, the recognized foreground colors are:
  
    ansi0 .. ansi15
    grey0 .. grey23
  
  plus C<rgbI<RGB>> for I<R>, I<G>, and I<B> values from 0 to 5, such as
  C<rgb000> or C<rgb515>.  Similarly, the recognized background colors are:
  
    on_ansi0 .. on_ansi15
    on_grey0 .. on_grey23
  
  plus C<on_rgbI<RGB>> for for I<R>, I<G>, and I<B> values from 0 to 5.
  
  For any of the above listed attributes, case is not significant.
  
  Attributes, once set, last until they are unset (by printing the attribute
  C<clear> or C<reset>).  Be careful to do this, or otherwise your attribute
  will last after your script is done running, and people get very annoyed
  at having their prompt and typing changed to weird colors.
  
  =over 4
  
  =item color(ATTR[, ATTR ...])
  
  color() takes any number of strings as arguments and considers them to be
  space-separated lists of attributes.  It then forms and returns the escape
  sequence to set those attributes.  It doesn't print it out, just returns
  it, so you'll have to print it yourself if you want to.  This is so that
  you can save it as a string, pass it to something else, send it to a file
  handle, or do anything else with it that you might care to.  color()
  throws an exception if given an invalid attribute.
  
  =item colored(STRING, ATTR[, ATTR ...])
  
  =item colored(ATTR-REF, STRING[, STRING...])
  
  As an aid in resetting colors, colored() takes a scalar as the first
  argument and any number of attribute strings as the second argument and
  returns the scalar wrapped in escape codes so that the attributes will be
  set as requested before the string and reset to normal after the string.
  Alternately, you can pass a reference to an array as the first argument,
  and then the contents of that array will be taken as attributes and color
  codes and the remainder of the arguments as text to colorize.
  
  Normally, colored() just puts attribute codes at the beginning and end of
  the string, but if you set $Term::ANSIColor::EACHLINE to some string, that
  string will be considered the line delimiter and the attribute will be set
  at the beginning of each line of the passed string and reset at the end of
  each line.  This is often desirable if the output contains newlines and
  you're using background colors, since a background color that persists
  across a newline is often interpreted by the terminal as providing the
  default background color for the next line.  Programs like pagers can also
  be confused by attributes that span lines.  Normally you'll want to set
  $Term::ANSIColor::EACHLINE to C<"\n"> to use this feature.
  
  =item uncolor(ESCAPE)
  
  uncolor() performs the opposite translation as color(), turning escape
  sequences into a list of strings corresponding to the attributes being set
  by those sequences.
  
  =item colorstrip(STRING[, STRING ...])
  
  colorstrip() removes all color escape sequences from the provided strings,
  returning the modified strings separately in array context or joined
  together in scalar context.  Its arguments are not modified.
  
  =item colorvalid(ATTR[, ATTR ...])
  
  colorvalid() takes attribute strings the same as color() and returns true
  if all attributes are known and false otherwise.
  
  =item coloralias(ALIAS[, ATTR])
  
  If ATTR is specified, coloralias() sets up an alias of ALIAS for the
  standard color ATTR.  From that point forward, ALIAS can be passed into
  color(), colored(), and colorvalid() and will have the same meaning as
  ATTR.  One possible use of this facility is to give more meaningful names
  to the 256-color RGB colors.  Only alphanumerics, C<.>, C<_>, and C<-> are
  allowed in alias names.
  
  If ATTR is not specified, coloralias() returns the standard color name to
  which ALIAS is aliased, if any, or undef if ALIAS does not exist.
  
  This is the same facility used by the ANSI_COLORS_ALIASES environment
  variable (see L</ENVIRONMENT> below) but can be used at runtime, not just
  when the module is loaded.
  
  Later invocations of coloralias() with the same ALIAS will override
  earlier aliases.  There is no way to remove an alias.
  
  Aliases have no effect on the return value of uncolor().
  
  B<WARNING>: Aliases are global and affect all callers in the same process.
  There is no way to set an alias limited to a particular block of code or a
  particular object.
  
  =back
  
  =head2 Constant Interface
  
  Alternately, if you import C<:constants>, you can use the following
  constants directly:
  
    CLEAR           RESET             BOLD            DARK
    FAINT           ITALIC            UNDERLINE       UNDERSCORE
    BLINK           REVERSE           CONCEALED
  
    BLACK           RED               GREEN           YELLOW
    BLUE            MAGENTA           CYAN            WHITE
    BRIGHT_BLACK    BRIGHT_RED        BRIGHT_GREEN    BRIGHT_YELLOW
    BRIGHT_BLUE     BRIGHT_MAGENTA    BRIGHT_CYAN     BRIGHT_WHITE
  
    ON_BLACK        ON_RED            ON_GREEN        ON_YELLOW
    ON_BLUE         ON_MAGENTA        ON_CYAN         ON_WHITE
    ON_BRIGHT_BLACK ON_BRIGHT_RED     ON_BRIGHT_GREEN ON_BRIGHT_YELLOW
    ON_BRIGHT_BLUE  ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN  ON_BRIGHT_WHITE
  
  These are the same as color('attribute') and can be used if you prefer
  typing:
  
      print BOLD BLUE ON_WHITE "Text", RESET, "\n";
  
  to
  
      print colored ("Text", 'bold blue on_white'), "\n";
  
  (Note that the newline is kept separate to avoid confusing the terminal as
  described above since a background color is being used.)
  
  If you import C<:constants256>, you can use the following constants
  directly:
  
    ANSI0 .. ANSI15
    GREY0 .. GREY23
  
    RGBXYZ (for X, Y, and Z values from 0 to 5, like RGB000 or RGB515)
  
    ON_ANSI0 .. ON_ANSI15
    ON_GREY0 .. ON_GREY23
  
    ON_RGBXYZ (for X, Y, and Z values from 0 to 5)
  
  Note that C<:constants256> does not include the other constants, so if you
  want to mix both, you need to include C<:constants> as well.  You may want
  to explicitly import at least C<RESET>, as in:
  
      use Term::ANSIColor 4.00 qw(RESET :constants256);
  
  When using the constants, if you don't want to have to remember to add the
  C<, RESET> at the end of each print line, you can set
  $Term::ANSIColor::AUTORESET to a true value.  Then, the display mode will
  automatically be reset if there is no comma after the constant.  In other
  words, with that variable set:
  
      print BOLD BLUE "Text\n";
  
  will reset the display mode afterward, whereas:
  
      print BOLD, BLUE, "Text\n";
  
  will not.  If you are using background colors, you will probably want to
  either use say() (in newer versions of Perl) or print the newline with a
  separate print statement to avoid confusing the terminal.
  
  If $Term::ANSIColor::AUTOLOCAL is set (see below), it takes precedence
  over $Term::ANSIColor::AUTORESET, and the latter is ignored.
  
  The subroutine interface has the advantage over the constants interface in
  that only two subroutines are exported into your namespace, versus
  thirty-eight in the constants interface.  On the flip side, the constants
  interface has the advantage of better compile time error checking, since
  misspelled names of colors or attributes in calls to color() and colored()
  won't be caught until runtime whereas misspelled names of constants will
  be caught at compile time.  So, pollute your namespace with almost two
  dozen subroutines that you may not even use that often, or risk a silly
  bug by mistyping an attribute.  Your choice, TMTOWTDI after all.
  
  =head2 The Color Stack
  
  You can import C<:pushpop> and maintain a stack of colors using PUSHCOLOR,
  POPCOLOR, and LOCALCOLOR.  PUSHCOLOR takes the attribute string that
  starts its argument and pushes it onto a stack of attributes.  POPCOLOR
  removes the top of the stack and restores the previous attributes set by
  the argument of a prior PUSHCOLOR.  LOCALCOLOR surrounds its argument in a
  PUSHCOLOR and POPCOLOR so that the color resets afterward.
  
  If $Term::ANSIColor::AUTOLOCAL is set, each sequence of color constants
  will be implicitly preceded by LOCALCOLOR.  In other words, the following:
  
      {
          local $Term::ANSIColor::AUTOLOCAL = 1;
          print BLUE "Text\n";
      }
  
  is equivalent to:
  
      print LOCALCOLOR BLUE "Text\n";
  
  If $Term::ANSIColor::AUTOLOCAL is set, it takes precedence over
  $Term::ANSIColor::AUTORESET, and the latter is ignored.
  
  When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly
  important to not put commas between the constants.
  
      print PUSHCOLOR BLUE "Text\n";
  
  will correctly push BLUE onto the top of the stack.
  
      print PUSHCOLOR, BLUE, "Text\n";    # wrong!
  
  will not, and a subsequent pop won't restore the correct attributes.
  PUSHCOLOR pushes the attributes set by its argument, which is normally a
  string of color constants.  It can't ask the terminal what the current
  attributes are.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bad color mapping %s
  
  (W) The specified color mapping from ANSI_COLORS_ALIASES is not valid and
  could not be parsed.  It was ignored.
  
  =item Bad escape sequence %s
  
  (F) You passed an invalid ANSI escape sequence to uncolor().
  
  =item Bareword "%s" not allowed while "strict subs" in use
  
  (F) You probably mistyped a constant color name such as:
  
      $Foobar = FOOBAR . "This line should be blue\n";
  
  or:
  
      @Foobar = FOOBAR, "This line should be blue\n";
  
  This will only show up under use strict (another good reason to run under
  use strict).
  
  =item Cannot alias standard color %s
  
  (F) The alias name passed to coloralias() matches a standard color name.
  Standard color names cannot be aliased.
  
  =item Cannot alias standard color %s in %s
  
  (W) The same, but in ANSI_COLORS_ALIASES.  The color mapping was ignored.
  
  =item Invalid alias name %s
  
  (F) You passed an invalid alias name to coloralias().  Alias names must
  consist only of alphanumerics, C<.>, C<->, and C<_>.
  
  =item Invalid alias name %s in %s
  
  (W) You specified an invalid alias name on the left hand of the equal sign
  in a color mapping in ANSI_COLORS_ALIASES.  The color mapping was ignored.
  
  =item Invalid attribute name %s
  
  (F) You passed an invalid attribute name to color(), colored(), or
  coloralias().
  
  =item Invalid attribute name %s in %s
  
  (W) You specified an invalid attribute name on the right hand of the equal
  sign in a color mapping in ANSI_COLORS_ALIASES.  The color mapping was
  ignored.
  
  =item Name "%s" used only once: possible typo
  
  (W) You probably mistyped a constant color name such as:
  
      print FOOBAR "This text is color FOOBAR\n";
  
  It's probably better to always use commas after constant names in order to
  force the next error.
  
  =item No comma allowed after filehandle
  
  (F) You probably mistyped a constant color name such as:
  
      print FOOBAR, "This text is color FOOBAR\n";
  
  Generating this fatal compile error is one of the main advantages of using
  the constants interface, since you'll immediately know if you mistype a
  color name.
  
  =item No name for escape sequence %s
  
  (F) The ANSI escape sequence passed to uncolor() contains escapes which
  aren't recognized and can't be translated to names.
  
  =back
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item ANSI_COLORS_ALIASES
  
  This environment variable allows the user to specify custom color aliases
  that will be understood by color(), colored(), and colorvalid().  None of
  the other functions will be affected, and no new color constants will be
  created.  The custom colors are aliases for existing color names; no new
  escape sequences can be introduced.  Only alphanumerics, C<.>, C<_>, and
  C<-> are allowed in alias names.
  
  The format is:
  
      ANSI_COLORS_ALIASES='newcolor1=oldcolor1,newcolor2=oldcolor2'
  
  Whitespace is ignored.
  
  For example the L<Solarized|http://ethanschoonover.com/solarized> colors
  can be mapped with:
  
      ANSI_COLORS_ALIASES='\
          base00=bright_yellow, on_base00=on_bright_yellow,\
          base01=bright_green,  on_base01=on_bright_green, \
          base02=black,         on_base02=on_black,        \
          base03=bright_black,  on_base03=on_bright_black, \
          base0=bright_blue,    on_base0=on_bright_blue,   \
          base1=bright_cyan,    on_base1=on_bright_cyan,   \
          base2=white,          on_base2=on_white,         \
          base3=bright_white,   on_base3=on_bright_white,  \
          orange=bright_red,    on_orange=on_bright_red,   \
          violet=bright_magenta,on_violet=on_bright_magenta'
  
  This environment variable is read and applied when the Term::ANSIColor
  module is loaded and is then subsequently ignored.  Changes to
  ANSI_COLORS_ALIASES after the module is loaded will have no effect.  See
  coloralias() for an equivalent facility that can be used at runtime.
  
  =item ANSI_COLORS_DISABLED
  
  If this environment variable is set to a true value, all of the functions
  defined by this module (color(), colored(), and all of the constants not
  previously used in the program) will not output any escape sequences and
  instead will just return the empty string or pass through the original
  text as appropriate.  This is intended to support easy use of scripts
  using this module on platforms that don't support ANSI escape sequences.
  
  =back
  
  =head1 COMPATIBILITY
  
  Term::ANSIColor was first included with Perl in Perl 5.6.0.
  
  The uncolor() function and support for ANSI_COLORS_DISABLED were added in
  Term::ANSIColor 1.04, included in Perl 5.8.0.
  
  Support for dark was added in Term::ANSIColor 1.08, included in Perl
  5.8.4.
  
  The color stack, including the C<:pushpop> import tag, PUSHCOLOR,
  POPCOLOR, LOCALCOLOR, and the $Term::ANSIColor::AUTOLOCAL variable, was
  added in Term::ANSIColor 2.00, included in Perl 5.10.1.
  
  colorstrip() was added in Term::ANSIColor 2.01 and colorvalid() was added
  in Term::ANSIColor 2.02, both included in Perl 5.11.0.
  
  Support for colors 8 through 15 (the C<bright_> variants) was added in
  Term::ANSIColor 3.00, included in Perl 5.13.3.
  
  Support for italic was added in Term::ANSIColor 3.02, included in Perl
  5.17.1.
  
  Support for colors 16 through 256 (the C<ansi>, C<rgb>, and C<grey>
  colors), the C<:constants256> import tag, the coloralias() function, and
  support for the ANSI_COLORS_ALIASES environment variable were added in
  Term::ANSIColor 4.00.
  
  $Term::ANSIColor::AUTOLOCAL was changed to take precedence over
  $Term::ANSIColor::AUTORESET, rather than the other way around, in
  Term::ANSIColor 4.00.
  
  =head1 RESTRICTIONS
  
  It would be nice if one could leave off the commas around the constants
  entirely and just say:
  
      print BOLD BLUE ON_WHITE "Text\n" RESET;
  
  but the syntax of Perl doesn't allow this.  You need a comma after the
  string.  (Of course, you may consider it a bug that commas between all the
  constants aren't required, in which case you may feel free to insert
  commas unless you're using $Term::ANSIColor::AUTORESET or
  PUSHCOLOR/POPCOLOR.)
  
  For easier debugging, you may prefer to always use the commas when not
  setting $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR so that you'll
  get a fatal compile error rather than a warning.
  
  It's not possible to use this module to embed formatting and color
  attributes using Perl formats.  They replace the escape character with a
  space (as documented in L<perlform(1)>), resulting in garbled output from
  the unrecognized attribute.  Even if there were a way around that problem,
  the format doesn't know that the non-printing escape sequence is
  zero-length and would incorrectly format the output.  For formatted output
  using color or other attributes, either use sprintf() instead or use
  formline() and then add the color or other attributes after formatting and
  before output.
  
  =head1 NOTES
  
  The codes generated by this module are standard terminal control codes,
  complying with ECMA-048 and ISO 6429 (generally referred to as "ANSI
  color" for the color codes).  The non-color control codes (bold, dark,
  italic, underline, and reverse) are part of the earlier ANSI X3.64
  standard for control sequences for video terminals and peripherals.
  
  Note that not all displays are ISO 6429-compliant, or even X3.64-compliant
  (or are even attempting to be so).  This module will not work as expected
  on displays that do not honor these escape sequences, such as cmd.exe,
  4nt.exe, and command.com under either Windows NT or Windows 2000.  They
  may just be ignored, or they may display as an ESC character followed by
  some apparent garbage.
  
  Jean Delvare provided the following table of different common terminal
  emulators and their support for the various attributes and others have
  helped me flesh it out:
  
                clear    bold     faint   under    blink   reverse  conceal
   ------------------------------------------------------------------------
   xterm         yes      yes      no      yes      yes      yes      yes
   linux         yes      yes      yes    bold      yes      yes      no
   rxvt          yes      yes      no      yes  bold/black   yes      no
   dtterm        yes      yes      yes     yes    reverse    yes      yes
   teraterm      yes    reverse    no      yes    rev/red    yes      no
   aixterm      kinda   normal     no      yes      no       yes      yes
   PuTTY         yes     color     no      yes      no       yes      no
   Windows       yes      no       no      no       no       yes      no
   Cygwin SSH    yes      yes      no     color    color    color     yes
   Terminal.app  yes      yes      no      yes      yes      yes      yes
  
  Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under
  Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac
  OS X.  Where the entry is other than yes or no, that emulator displays the
  given attribute as something else instead.  Note that on an aixterm, clear
  doesn't reset colors; you have to explicitly set the colors back to what
  you want.  More entries in this table are welcome.
  
  Support for code 3 (italic) is rare and therefore not mentioned in that
  table.  It is not believed to be fully supported by any of the terminals
  listed, although it's displayed as green in the Linux console, but it is
  reportedly supported by urxvt.
  
  Note that codes 6 (rapid blink) and 9 (strike-through) are specified in
  ANSI X3.64 and ECMA-048 but are not commonly supported by most displays
  and emulators and therefore aren't supported by this module at the present
  time.  ECMA-048 also specifies a large number of other attributes,
  including a sequence of attributes for font changes, Fraktur characters,
  double-underlining, framing, circling, and overlining.  As none of these
  attributes are widely supported or useful, they also aren't currently
  supported by this module.
  
  Most modern X terminal emulators support 256 colors.  Known to not support
  those colors are aterm, rxvt, Terminal.app, and TTY/VC.
  
  =head1 SEE ALSO
  
  ECMA-048 is available on-line (at least at the time of this writing) at
  L<http://www.ecma-international.org/publications/standards/Ecma-048.htm>.
  
  ISO 6429 is available from ISO for a charge; the author of this module
  does not own a copy of it.  Since the source material for ISO 6429 was
  ECMA-048 and the latter is available for free, there seems little reason
  to obtain the ISO standard.
  
  The 256-color control sequences are documented at
  L<http://www.xfree86.org/current/ctlseqs.html> (search for 256-color).
  
  The CPAN module Term::ExtendedColor provides a different and more
  comprehensive interface for 256-color emulators that may be more
  convenient.
  
  The current version of this module is always available from its web site
  at L<http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of
  the Perl core distribution as of 5.6.0.
  
  =head1 AUTHORS
  
  Original idea (using constants) by Zenin, reimplemented using subs by Russ
  Allbery <rra@stanford.edu>, and then combined with the original idea by
  Russ with input from Zenin.  256-color support is based on work by Kurt
  Starsinic.  Russ Allbery now maintains this module.
  
  PUSHCOLOR, POPCOLOR, and LOCALCOLOR were contributed by openmethods.com
  voice solutions.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1996 Zenin.  Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005,
  2006, 2008, 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>.
  Copyright 2012 Kurt Starsinic <kstarsinic@gmail.com>.  This program is
  free software; you may redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
TERM_ANSICOLOR

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.09";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, @finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			push @finally, ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my @guts = @{ shift() };
      my $code = shift @guts;
      $code->(@guts);
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the try block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L<BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the try block dies, it returns the value of the last statement executed in
  the catch block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following two examples both
  assign C<"bar"> to C<$x>.
  
  	my $x = try { die "foo" } catch { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add finally blocks making the following true.
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  Finally blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many finally blocks to a
  given try block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory try subroutine, an optional catch subroutine & finally
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the finally block if given will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the catch block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. Finally blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the finally block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  In other words, the following code
  does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the finally block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an eval block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an eval block C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the eval was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  or
  
  	sub bar_in_place {
  		my $self = shift;
  		my $args = \@_;
  		try { $_ = $self->bar($_) for @$args }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
  	sub bar {
  		try { return "foo" };
  		return "baz";
  	}
  
  	say bar(); # "baz"
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"YAML/Tiny.pm"} = <<'YAML_TINY';
  package YAML::Tiny;
  
  use strict;
  
  # UTF Support?
  sub HAVE_UTF8 () { $] >= 5.007003 }
  BEGIN {
  	if ( HAVE_UTF8 ) {
  		# The string eval helps hide this from Test::MinimumVersion
  		eval "require utf8;";
  		die "Failed to load UTF-8 support" if $@;
  	}
  
  	# Class structure
  	require 5.004;
  	require Exporter;
  	require Carp;
  	$YAML::Tiny::VERSION   = '1.50';
  	# $YAML::Tiny::VERSION   = eval $YAML::Tiny::VERSION;
  	@YAML::Tiny::ISA       = qw{ Exporter  };
  	@YAML::Tiny::EXPORT    = qw{ Load Dump };
  	@YAML::Tiny::EXPORT_OK = qw{ LoadFile DumpFile freeze thaw };
  
  	# Error storage
  	$YAML::Tiny::errstr    = '';
  }
  
  # The character class of all characters we need to escape
  # NOTE: Inlined, since it's only used once
  # my $RE_ESCAPE = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f\"\n]';
  
  # Printed form of the unprintable characters in the lowest range
  # of ASCII characters, listed by ASCII ordinal position.
  my @UNPRINTABLE = qw(
  	z    x01  x02  x03  x04  x05  x06  a
  	x08  t    n    v    f    r    x0e  x0f
  	x10  x11  x12  x13  x14  x15  x16  x17
  	x18  x19  x1a  e    x1c  x1d  x1e  x1f
  );
  
  # Printable characters for escapes
  my %UNESCAPES = (
  	z => "\x00", a => "\x07", t    => "\x09",
  	n => "\x0a", v => "\x0b", f    => "\x0c",
  	r => "\x0d", e => "\x1b", '\\' => '\\',
  );
  
  # Special magic boolean words
  my %QUOTE = map { $_ => 1 } qw{
  	null Null NULL
  	y Y yes Yes YES n N no No NO
  	true True TRUE false False FALSE
  	on On ON off Off OFF
  };
  
  
  
  
  
  #####################################################################
  # Implementation
  
  # Create an empty YAML::Tiny object
  sub new {
  	my $class = shift;
  	bless [ @_ ], $class;
  }
  
  # Create an object from a file
  sub read {
  	my $class = ref $_[0] ? ref shift : shift;
  
  	# Check the file
  	my $file = shift or return $class->_error( 'You did not specify a file name' );
  	return $class->_error( "File '$file' does not exist" )              unless -e $file;
  	return $class->_error( "'$file' is a directory, not a file" )       unless -f _;
  	return $class->_error( "Insufficient permissions to read '$file'" ) unless -r _;
  
  	# Slurp in the file
  	local $/ = undef;
  	local *CFG;
  	unless ( open(CFG, $file) ) {
  		return $class->_error("Failed to open file '$file': $!");
  	}
  	my $contents = <CFG>;
  	unless ( close(CFG) ) {
  		return $class->_error("Failed to close file '$file': $!");
  	}
  
  	$class->read_string( $contents );
  }
  
  # Create an object from a string
  sub read_string {
  	my $class  = ref $_[0] ? ref shift : shift;
  	my $self   = bless [], $class;
  	my $string = $_[0];
  	eval {
  		unless ( defined $string ) {
  			die \"Did not provide a string to load";
  		}
  
  		# Byte order marks
  		# NOTE: Keeping this here to educate maintainers
  		# my %BOM = (
  		#     "\357\273\277" => 'UTF-8',
  		#     "\376\377"     => 'UTF-16BE',
  		#     "\377\376"     => 'UTF-16LE',
  		#     "\377\376\0\0" => 'UTF-32LE'
  		#     "\0\0\376\377" => 'UTF-32BE',
  		# );
  		if ( $string =~ /^(?:\376\377|\377\376|\377\376\0\0|\0\0\376\377)/ ) {
  			die \"Stream has a non UTF-8 BOM";
  		} else {
  			# Strip UTF-8 bom if found, we'll just ignore it
  			$string =~ s/^\357\273\277//;
  		}
  
  		# Try to decode as utf8
  		utf8::decode($string) if HAVE_UTF8;
  
  		# Check for some special cases
  		return $self unless length $string;
  		unless ( $string =~ /[\012\015]+\z/ ) {
  			die \"Stream does not end with newline character";
  		}
  
  		# Split the file into lines
  		my @lines = grep { ! /^\s*(?:\#.*)?\z/ }
  			    split /(?:\015{1,2}\012|\015|\012)/, $string;
  
  		# Strip the initial YAML header
  		@lines and $lines[0] =~ /^\%YAML[: ][\d\.]+.*\z/ and shift @lines;
  
  		# A nibbling parser
  		while ( @lines ) {
  			# Do we have a document header?
  			if ( $lines[0] =~ /^---\s*(?:(.+)\s*)?\z/ ) {
  				# Handle scalar documents
  				shift @lines;
  				if ( defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/ ) {
  					push @$self, $self->_read_scalar( "$1", [ undef ], \@lines );
  					next;
  				}
  			}
  
  			if ( ! @lines or $lines[0] =~ /^(?:---|\.\.\.)/ ) {
  				# A naked document
  				push @$self, undef;
  				while ( @lines and $lines[0] !~ /^---/ ) {
  					shift @lines;
  				}
  
  			} elsif ( $lines[0] =~ /^\s*\-/ ) {
  				# An array at the root
  				my $document = [ ];
  				push @$self, $document;
  				$self->_read_array( $document, [ 0 ], \@lines );
  
  			} elsif ( $lines[0] =~ /^(\s*)\S/ ) {
  				# A hash at the root
  				my $document = { };
  				push @$self, $document;
  				$self->_read_hash( $document, [ length($1) ], \@lines );
  
  			} else {
  				die \"YAML::Tiny failed to classify the line '$lines[0]'";
  			}
  		}
  	};
  	if ( ref $@ eq 'SCALAR' ) {
  		return $self->_error(${$@});
  	} elsif ( $@ ) {
  		require Carp;
  		Carp::croak($@);
  	}
  
  	return $self;
  }
  
  # Deparse a scalar string to the actual scalar
  sub _read_scalar {
  	my ($self, $string, $indent, $lines) = @_;
  
  	# Trim trailing whitespace
  	$string =~ s/\s*\z//;
  
  	# Explitic null/undef
  	return undef if $string eq '~';
  
  	# Single quote
  	if ( $string =~ /^\'(.*?)\'(?:\s+\#.*)?\z/ ) {
  		return '' unless defined $1;
  		$string = $1;
  		$string =~ s/\'\'/\'/g;
  		return $string;
  	}
  
  	# Double quote.
  	# The commented out form is simpler, but overloaded the Perl regex
  	# engine due to recursion and backtracking problems on strings
  	# larger than 32,000ish characters. Keep it for reference purposes.
  	# if ( $string =~ /^\"((?:\\.|[^\"])*)\"\z/ ) {
  	if ( $string =~ /^\"([^\\"]*(?:\\.[^\\"]*)*)\"(?:\s+\#.*)?\z/ ) {
  		# Reusing the variable is a little ugly,
  		# but avoids a new variable and a string copy.
  		$string = $1;
  		$string =~ s/\\"/"/g;
  		$string =~ s/\\([never\\fartz]|x([0-9a-fA-F]{2}))/(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}/gex;
  		return $string;
  	}
  
  	# Special cases
  	if ( $string =~ /^[\'\"!&]/ ) {
  		die \"YAML::Tiny does not support a feature in line '$string'";
  	}
  	return {} if $string =~ /^{}(?:\s+\#.*)?\z/;
  	return [] if $string =~ /^\[\](?:\s+\#.*)?\z/;
  
  	# Regular unquoted string
  	if ( $string !~ /^[>|]/ ) {
  		if (
  			$string =~ /^(?:-(?:\s|$)|[\@\%\`])/
  			or
  			$string =~ /:(?:\s|$)/
  		) {
  			die \"YAML::Tiny found illegal characters in plain scalar: '$string'";
  		}
  		$string =~ s/\s+#.*\z//;
  		return $string;
  	}
  
  	# Error
  	die \"YAML::Tiny failed to find multi-line scalar content" unless @$lines;
  
  	# Check the indent depth
  	$lines->[0]   =~ /^(\s*)/;
  	$indent->[-1] = length("$1");
  	if ( defined $indent->[-2] and $indent->[-1] <= $indent->[-2] ) {
  		die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
  	}
  
  	# Pull the lines
  	my @multiline = ();
  	while ( @$lines ) {
  		$lines->[0] =~ /^(\s*)/;
  		last unless length($1) >= $indent->[-1];
  		push @multiline, substr(shift(@$lines), length($1));
  	}
  
  	my $j = (substr($string, 0, 1) eq '>') ? ' ' : "\n";
  	my $t = (substr($string, 1, 1) eq '-') ? ''  : "\n";
  	return join( $j, @multiline ) . $t;
  }
  
  # Parse an array
  sub _read_array {
  	my ($self, $array, $indent, $lines) = @_;
  
  	while ( @$lines ) {
  		# Check for a new document
  		if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
  			while ( @$lines and $lines->[0] !~ /^---/ ) {
  				shift @$lines;
  			}
  			return 1;
  		}
  
  		# Check the indent level
  		$lines->[0] =~ /^(\s*)/;
  		if ( length($1) < $indent->[-1] ) {
  			return 1;
  		} elsif ( length($1) > $indent->[-1] ) {
  			die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
  		}
  
  		if ( $lines->[0] =~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/ ) {
  			# Inline nested hash
  			my $indent2 = length("$1");
  			$lines->[0] =~ s/-/ /;
  			push @$array, { };
  			$self->_read_hash( $array->[-1], [ @$indent, $indent2 ], $lines );
  
  		} elsif ( $lines->[0] =~ /^\s*\-(\s*)(.+?)\s*\z/ ) {
  			# Array entry with a value
  			shift @$lines;
  			push @$array, $self->_read_scalar( "$2", [ @$indent, undef ], $lines );
  
  		} elsif ( $lines->[0] =~ /^\s*\-\s*\z/ ) {
  			shift @$lines;
  			unless ( @$lines ) {
  				push @$array, undef;
  				return 1;
  			}
  			if ( $lines->[0] =~ /^(\s*)\-/ ) {
  				my $indent2 = length("$1");
  				if ( $indent->[-1] == $indent2 ) {
  					# Null array entry
  					push @$array, undef;
  				} else {
  					# Naked indenter
  					push @$array, [ ];
  					$self->_read_array( $array->[-1], [ @$indent, $indent2 ], $lines );
  				}
  
  			} elsif ( $lines->[0] =~ /^(\s*)\S/ ) {
  				push @$array, { };
  				$self->_read_hash( $array->[-1], [ @$indent, length("$1") ], $lines );
  
  			} else {
  				die \"YAML::Tiny failed to classify line '$lines->[0]'";
  			}
  
  		} elsif ( defined $indent->[-2] and $indent->[-1] == $indent->[-2] ) {
  			# This is probably a structure like the following...
  			# ---
  			# foo:
  			# - list
  			# bar: value
  			#
  			# ... so lets return and let the hash parser handle it
  			return 1;
  
  		} else {
  			die \"YAML::Tiny failed to classify line '$lines->[0]'";
  		}
  	}
  
  	return 1;
  }
  
  # Parse an array
  sub _read_hash {
  	my ($self, $hash, $indent, $lines) = @_;
  
  	while ( @$lines ) {
  		# Check for a new document
  		if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
  			while ( @$lines and $lines->[0] !~ /^---/ ) {
  				shift @$lines;
  			}
  			return 1;
  		}
  
  		# Check the indent level
  		$lines->[0] =~ /^(\s*)/;
  		if ( length($1) < $indent->[-1] ) {
  			return 1;
  		} elsif ( length($1) > $indent->[-1] ) {
  			die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
  		}
  
  		# Get the key
  		unless ( $lines->[0] =~ s/^\s*([^\'\" ][^\n]*?)\s*:(\s+(?:\#.*)?|$)// ) {
  			if ( $lines->[0] =~ /^\s*[?\'\"]/ ) {
  				die \"YAML::Tiny does not support a feature in line '$lines->[0]'";
  			}
  			die \"YAML::Tiny failed to classify line '$lines->[0]'";
  		}
  		my $key = $1;
  
  		# Do we have a value?
  		if ( length $lines->[0] ) {
  			# Yes
  			$hash->{$key} = $self->_read_scalar( shift(@$lines), [ @$indent, undef ], $lines );
  		} else {
  			# An indent
  			shift @$lines;
  			unless ( @$lines ) {
  				$hash->{$key} = undef;
  				return 1;
  			}
  			if ( $lines->[0] =~ /^(\s*)-/ ) {
  				$hash->{$key} = [];
  				$self->_read_array( $hash->{$key}, [ @$indent, length($1) ], $lines );
  			} elsif ( $lines->[0] =~ /^(\s*)./ ) {
  				my $indent2 = length("$1");
  				if ( $indent->[-1] >= $indent2 ) {
  					# Null hash entry
  					$hash->{$key} = undef;
  				} else {
  					$hash->{$key} = {};
  					$self->_read_hash( $hash->{$key}, [ @$indent, length($1) ], $lines );
  				}
  			}
  		}
  	}
  
  	return 1;
  }
  
  # Save an object to a file
  sub write {
  	my $self = shift;
  	my $file = shift or return $self->_error('No file name provided');
  
  	# Write it to the file
  	open( CFG, '>' . $file ) or return $self->_error(
  		"Failed to open file '$file' for writing: $!"
  		);
  	print CFG $self->write_string;
  	close CFG;
  
  	return 1;
  }
  
  # Save an object to a string
  sub write_string {
  	my $self = shift;
  	return '' unless @$self;
  
  	# Iterate over the documents
  	my $indent = 0;
  	my @lines  = ();
  	foreach my $cursor ( @$self ) {
  		push @lines, '---';
  
  		# An empty document
  		if ( ! defined $cursor ) {
  			# Do nothing
  
  		# A scalar document
  		} elsif ( ! ref $cursor ) {
  			$lines[-1] .= ' ' . $self->_write_scalar( $cursor, $indent );
  
  		# A list at the root
  		} elsif ( ref $cursor eq 'ARRAY' ) {
  			unless ( @$cursor ) {
  				$lines[-1] .= ' []';
  				next;
  			}
  			push @lines, $self->_write_array( $cursor, $indent, {} );
  
  		# A hash at the root
  		} elsif ( ref $cursor eq 'HASH' ) {
  			unless ( %$cursor ) {
  				$lines[-1] .= ' {}';
  				next;
  			}
  			push @lines, $self->_write_hash( $cursor, $indent, {} );
  
  		} else {
  			Carp::croak("Cannot serialize " . ref($cursor));
  		}
  	}
  
  	join '', map { "$_\n" } @lines;
  }
  
  sub _write_scalar {
  	my $string = $_[1];
  	return '~'  unless defined $string;
  	return "''" unless length  $string;
  	if ( $string =~ /[\x00-\x08\x0b-\x0d\x0e-\x1f\"\'\n]/ ) {
  		$string =~ s/\\/\\\\/g;
  		$string =~ s/"/\\"/g;
  		$string =~ s/\n/\\n/g;
  		$string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;
  		return qq|"$string"|;
  	}
  	if ( $string =~ /(?:^\W|\s|:\z)/ or $QUOTE{$string} ) {
  		return "'$string'";
  	}
  	return $string;
  }
  
  sub _write_array {
  	my ($self, $array, $indent, $seen) = @_;
  	if ( $seen->{refaddr($array)}++ ) {
  		die "YAML::Tiny does not support circular references";
  	}
  	my @lines  = ();
  	foreach my $el ( @$array ) {
  		my $line = ('  ' x $indent) . '-';
  		my $type = ref $el;
  		if ( ! $type ) {
  			$line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
  			push @lines, $line;
  
  		} elsif ( $type eq 'ARRAY' ) {
  			if ( @$el ) {
  				push @lines, $line;
  				push @lines, $self->_write_array( $el, $indent + 1, $seen );
  			} else {
  				$line .= ' []';
  				push @lines, $line;
  			}
  
  		} elsif ( $type eq 'HASH' ) {
  			if ( keys %$el ) {
  				push @lines, $line;
  				push @lines, $self->_write_hash( $el, $indent + 1, $seen );
  			} else {
  				$line .= ' {}';
  				push @lines, $line;
  			}
  
  		} else {
  			die "YAML::Tiny does not support $type references";
  		}
  	}
  
  	@lines;
  }
  
  sub _write_hash {
  	my ($self, $hash, $indent, $seen) = @_;
  	if ( $seen->{refaddr($hash)}++ ) {
  		die "YAML::Tiny does not support circular references";
  	}
  	my @lines  = ();
  	foreach my $name ( sort keys %$hash ) {
  		my $el   = $hash->{$name};
  		my $line = ('  ' x $indent) . "$name:";
  		my $type = ref $el;
  		if ( ! $type ) {
  			$line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
  			push @lines, $line;
  
  		} elsif ( $type eq 'ARRAY' ) {
  			if ( @$el ) {
  				push @lines, $line;
  				push @lines, $self->_write_array( $el, $indent + 1, $seen );
  			} else {
  				$line .= ' []';
  				push @lines, $line;
  			}
  
  		} elsif ( $type eq 'HASH' ) {
  			if ( keys %$el ) {
  				push @lines, $line;
  				push @lines, $self->_write_hash( $el, $indent + 1, $seen );
  			} else {
  				$line .= ' {}';
  				push @lines, $line;
  			}
  
  		} else {
  			die "YAML::Tiny does not support $type references";
  		}
  	}
  
  	@lines;
  }
  
  # Set error
  sub _error {
  	$YAML::Tiny::errstr = $_[1];
  	undef;
  }
  
  # Retrieve error
  sub errstr {
  	$YAML::Tiny::errstr;
  }
  
  
  
  
  
  #####################################################################
  # YAML Compatibility
  
  sub Dump {
  	YAML::Tiny->new(@_)->write_string;
  }
  
  sub Load {
  	my $self = YAML::Tiny->read_string(@_);
  	unless ( $self ) {
  		Carp::croak("Failed to load YAML document from string");
  	}
  	if ( wantarray ) {
  		return @$self;
  	} else {
  		# To match YAML.pm, return the last document
  		return $self->[-1];
  	}
  }
  
  BEGIN {
  	*freeze = *Dump;
  	*thaw   = *Load;
  }
  
  sub DumpFile {
  	my $file = shift;
  	YAML::Tiny->new(@_)->write($file);
  }
  
  sub LoadFile {
  	my $self = YAML::Tiny->read($_[0]);
  	unless ( $self ) {
  		Carp::croak("Failed to load YAML document from '" . ($_[0] || '') . "'");
  	}
  	if ( wantarray ) {
  		return @$self;
  	} else {
  		# Return only the last document to match YAML.pm, 
  		return $self->[-1];
  	}
  }
  
  
  
  
  
  #####################################################################
  # Use Scalar::Util if possible, otherwise emulate it
  
  BEGIN {
  	local $@;
  	eval {
  		require Scalar::Util;
  	};
  	if ( $@ or $Scalar::Util::VERSION < 1.18 ) {
  		eval <<'END_PERL' if $@;
  # Scalar::Util failed to load or too old
  sub refaddr {
  	my $pkg = ref($_[0]) or return undef;
  	if ( !! UNIVERSAL::can($_[0], 'can') ) {
  		bless $_[0], 'Scalar::Util::Fake';
  	} else {
  		$pkg = undef;
  	}
  	"$_[0]" =~ /0x(\w+)/;
  	my $i = do { local $^W; hex $1 };
  	bless $_[0], $pkg if defined $pkg;
  	$i;
  }
  END_PERL
  	} else {
  		*refaddr = *Scalar::Util::refaddr;
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  YAML::Tiny - Read/Write YAML files with as little code as possible
  
  =head1 PREAMBLE
  
  The YAML specification is huge. Really, B<really> huge. It contains all the
  functionality of XML, except with flexibility and choice, which makes it
  easier to read, but with a formal specification that is more complex than
  XML.
  
  The original pure-Perl implementation L<YAML> costs just over 4 megabytes
  of memory to load. Just like with Windows .ini files (3 meg to load) and
  CSS (3.5 meg to load) the situation is just asking for a B<YAML::Tiny>
  module, an incomplete but correct and usable subset of the functionality,
  in as little code as possible.
  
  Like the other C<::Tiny> modules, YAML::Tiny has no non-core dependencies,
  does not require a compiler to install, is back-compatible to Perl 5.004,
  and can be inlined into other modules if needed.
  
  In exchange for this adding this extreme flexibility, it provides support
  for only a limited subset of YAML. But the subset supported contains most
  of the features for the more common usese of YAML.
  
  =head1 SYNOPSIS
  
      #############################################
      # In your file
      
      ---
      rootproperty: blah
      section:
        one: two
        three: four
        Foo: Bar
        empty: ~
      
      
      
      #############################################
      # In your program
      
      use YAML::Tiny;
      
      # Create a YAML file
      my $yaml = YAML::Tiny->new;
      
      # Open the config
      $yaml = YAML::Tiny->read( 'file.yml' );
      
      # Reading properties
      my $root = $yaml->[0]->{rootproperty};
      my $one  = $yaml->[0]->{section}->{one};
      my $Foo  = $yaml->[0]->{section}->{Foo};
      
      # Changing data
      $yaml->[0]->{newsection} = { this => 'that' }; # Add a section
      $yaml->[0]->{section}->{Foo} = 'Not Bar!';     # Change a value
      delete $yaml->[0]->{section};                  # Delete a value
      
      # Add an entire document
      $yaml->[1] = [ 'foo', 'bar', 'baz' ];
      
      # Save the file
      $yaml->write( 'file.conf' );
  
  =head1 DESCRIPTION
  
  B<YAML::Tiny> is a perl class for reading and writing YAML-style files,
  written with as little code as possible, reducing load time and memory
  overhead.
  
  Most of the time it is accepted that Perl applications use a lot
  of memory and modules. The B<::Tiny> family of modules is specifically
  intended to provide an ultralight and zero-dependency alternative to
  many more-thorough standard modules.
  
  This module is primarily for reading human-written files (like simple
  config files) and generating very simple human-readable files. Note that
  I said B<human-readable> and not B<geek-readable>. The sort of files that
  your average manager or secretary should be able to look at and make
  sense of.
  
  L<YAML::Tiny> does not generate comments, it won't necesarily preserve the
  order of your hashes, and it will normalise if reading in and writing out
  again.
  
  It only supports a very basic subset of the full YAML specification.
  
  Usage is targetted at files like Perl's META.yml, for which a small and
  easily-embeddable module is extremely attractive.
  
  Features will only be added if they are human readable, and can be written
  in a few lines of code. Please don't be offended if your request is
  refused. Someone has to draw the line, and for YAML::Tiny that someone
  is me.
  
  If you need something with more power move up to L<YAML> (4 megabytes of
  memory overhead) or L<YAML::Syck> (275k, but requires libsyck and a C
  compiler).
  
  To restate, L<YAML::Tiny> does B<not> preserve your comments, whitespace,
  or the order of your YAML data. But it should round-trip from Perl
  structure to file and back again just fine.
  
  =head1 YAML TINY SPECIFICATION
  
  This section of the documentation provides a specification for "YAML Tiny",
  a subset of the YAML specification.
  
  It is based on and described comparatively to the YAML 1.1 Working Draft
  2004-12-28 specification, located at L<http://yaml.org/spec/current.html>.
  
  Terminology and chapter numbers are based on that specification.
  
  =head2 1. Introduction and Goals
  
  The purpose of the YAML Tiny specification is to describe a useful subset
  of the YAML specification that can be used for typical document-oriented
  use cases such as configuration files and simple data structure dumps.
  
  Many specification elements that add flexibility or extensibility are
  intentionally removed, as is support for complex datastructures, class
  and object-orientation.
  
  In general, the YAML Tiny language targets only those data structures
  available in JSON, with the additional limitation that only simple keys
  are supported.
  
  As a result, all possible YAML Tiny documents should be able to be
  transformed into an equivalent JSON document, although the reverse is
  not necesarily true (but will be true in simple cases).
  
  As a result of these simplifications the YAML Tiny specification should
  be implementable in a (relatively) small amount of code in any language
  that supports Perl Compatible Regular Expressions (PCRE).
  
  =head2 2. Introduction
  
  YAML Tiny supports three data structures. These are scalars (in a variety
  of forms), block-form sequences and block-form mappings. Flow-style
  sequences and mappings are not supported, with some minor exceptions
  detailed later.
  
  The use of three dashes "---" to indicate the start of a new document is
  supported, and multiple documents per file/stream is allowed.
  
  Both line and inline comments are supported.
  
  Scalars are supported via the plain style, single quote and double quote,
  as well as literal-style and folded-style multi-line scalars.
  
  The use of explicit tags is not supported.
  
  The use of "null" type scalars is supported via the ~ character.
  
  The use of "bool" type scalars is not supported.
  
  However, serializer implementations should take care to explicitly escape
  strings that match a "bool" keyword in the following set to prevent other
  implementations that do support "bool" accidentally reading a string as a
  boolean
  
    y|Y|yes|Yes|YES|n|N|no|No|NO
    |true|True|TRUE|false|False|FALSE
    |on|On|ON|off|Off|OFF
  
  The use of anchors and aliases is not supported.
  
  The use of directives is supported only for the %YAML directive.
  
  =head2 3. Processing YAML Tiny Information
  
  B<Processes>
  
  The YAML specification dictates three-phase serialization and three-phase
  deserialization.
  
  The YAML Tiny specification does not mandate any particular methodology
  or mechanism for parsing.
  
  Any compliant parser is only required to parse a single document at a
  time. The ability to support streaming documents is optional and most
  likely non-typical.
  
  Because anchors and aliases are not supported, the resulting representation
  graph is thus directed but (unlike the main YAML specification) B<acyclic>.
  
  Circular references/pointers are not possible, and any YAML Tiny serializer
  detecting a circular reference should error with an appropriate message.
  
  B<Presentation Stream>
  
  YAML Tiny is notionally unicode, but support for unicode is required if the
  underlying language or system being used to implement a parser does not
  support Unicode. If unicode is encountered in this case an error should be
  returned.
  
  B<Loading Failure Points>
  
  YAML Tiny parsers and emitters are not expected to recover from adapt to
  errors. The specific error modality of any implementation is not dictated
  (return codes, exceptions, etc) but is expected to be consistant.
  
  =head2 4. Syntax
  
  B<Character Set>
  
  YAML Tiny streams are implemented primarily using the ASCII character set,
  although the use of Unicode inside strings is allowed if support by the
  implementation.
  
  Specific YAML Tiny encoded document types aiming for maximum compatibility
  should restrict themselves to ASCII.
  
  The escaping and unescaping of the 8-bit YAML escapes is required.
  
  The escaping and unescaping of 16-bit and 32-bit YAML escapes is not
  required.
  
  B<Indicator Characters>
  
  Support for the "~" null/undefined indicator is required.
  
  Implementations may represent this as appropriate for the underlying
  language.
  
  Support for the "-" block sequence indicator is required.
  
  Support for the "?" mapping key indicator is B<not> required.
  
  Support for the ":" mapping value indicator is required.
  
  Support for the "," flow collection indicator is B<not> required.
  
  Support for the "[" flow sequence indicator is B<not> required, with
  one exception (detailed below).
  
  Support for the "]" flow sequence indicator is B<not> required, with
  one exception (detailed below).
  
  Support for the "{" flow mapping indicator is B<not> required, with
  one exception (detailed below).
  
  Support for the "}" flow mapping indicator is B<not> required, with
  one exception (detailed below).
  
  Support for the "#" comment indicator is required.
  
  Support for the "&" anchor indicator is B<not> required.
  
  Support for the "*" alias indicator is B<not> required.
  
  Support for the "!" tag indicator is B<not> required.
  
  Support for the "|" literal block indicator is required.
  
  Support for the ">" folded block indicator is required.
  
  Support for the "'" single quote indicator is required.
  
  Support for the """ double quote indicator is required.
  
  Support for the "%" directive indicator is required, but only
  for the special case of a %YAML version directive before the
  "---" document header, or on the same line as the document header.
  
  For example:
  
    %YAML 1.1
    ---
    - A sequence with a single element
  
  Special Exception:
  
  To provide the ability to support empty sequences
  and mappings, support for the constructs [] (empty sequence) and {}
  (empty mapping) are required.
  
  For example, 
    
    %YAML 1.1
    # A document consisting of only an empty mapping
    --- {}
    # A document consisting of only an empty sequence
    --- []
    # A document consisting of an empty mapping within a sequence
    - foo
    - {}
    - bar
  
  B<Syntax Primitives>
  
  Other than the empty sequence and mapping cases described above, YAML Tiny
  supports only the indentation-based block-style group of contexts.
  
  All five scalar contexts are supported.
  
  Indentation spaces work as per the YAML specification in all cases.
  
  Comments work as per the YAML specification in all simple cases.
  Support for indented multi-line comments is B<not> required.
  
  Seperation spaces work as per the YAML specification in all cases.
  
  B<YAML Tiny Character Stream>
  
  The only directive supported by the YAML Tiny specification is the
  %YAML language/version identifier. Although detected, this directive
  will have no control over the parsing itself.
  
  The parser must recognise both the YAML 1.0 and YAML 1.1+ formatting
  of this directive (as well as the commented form, although no explicit
  code should be needed to deal with this case, being a comment anyway)
  
  That is, all of the following should be supported.
  
    --- #YAML:1.0
    - foo
  
    %YAML:1.0
    ---
    - foo
  
    % YAML 1.1
    ---
    - foo
  
  Support for the %TAG directive is B<not> required.
  
  Support for additional directives is B<not> required.
  
  Support for the document boundary marker "---" is required.
  
  Support for the document boundary market "..." is B<not> required.
  
  If necesary, a document boundary should simply by indicated with a
  "---" marker, with not preceding "..." marker.
  
  Support for empty streams (containing no documents) is required.
  
  Support for implicit document starts is required.
  
  That is, the following must be equivalent.
  
   # Full form
   %YAML 1.1
   ---
   foo: bar
  
   # Implicit form
   foo: bar
  
  B<Nodes>
  
  Support for nodes optional anchor and tag properties are B<not> required.
  
  Support for node anchors is B<not> required.
  
  Support for node tags is B<not> required.
  
  Support for alias nodes is B<not> required.
  
  Support for flow nodes is B<not> required.
  
  Support for block nodes is required.
  
  B<Scalar Styles>
  
  Support for all five scalar styles are required as per the YAML
  specification, although support for quoted scalars spanning more
  than one line is B<not> required.
  
  Support for the chomping indicators on multi-line scalar styles
  is required.
  
  B<Collection Styles>
  
  Support for block-style sequences is required.
  
  Support for flow-style sequences is B<not> required.
  
  Support for block-style mappings is required.
  
  Support for flow-style mappings is B<not> required.
  
  Both sequences and mappings should be able to be arbitrarily
  nested.
  
  Support for plain-style mapping keys is required.
  
  Support for quoted keys in mappings is B<not> required.
  
  Support for "?"-indicated explicit keys is B<not> required.
  
  Here endeth the specification.
  
  =head2 Additional Perl-Specific Notes
  
  For some Perl applications, it's important to know if you really have a
  number and not a string.
  
  That is, in some contexts is important that 3 the number is distinctive
  from "3" the string.
  
  Because even Perl itself is not trivially able to understand the difference
  (certainly without XS-based modules) Perl implementations of the YAML Tiny
  specification are not required to retain the distinctiveness of 3 vs "3".
  
  =head1 METHODS
  
  =head2 new
  
  The constructor C<new> creates and returns an empty C<YAML::Tiny> object.
  
  =head2 read $filename
  
  The C<read> constructor reads a YAML file from a file name,
  and returns a new C<YAML::Tiny> object containing the parsed content.
  
  Returns the object on success, or C<undef> on error.
  
  When C<read> fails, C<YAML::Tiny> sets an error message internally
  you can recover via C<YAML::Tiny-E<gt>errstr>. Although in B<some>
  cases a failed C<read> will also set the operating system error
  variable C<$!>, not all errors do and you should not rely on using
  the C<$!> variable.
  
  =head2 read_string $string;
  
  The C<read> constructor reads a YAML file from a file name,
  and returns a new C<YAML::Tiny> object containing the parsed content.
  
  Returns the object on success, or C<undef> on error.
  
  =head2 write $filename
  
  The C<write> method generates the file content for the properties, and
  writes it to disk to the filename specified.
  
  Returns true on success or C<undef> on error.
  
  =head2 write_string
  
  Generates the file content for the object and returns it as a string.
  
  =head2 errstr
  
  When an error occurs, you can retrieve the error message either from the
  C<$YAML::Tiny::errstr> variable, or using the C<errstr()> method.
  
  =head1 FUNCTIONS
  
  YAML::Tiny implements a number of functions to add compatibility with
  the L<YAML> API. These should be a drop-in replacement, except that
  YAML::Tiny will B<not> export functions by default, and so you will need
  to explicitly import the functions.
  
  =head2 Dump
  
    my $string = Dump(list-of-Perl-data-structures);
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper().
  
  It takes a list of Perl data strucures and dumps them into a serialized
  form.
  
  It returns a string containing the YAML stream.
  
  The structures can be references or plain scalars.
  
  =head2 Load
  
    my @documents = Load(string-containing-a-YAML-stream);
  
  Turn YAML into Perl data. This is the opposite of Dump.
  
  Just like L<Storable>'s thaw() function or the eval() function in relation
  to L<Data::Dumper>.
  
  It parses a string containing a valid YAML stream into a list of Perl data
  structures.
  
  =head2 freeze() and thaw()
  
  Aliases to Dump() and Load() for L<Storable> fans. This will also allow
  YAML::Tiny to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =head2 DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =head2 LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=YAML-Tiny>
  
  =begin html
  
  For other issues, or commercial enhancement or support, please contact
  <a href="http://ali.as/">Adam Kennedy</a> directly.
  
  =end html
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<YAML>, L<YAML::Syck>, L<Config::Tiny>, L<CSS::Tiny>,
  L<http://use.perl.org/~Alias/journal/29427>, L<http://ali.as/>
  
  =head1 COPYRIGHT
  
  Copyright 2006 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
YAML_TINY

$fatpacked{"darwin-2level/Cwd.pm"} = <<'DARWIN-2LEVEL_CWD';
  package Cwd;
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
  
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.40';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  eval {
    if ( $] >= 5.006 ) {
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
    } else {
      require DynaLoader;
      push @ISA, 'DynaLoader';
      __PACKAGE__->bootstrap( $xs_version );
    }
  };
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  foreach my $try ('/bin/pwd',
  		 '/usr/bin/pwd',
  		 '/QOpenSys/bin/pwd', # OS/400 PASE.
  		) {
  
      if( -x $try ) {
          $pwd_cmd = $try;
          last;
      }
  }
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if somenone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
      # Localize %ENV entries in a way that won't create new hash keys
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
      local @ENV{@localize};
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      $ENV{'PWD'} = `cmd /c cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd_simple {
      $ENV{'PWD'} = `cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd {
      # Need to avoid taking any sort of reference to the typeglob or the code in
      # the optree, so that this tests the runtime state of things, as the
      # ExtUtils::MakeMaker tests for "miniperl" need to be able to fake things at
      # runtime by deleting the subroutine. *foo{THING} syntax on a symbol table
      # lookup avoids needing a string eval, which has been reported to cause
      # problems (for reasons that we haven't been able to get to the bottom of -
      # rt.cpan.org #56225)
      if (*{$DynaLoader::{boot_DynaLoader}}{CODE}) {
  	$ENV{'PWD'} = Win32::GetCwd();
      }
      else { # miniperl
  	chomp($ENV{'PWD'} = `cd`);
      }
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      if (!defined &Dos::GetCwd) {
          $ENV{'PWD'} = `command /c cd`;
          chomp $ENV{'PWD'};
          $ENV{'PWD'} =~ s:\\:/:g ;
      } else {
          $ENV{'PWD'} = Dos::GetCwd();
      }
      return $ENV{'PWD'};
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      $ENV{'PWD'} = `/usr/bin/fullpath -t`;
      chomp $ENV{'PWD'};
      return $ENV{'PWD'};
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      $ENV{'PWD'} = EPOC::getcwd();
      return $ENV{'PWD'};
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
DARWIN-2LEVEL_CWD

$fatpacked{"darwin-2level/Data/Dumper.pm"} = <<'DARWIN-2LEVEL_DATA_DUMPER';
  #
  # Data/Dumper.pm
  #
  # convert perl data structures into perl syntax suitable for both printing
  # and eval
  #
  # Documentation at the __END__
  #
  
  package Data::Dumper;
  
  $VERSION = '2.131'; # Don't forget to set version and release date in POD!
  
  #$| = 1;
  
  use 5.006_001;
  require Exporter;
  require overload;
  
  use Carp;
  
  BEGIN {
      @ISA = qw(Exporter);
      @EXPORT = qw(Dumper);
      @EXPORT_OK = qw(DumperX);
  
      # if run under miniperl, or otherwise lacking dynamic loading,
      # XSLoader should be attempted to load, or the pure perl flag
      # toggled on load failure.
      eval {
  	require XSLoader;
      };
      $Useperl = 1 if $@;
  }
  
  XSLoader::load( 'Data::Dumper' ) unless $Useperl;
  
  # module vars and their defaults
  $Indent     = 2         unless defined $Indent;
  $Purity     = 0         unless defined $Purity;
  $Pad        = ""        unless defined $Pad;
  $Varname    = "VAR"     unless defined $Varname;
  $Useqq      = 0         unless defined $Useqq;
  $Terse      = 0         unless defined $Terse;
  $Freezer    = ""        unless defined $Freezer;
  $Toaster    = ""        unless defined $Toaster;
  $Deepcopy   = 0         unless defined $Deepcopy;
  $Quotekeys  = 1         unless defined $Quotekeys;
  $Bless      = "bless"   unless defined $Bless;
  #$Expdepth   = 0         unless defined $Expdepth;
  $Maxdepth   = 0         unless defined $Maxdepth;
  $Pair       = ' => '    unless defined $Pair;
  $Useperl    = 0         unless defined $Useperl;
  $Sortkeys   = 0         unless defined $Sortkeys;
  $Deparse    = 0         unless defined $Deparse;
  
  #
  # expects an arrayref of values to be dumped.
  # can optionally pass an arrayref of names for the values.
  # names must have leading $ sign stripped. begin the name with *
  # to cause output of arrays and hashes rather than refs.
  #
  sub new {
    my($c, $v, $n) = @_;
  
    croak "Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])" 
      unless (defined($v) && (ref($v) eq 'ARRAY'));
    $n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));
  
    my($s) = { 
               level      => 0,           # current recursive depth
  	     indent     => $Indent,     # various styles of indenting
  	     pad	=> $Pad,        # all lines prefixed by this string
  	     xpad       => "",          # padding-per-level
  	     apad       => "",          # added padding for hash keys n such
  	     sep        => "",          # list separator
  	     pair	=> $Pair,	# hash key/value separator: defaults to ' => '
  	     seen       => {},          # local (nested) refs (id => [name, val])
  	     todump     => $v,          # values to dump []
  	     names      => $n,          # optional names for values []
  	     varname    => $Varname,    # prefix to use for tagging nameless ones
               purity     => $Purity,     # degree to which output is evalable
               useqq 	=> $Useqq,      # use "" for strings (backslashitis ensues)
               terse 	=> $Terse,      # avoid name output (where feasible)
               freezer	=> $Freezer,    # name of Freezer method for objects
               toaster	=> $Toaster,    # name of method to revive objects
               deepcopy	=> $Deepcopy,   # dont cross-ref, except to stop recursion
               quotekeys	=> $Quotekeys,  # quote hash keys
               'bless'	=> $Bless,	# keyword to use for "bless"
  #	     expdepth   => $Expdepth,   # cutoff depth for explicit dumping
  	     maxdepth	=> $Maxdepth,   # depth beyond which we give up
  	     useperl    => $Useperl,    # use the pure Perl implementation
  	     sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys
  	     deparse	=> $Deparse,	# use B::Deparse for coderefs
  	   };
  
    if ($Indent > 0) {
      $s->{xpad} = "  ";
      $s->{sep} = "\n";
    }
    return bless($s, $c);
  }
  
  if ($] >= 5.008) {
    # Packed numeric addresses take less memory. Plus pack is faster than sprintf
    *init_refaddr_format = sub {};
  
    *format_refaddr  = sub {
      require Scalar::Util;
      pack "J", Scalar::Util::refaddr(shift);
    };
  } else {
    *init_refaddr_format = sub {
      require Config;
      my $f = $Config::Config{uvxformat};
      $f =~ tr/"//d;
      our $refaddr_format = "0x%" . $f;
    };
  
    *format_refaddr = sub {
      require Scalar::Util;
      sprintf our $refaddr_format, Scalar::Util::refaddr(shift);
    }
  }
  
  #
  # add-to or query the table of already seen references
  #
  sub Seen {
    my($s, $g) = @_;
    if (defined($g) && (ref($g) eq 'HASH'))  {
      init_refaddr_format();
      my($k, $v, $id);
      while (($k, $v) = each %$g) {
        if (defined $v and ref $v) {
  	$id = format_refaddr($v);
  	if ($k =~ /^[*](.*)$/) {
  	  $k = (ref $v eq 'ARRAY') ? ( "\\\@" . $1 ) :
  	       (ref $v eq 'HASH')  ? ( "\\\%" . $1 ) :
  	       (ref $v eq 'CODE')  ? ( "\\\&" . $1 ) :
  				     (   "\$" . $1 ) ;
  	}
  	elsif ($k !~ /^\$/) {
  	  $k = "\$" . $k;
  	}
  	$s->{seen}{$id} = [$k, $v];
        }
        else {
  	carp "Only refs supported, ignoring non-ref item \$$k";
        }
      }
      return $s;
    }
    else {
      return map { @$_ } values %{$s->{seen}};
    }
  }
  
  #
  # set or query the values to be dumped
  #
  sub Values {
    my($s, $v) = @_;
    if (defined($v) && (ref($v) eq 'ARRAY'))  {
      $s->{todump} = [@$v];        # make a copy
      return $s;
    }
    else {
      return @{$s->{todump}};
    }
  }
  
  #
  # set or query the names of the values to be dumped
  #
  sub Names {
    my($s, $n) = @_;
    if (defined($n) && (ref($n) eq 'ARRAY'))  {
      $s->{names} = [@$n];         # make a copy
      return $s;
    }
    else {
      return @{$s->{names}};
    }
  }
  
  sub DESTROY {}
  
  sub Dump {
      return &Dumpxs
  	unless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl}) ||
  	       $Data::Dumper::Useqq   || (ref($_[0]) && $_[0]->{useqq}) ||
  	       $Data::Dumper::Deparse || (ref($_[0]) && $_[0]->{deparse});
      return &Dumpperl;
  }
  
  #
  # dump the refs in the current dumper object.
  # expects same args as new() if called via package name.
  #
  sub Dumpperl {
    my($s) = shift;
    my(@out, $val, $name);
    my($i) = 0;
    local(@post);
    init_refaddr_format();
  
    $s = $s->new(@_) unless ref $s;
  
    for $val (@{$s->{todump}}) {
      my $out = "";
      @post = ();
      $name = $s->{names}[$i++];
      if (defined $name) {
        if ($name =~ /^[*](.*)$/) {
  	if (defined $val) {
  	  $name = (ref $val eq 'ARRAY') ? ( "\@" . $1 ) :
  		  (ref $val eq 'HASH')  ? ( "\%" . $1 ) :
  		  (ref $val eq 'CODE')  ? ( "\*" . $1 ) :
  					  ( "\$" . $1 ) ;
  	}
  	else {
  	  $name = "\$" . $1;
  	}
        }
        elsif ($name !~ /^\$/) {
  	$name = "\$" . $name;
        }
      }
      else {
        $name = "\$" . $s->{varname} . $i;
      }
  
      my $valstr;
      {
        local($s->{apad}) = $s->{apad};
        $s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2 and !$s->{terse};
        $valstr = $s->_dump($val, $name);
      }
  
      $valstr = "$name = " . $valstr . ';' if @post or !$s->{terse};
      $out .= $s->{pad} . $valstr . $s->{sep};
      $out .= $s->{pad} . join(';' . $s->{sep} . $s->{pad}, @post) 
        . ';' . $s->{sep} if @post;
  
      push @out, $out;
    }
    return wantarray ? @out : join('', @out);
  }
  
  # wrap string in single quotes (escaping if needed)
  sub _quote {
      my $val = shift;
      $val =~ s/([\\\'])/\\$1/g;
      return  "'" . $val .  "'";
  }
  
  #
  # twist, toil and turn;
  # and recurse, of course.
  # sometimes sordidly;
  # and curse if no recourse.
  #
  sub _dump {
    my($s, $val, $name) = @_;
    my($sname);
    my($out, $realpack, $realtype, $type, $ipad, $id, $blesspad);
  
    $type = ref $val;
    $out = "";
  
    if ($type) {
  
      # Call the freezer method if it's specified and the object has the
      # method.  Trap errors and warn() instead of die()ing, like the XS
      # implementation.
      my $freezer = $s->{freezer};
      if ($freezer and UNIVERSAL::can($val, $freezer)) {
        eval { $val->$freezer() };
        warn "WARNING(Freezer method call failed): $@" if $@;
      }
  
      require Scalar::Util;
      $realpack = Scalar::Util::blessed($val);
      $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;
      $id = format_refaddr($val);
  
      # if it has a name, we need to either look it up, or keep a tab
      # on it so we know when we hit it later
      if (defined($name) and length($name)) {
        # keep a tab on it so that we dont fall into recursive pit
        if (exists $s->{seen}{$id}) {
  #	if ($s->{expdepth} < $s->{level}) {
  	  if ($s->{purity} and $s->{level} > 0) {
  	    $out = ($realtype eq 'HASH')  ? '{}' :
  	      ($realtype eq 'ARRAY') ? '[]' :
  		'do{my $o}' ;
  	    push @post, $name . " = " . $s->{seen}{$id}[0];
  	  }
  	  else {
  	    $out = $s->{seen}{$id}[0];
  	    if ($name =~ /^([\@\%])/) {
  	      my $start = $1;
  	      if ($out =~ /^\\$start/) {
  		$out = substr($out, 1);
  	      }
  	      else {
  		$out = $start . '{' . $out . '}';
  	      }
  	    }
            }
  	  return $out;
  #        }
        }
        else {
          # store our name
          $s->{seen}{$id} = [ (($name =~ /^[@%]/)     ? ('\\' . $name ) :
  			     ($realtype eq 'CODE' and
  			      $name =~ /^[*](.*)$/) ? ('\\&' . $1 )   :
  			     $name          ),
  			    $val ];
        }
      }
      my $no_bless = 0; 
      my $is_regex = 0;
      if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {
          $is_regex = 1;
          $no_bless = $realpack eq 'Regexp';
      }
  
      # If purity is not set and maxdepth is set, then check depth: 
      # if we have reached maximum depth, return the string
      # representation of the thing we are currently examining
      # at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)'). 
      if (!$s->{purity}
  	and $s->{maxdepth} > 0
  	and $s->{level} >= $s->{maxdepth})
      {
        return qq['$val'];
      }
  
      # we have a blessed ref
      if ($realpack and !$no_bless) {
        $out = $s->{'bless'} . '( ';
        $blesspad = $s->{apad};
        $s->{apad} .= '       ' if ($s->{indent} >= 2);
      }
  
      $s->{level}++;
      $ipad = $s->{xpad} x $s->{level};
  
      if ($is_regex) {
          my $pat;
          # This really sucks, re:regexp_pattern is in ext/re/re.xs and not in 
          # universal.c, and even worse we cant just require that re to be loaded
          # we *have* to use() it. 
          # We should probably move it to universal.c for 5.10.1 and fix this.
          # Currently we only use re::regexp_pattern when the re is blessed into another
          # package. This has the disadvantage of meaning that a DD dump won't round trip
          # as the pattern will be repeatedly wrapped with the same modifiers.
          # This is an aesthetic issue so we will leave it for now, but we could use
          # regexp_pattern() in list context to get the modifiers separately.
          # But since this means loading the full debugging engine in process we wont
          # bother unless its necessary for accuracy.
          if (($realpack ne 'Regexp') && defined(*re::regexp_pattern{CODE})) {
              $pat = re::regexp_pattern($val);
          } else {
              $pat = "$val";
          }
          $pat =~ s,/,\\/,g;
          $out .= "qr/$pat/";
      }
      elsif ($realtype eq 'SCALAR' || $realtype eq 'REF') {
        if ($realpack) {
  	$out .= 'do{\\(my $o = ' . $s->_dump($$val, "\${$name}") . ')}';
        }
        else {
  	$out .= '\\' . $s->_dump($$val, "\${$name}");
        }
      }
      elsif ($realtype eq 'GLOB') {
  	$out .= '\\' . $s->_dump($$val, "*{$name}");
      }
      elsif ($realtype eq 'ARRAY') {
        my($pad, $mname);
        my($i) = 0;
        $out .= ($name =~ /^\@/) ? '(' : '[';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        ($name =~ /^\@(.*)$/) ? ($mname = "\$" . $1) : 
  	# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
  	($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
  	  ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        for my $v (@$val) {
  	$sname = $mname . '[' . $i . ']';
  	$out .= $pad . $ipad . '#' . $i if $s->{indent} >= 3;
  	$out .= $pad . $ipad . $s->_dump($v, $sname);
  	$out .= "," if $i++ < $#$val;
        }
        $out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;
        $out .= ($name =~ /^\@/) ? ')' : ']';
      }
      elsif ($realtype eq 'HASH') {
        my($k, $v, $pad, $lpad, $mname, $pair);
        $out .= ($name =~ /^\%/) ? '(' : '{';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        $lpad = $s->{apad};
        $pair = $s->{pair};
        ($name =~ /^\%(.*)$/) ? ($mname = "\$" . $1) :
  	# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
  	($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
  	  ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        my ($sortkeys, $keys, $key) = ("$s->{sortkeys}");
        if ($sortkeys) {
  	if (ref($s->{sortkeys}) eq 'CODE') {
  	  $keys = $s->{sortkeys}($val);
  	  unless (ref($keys) eq 'ARRAY') {
  	    carp "Sortkeys subroutine did not return ARRAYREF";
  	    $keys = [];
  	  }
  	}
  	else {
  	  $keys = [ sort keys %$val ];
  	}
        }
  
        # Ensure hash iterator is reset
        keys(%$val);
  
        while (($k, $v) = ! $sortkeys ? (each %$val) :
  	     @$keys ? ($key = shift(@$keys), $val->{$key}) :
  	     () ) 
        {
  	my $nk = $s->_dump($k, "");
  	$nk = $1 if !$s->{quotekeys} and $nk =~ /^[\"\']([A-Za-z_]\w*)[\"\']$/;
  	$sname = $mname . '{' . $nk . '}';
  	$out .= $pad . $ipad . $nk . $pair;
  
  	# temporarily alter apad
  	$s->{apad} .= (" " x (length($nk) + 4)) if $s->{indent} >= 2;
  	$out .= $s->_dump($val->{$k}, $sname) . ",";
  	$s->{apad} = $lpad if $s->{indent} >= 2;
        }
        if (substr($out, -1) eq ',') {
  	chop $out;
  	$out .= $pad . ($s->{xpad} x ($s->{level} - 1));
        }
        $out .= ($name =~ /^\%/) ? ')' : '}';
      }
      elsif ($realtype eq 'CODE') {
        if ($s->{deparse}) {
  	require B::Deparse;
  	my $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);
  	$pad    =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);
  	$sub    =~ s/\n/$pad/gse;
  	$out   .=  $sub;
        } else {
          $out .= 'sub { "DUMMY" }';
          carp "Encountered CODE ref, using dummy placeholder" if $s->{purity};
        }
      }
      else {
        croak "Can\'t handle $realtype type.";
      }
      
      if ($realpack and !$no_bless) { # we have a blessed ref
        $out .= ', ' . _quote($realpack) . ' )';
        $out .= '->' . $s->{toaster} . '()'  if $s->{toaster} ne '';
        $s->{apad} = $blesspad;
      }
      $s->{level}--;
  
    }
    else {                                 # simple scalar
  
      my $ref = \$_[1];
      # first, catalog the scalar
      if ($name ne '') {
        $id = format_refaddr($ref);
        if (exists $s->{seen}{$id}) {
          if ($s->{seen}{$id}[2]) {
  	  $out = $s->{seen}{$id}[0];
  	  #warn "[<$out]\n";
  	  return "\${$out}";
  	}
        }
        else {
  	#warn "[>\\$name]\n";
  	$s->{seen}{$id} = ["\\$name", $ref];
        }
      }
      if (ref($ref) eq 'GLOB' or "$ref" =~ /=GLOB\([^()]+\)$/) {  # glob
        my $name = substr($val, 1);
        if ($name =~ /^[A-Za-z_][\w:]*$/) {
  	$name =~ s/^main::/::/;
  	$sname = $name;
        }
        else {
  	$sname = $s->_dump($name, "");
  	$sname = '{' . $sname . '}';
        }
        if ($s->{purity}) {
  	my $k;
  	local ($s->{level}) = 0;
  	for $k (qw(SCALAR ARRAY HASH)) {
  	  my $gval = *$val{$k};
  	  next unless defined $gval;
  	  next if $k eq "SCALAR" && ! defined $$gval;  # always there
  
  	  # _dump can push into @post, so we hold our place using $postlen
  	  my $postlen = scalar @post;
  	  $post[$postlen] = "\*$sname = ";
  	  local ($s->{apad}) = " " x length($post[$postlen]) if $s->{indent} >= 2;
  	  $post[$postlen] .= $s->_dump($gval, "\*$sname\{$k\}");
  	}
        }
        $out .= '*' . $sname;
      }
      elsif (!defined($val)) {
        $out .= "undef";
      }
      elsif ($val =~ /^(?:0|-?[1-9]\d{0,8})\z/) { # safe decimal number
        $out .= $val;
      }
      else {				 # string
        if ($s->{useqq} or $val =~ tr/\0-\377//c) {
          # Fall back to qq if there's Unicode
  	$out .= qquote($val, $s->{useqq});
        }
        else {
          $out .= _quote($val);
        }
      }
    }
    if ($id) {
      # if we made it this far, $id was added to seen list at current
      # level, so remove it to get deep copies
      if ($s->{deepcopy}) {
        delete($s->{seen}{$id});
      }
      elsif ($name) {
        $s->{seen}{$id}[2] = 1;
      }
    }
    return $out;
  }
    
  #
  # non-OO style of earlier version
  #
  sub Dumper {
    return Data::Dumper->Dump([@_]);
  }
  
  # compat stub
  sub DumperX {
    return Data::Dumper->Dumpxs([@_], []);
  }
  
  sub Dumpf { return Data::Dumper->Dump(@_) }
  
  sub Dumpp { print Data::Dumper->Dump(@_) }
  
  #
  # reset the "seen" cache 
  #
  sub Reset {
    my($s) = shift;
    $s->{seen} = {};
    return $s;
  }
  
  sub Indent {
    my($s, $v) = @_;
    if (defined($v)) {
      if ($v == 0) {
        $s->{xpad} = "";
        $s->{sep} = "";
      }
      else {
        $s->{xpad} = "  ";
        $s->{sep} = "\n";
      }
      $s->{indent} = $v;
      return $s;
    }
    else {
      return $s->{indent};
    }
  }
  
  sub Pair {
      my($s, $v) = @_;
      defined($v) ? (($s->{pair} = $v), return $s) : $s->{pair};
  }
  
  sub Pad {
    my($s, $v) = @_;
    defined($v) ? (($s->{pad} = $v), return $s) : $s->{pad};
  }
  
  sub Varname {
    my($s, $v) = @_;
    defined($v) ? (($s->{varname} = $v), return $s) : $s->{varname};
  }
  
  sub Purity {
    my($s, $v) = @_;
    defined($v) ? (($s->{purity} = $v), return $s) : $s->{purity};
  }
  
  sub Useqq {
    my($s, $v) = @_;
    defined($v) ? (($s->{useqq} = $v), return $s) : $s->{useqq};
  }
  
  sub Terse {
    my($s, $v) = @_;
    defined($v) ? (($s->{terse} = $v), return $s) : $s->{terse};
  }
  
  sub Freezer {
    my($s, $v) = @_;
    defined($v) ? (($s->{freezer} = $v), return $s) : $s->{freezer};
  }
  
  sub Toaster {
    my($s, $v) = @_;
    defined($v) ? (($s->{toaster} = $v), return $s) : $s->{toaster};
  }
  
  sub Deepcopy {
    my($s, $v) = @_;
    defined($v) ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};
  }
  
  sub Quotekeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};
  }
  
  sub Bless {
    my($s, $v) = @_;
    defined($v) ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};
  }
  
  sub Maxdepth {
    my($s, $v) = @_;
    defined($v) ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};
  }
  
  sub Useperl {
    my($s, $v) = @_;
    defined($v) ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};
  }
  
  sub Sortkeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};
  }
  
  sub Deparse {
    my($s, $v) = @_;
    defined($v) ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};
  }
  
  # used by qquote below
  my %esc = (  
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  # put a string value in double quotes
  sub qquote {
    local($_) = shift;
    s/([\\\"\@\$])/\\$1/g;
    my $bytes; { use bytes; $bytes = length }
    s/([^\x00-\x7f])/'\x{'.sprintf("%x",ord($1)).'}'/ge if $bytes > length;
    return qq("$_") unless 
      /[^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~]/;  # fast exit
  
    my $high = shift || "";
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    if (ord('^')==94)  { # ascii
      # no need for 3 digits in escape for these
      s/([\0-\037])(?!\d)/'\\'.sprintf('%o',ord($1))/eg;
      s/([\0-\037\177])/'\\'.sprintf('%03o',ord($1))/eg;
      # all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--
      if ($high eq "iso8859") {
        s/([\200-\240])/'\\'.sprintf('%o',ord($1))/eg;
      } elsif ($high eq "utf8") {
  #     use utf8;
  #     $str =~ s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      } elsif ($high eq "8bit") {
          # leave it as it is
      } else {
        s/([\200-\377])/'\\'.sprintf('%03o',ord($1))/eg;
        s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      }
    }
    else { # ebcdic
        s{([^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~])(?!\d)}
         {my $v = ord($1); '\\'.sprintf(($v <= 037 ? '%o' : '%03o'), $v)}eg;
        s{([^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~])}
         {'\\'.sprintf('%03o',ord($1))}eg;
    }
  
    return qq("$_");
  }
  
  # helper sub to sort hash keys in Perl < 5.8.0 where we don't have
  # access to sortsv() from XS
  sub _sortkeys { [ sort keys %{$_[0]} ] }
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Dumper - stringified perl data structures, suitable for both printing and C<eval>
  
  =head1 SYNOPSIS
  
      use Data::Dumper;
  
      # simple procedural interface
      print Dumper($foo, $bar);
  
      # extended usage with names
      print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
  
      # configuration variables
      {
        local $Data::Dumper::Purity = 1;
        eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
      }
  
      # OO usage
      $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);
         ...
      print $d->Dump;
         ...
      $d->Purity(1)->Terse(1)->Deepcopy(1);
      eval $d->Dump;
  
  
  =head1 DESCRIPTION
  
  Given a list of scalars or reference variables, writes out their contents in
  perl syntax. The references can also be objects.  The content of each
  variable is output in a single Perl statement.  Handles self-referential
  structures correctly.
  
  The return value can be C<eval>ed to get back an identical copy of the
  original reference structure.
  
  Any references that are the same as one of those passed in will be named
  C<$VAR>I<n> (where I<n> is a numeric suffix), and other duplicate references
  to substructures within C<$VAR>I<n> will be appropriately labeled using arrow
  notation.  You can specify names for individual values to be dumped if you
  use the C<Dump()> method, or you can change the default C<$VAR> prefix to
  something else.  See C<$Data::Dumper::Varname> and C<$Data::Dumper::Terse>
  below.
  
  The default output of self-referential structures can be C<eval>ed, but the
  nested references to C<$VAR>I<n> will be undefined, since a recursive
  structure cannot be constructed using one Perl statement.  You should set the
  C<Purity> flag to 1 to get additional statements that will correctly fill in
  these references.  Moreover, if C<eval>ed when strictures are in effect,
  you need to ensure that any variables it accesses are previously declared.
  
  In the extended usage form, the references to be dumped can be given
  user-specified names.  If a name begins with a C<*>, the output will 
  describe the dereferenced type of the supplied reference for hashes and
  arrays, and coderefs.  Output of names will be avoided where possible if
  the C<Terse> flag is set.
  
  In many cases, methods that are used to set the internal state of the
  object will return the object itself, so method calls can be conveniently
  chained together.
  
  Several styles of output are possible, all controlled by setting
  the C<Indent> flag.  See L<Configuration Variables or Methods> below 
  for details.
  
  
  =head2 Methods
  
  =over 4
  
  =item I<PACKAGE>->new(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns a newly created C<Data::Dumper> object.  The first argument is an
  anonymous array of values to be dumped.  The optional second argument is an
  anonymous array of names for the values.  The names need not have a leading
  C<$> sign, and must be comprised of alphanumeric characters.  You can begin
  a name with a C<*> to specify that the dereferenced type must be dumped
  instead of the reference itself, for ARRAY and HASH references.
  
  The prefix specified by C<$Data::Dumper::Varname> will be used with a
  numeric suffix if the name for a value is undefined.
  
  Data::Dumper will catalog all references encountered while dumping the
  values. Cross-references (in the form of names of substructures in perl
  syntax) will be inserted at all possible points, preserving any structural
  interdependencies in the original set of values.  Structure traversal is
  depth-first,  and proceeds in order from the first supplied value to
  the last.
  
  =item I<$OBJ>->Dump  I<or>  I<PACKAGE>->Dump(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns the stringified form of the values stored in the object (preserving
  the order in which they were supplied to C<new>), subject to the
  configuration options below.  In a list context, it returns a list
  of strings corresponding to the supplied values.
  
  The second form, for convenience, simply calls the C<new> method on its
  arguments before dumping the object immediately.
  
  =item I<$OBJ>->Seen(I<[HASHREF]>)
  
  Queries or adds to the internal table of already encountered references.
  You must use C<Reset> to explicitly clear the table if needed.  Such
  references are not dumped; instead, their names are inserted wherever they
  are encountered subsequently.  This is useful especially for properly
  dumping subroutine references.
  
  Expects an anonymous hash of name => value pairs.  Same rules apply for names
  as in C<new>.  If no argument is supplied, will return the "seen" list of
  name => value pairs, in a list context.  Otherwise, returns the object
  itself.
  
  =item I<$OBJ>->Values(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of values that will be dumped.
  When called without arguments, returns the values.  Otherwise, returns the
  object itself.
  
  =item I<$OBJ>->Names(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of user supplied names for the values
  that will be dumped.  When called without arguments, returns the names.
  Otherwise, returns the object itself.
  
  =item I<$OBJ>->Reset
  
  Clears the internal table of "seen" references and returns the object
  itself.
  
  =back
  
  =head2 Functions
  
  =over 4
  
  =item Dumper(I<LIST>)
  
  Returns the stringified form of the values in the list, subject to the
  configuration options below.  The values will be named C<$VAR>I<n> in the
  output, where I<n> is a numeric suffix.  Will return a list of strings
  in a list context.
  
  =back
  
  =head2 Configuration Variables or Methods
  
  Several configuration variables can be used to control the kind of output
  generated when using the procedural interface.  These variables are usually
  C<local>ized in a block so that other parts of the code are not affected by
  the change.  
  
  These variables determine the default state of the object created by calling
  the C<new> method, but cannot be used to alter the state of the object
  thereafter.  The equivalent method names should be used instead to query
  or set the internal state of the object.
  
  The method forms return the object itself when called with arguments,
  so that they can be chained together nicely.
  
  =over 4
  
  =item *
  
  $Data::Dumper::Indent  I<or>  I<$OBJ>->Indent(I<[NEWVAL]>)
  
  Controls the style of indentation.  It can be set to 0, 1, 2 or 3.  Style 0
  spews output without any newlines, indentation, or spaces between list
  items.  It is the most compact format possible that can still be called
  valid perl.  Style 1 outputs a readable form with newlines but no fancy
  indentation (each level in the structure is simply indented by a fixed
  amount of whitespace).  Style 2 (the default) outputs a very readable form
  which takes into account the length of hash keys (so the hash value lines
  up).  Style 3 is like style 2, but also annotates the elements of arrays
  with their index (but the comment is on its own line, so array output
  consumes twice the number of lines).  Style 2 is the default.
  
  =item *
  
  $Data::Dumper::Purity  I<or>  I<$OBJ>->Purity(I<[NEWVAL]>)
  
  Controls the degree to which the output can be C<eval>ed to recreate the
  supplied reference structures.  Setting it to 1 will output additional perl
  statements that will correctly recreate nested references.  The default is
  0.
  
  =item *
  
  $Data::Dumper::Pad  I<or>  I<$OBJ>->Pad(I<[NEWVAL]>)
  
  Specifies the string that will be prefixed to every line of the output.
  Empty string by default.
  
  =item *
  
  $Data::Dumper::Varname  I<or>  I<$OBJ>->Varname(I<[NEWVAL]>)
  
  Contains the prefix to use for tagging variable names in the output. The
  default is "VAR".
  
  =item *
  
  $Data::Dumper::Useqq  I<or>  I<$OBJ>->Useqq(I<[NEWVAL]>)
  
  When set, enables the use of double quotes for representing string values.
  Whitespace other than space will be represented as C<[\n\t\r]>, "unsafe"
  characters will be backslashed, and unprintable characters will be output as
  quoted octal integers.  Since setting this variable imposes a performance
  penalty, the default is 0.  C<Dump()> will run slower if this flag is set,
  since the fast XSUB implementation doesn't support it yet.
  
  =item *
  
  $Data::Dumper::Terse  I<or>  I<$OBJ>->Terse(I<[NEWVAL]>)
  
  When set, Data::Dumper will emit single, non-self-referential values as
  atoms/terms rather than statements.  This means that the C<$VAR>I<n> names
  will be avoided where possible, but be advised that such output may not
  always be parseable by C<eval>.
  
  =item *
  
  $Data::Dumper::Freezer  I<or>  $I<OBJ>->Freezer(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will invoke that method via the object before attempting to
  stringify it.  This method can alter the contents of the object (if, for
  instance, it contains data allocated from C), and even rebless it in a
  different package.  The client is responsible for making sure the specified
  method can be called via the object, and that the object ends up containing
  only perl data types after the method has been called.  Defaults to an empty
  string.
  
  If an object does not support the method specified (determined using
  UNIVERSAL::can()) then the call will be skipped.  If the method dies a
  warning will be generated.
  
  =item *
  
  $Data::Dumper::Toaster  I<or>  $I<OBJ>->Toaster(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will emit a method call for any objects that are to be dumped
  using the syntax C<bless(DATA, CLASS)-E<gt>METHOD()>.  Note that this means that
  the method specified will have to perform any modifications required on the
  object (like creating new state within it, and/or reblessing it in a
  different package) and then return it.  The client is responsible for making
  sure the method can be called via the object, and that it returns a valid
  object.  Defaults to an empty string.
  
  =item *
  
  $Data::Dumper::Deepcopy  I<or>  $I<OBJ>->Deepcopy(I<[NEWVAL]>)
  
  Can be set to a boolean value to enable deep copies of structures.
  Cross-referencing will then only be done when absolutely essential
  (i.e., to break reference cycles).  Default is 0.
  
  =item *
  
  $Data::Dumper::Quotekeys  I<or>  $I<OBJ>->Quotekeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are quoted.
  A false value will avoid quoting hash keys when it looks like a simple
  string.  Default is 1, which will always enclose hash keys in quotes.
  
  =item *
  
  $Data::Dumper::Bless  I<or>  $I<OBJ>->Bless(I<[NEWVAL]>)
  
  Can be set to a string that specifies an alternative to the C<bless>
  builtin operator used to create objects.  A function with the specified
  name should exist, and should accept the same arguments as the builtin.
  Default is C<bless>.
  
  =item *
  
  $Data::Dumper::Pair  I<or>  $I<OBJ>->Pair(I<[NEWVAL]>)
  
  Can be set to a string that specifies the separator between hash keys
  and values. To dump nested hash, array and scalar values to JavaScript,
  use: C<$Data::Dumper::Pair = ' : ';>. Implementing C<bless> in JavaScript
  is left as an exercise for the reader.
  A function with the specified name exists, and accepts the same arguments
  as the builtin.
  
  Default is: C< =E<gt> >.
  
  =item *
  
  $Data::Dumper::Maxdepth  I<or>  $I<OBJ>->Maxdepth(I<[NEWVAL]>)
  
  Can be set to a positive integer that specifies the depth beyond which
  we don't venture into a structure.  Has no effect when
  C<Data::Dumper::Purity> is set.  (Useful in debugger when we often don't
  want to see more than enough).  Default is 0, which means there is 
  no maximum depth. 
  
  =item *
  
  $Data::Dumper::Useperl  I<or>  $I<OBJ>->Useperl(I<[NEWVAL]>)
  
  Can be set to a boolean value which controls whether the pure Perl
  implementation of C<Data::Dumper> is used. The C<Data::Dumper> module is
  a dual implementation, with almost all functionality written in both
  pure Perl and also in XS ('C'). Since the XS version is much faster, it
  will always be used if possible. This option lets you override the
  default behavior, usually for testing purposes only. Default is 0, which
  means the XS implementation will be used if possible.
  
  =item *
  
  $Data::Dumper::Sortkeys  I<or>  $I<OBJ>->Sortkeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are dumped in
  sorted order. A true value will cause the keys of all hashes to be
  dumped in Perl's default sort order. Can also be set to a subroutine
  reference which will be called for each hash that is dumped. In this
  case C<Data::Dumper> will call the subroutine once for each hash,
  passing it the reference of the hash. The purpose of the subroutine is
  to return a reference to an array of the keys that will be dumped, in
  the order that they should be dumped. Using this feature, you can
  control both the order of the keys, and which keys are actually used. In
  other words, this subroutine acts as a filter by which you can exclude
  certain keys from being dumped. Default is 0, which means that hash keys
  are not sorted.
  
  =item *
  
  $Data::Dumper::Deparse  I<or>  $I<OBJ>->Deparse(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether code references are
  turned into perl source code. If set to a true value, C<B::Deparse>
  will be used to get the source of the code reference. Using this option
  will force using the Perl implementation of the dumper, since the fast
  XSUB implementation doesn't support it.
  
  Caution : use this option only if you know that your coderefs will be
  properly reconstructed by C<B::Deparse>.
  
  =back
  
  =head2 Exports
  
  =over 4
  
  =item Dumper
  
  =back
  
  =head1 EXAMPLES
  
  Run these code snippets to get a quick feel for the behavior of this
  module.  When you are through with these examples, you may want to
  add or change the various configuration variables described above,
  to see their behavior.  (See the testsuite in the Data::Dumper
  distribution for more examples.)
  
  
      use Data::Dumper;
  
      package Foo;
      sub new {bless {'a' => 1, 'b' => sub { return "foo" }}, $_[0]};
  
      package Fuz;                       # a weird REF-REF-SCALAR object
      sub new {bless \($_ = \ 'fu\'z'), $_[0]};
  
      package main;
      $foo = Foo->new;
      $fuz = Fuz->new;
      $boo = [ 1, [], "abcd", \*foo,
               {1 => 'a', 023 => 'b', 0x45 => 'c'}, 
               \\"p\q\'r", $foo, $fuz];
  
      ########
      # simple usage
      ########
  
      $bar = eval(Dumper($boo));
      print($@) if $@;
      print Dumper($boo), Dumper($bar);  # pretty print (no array indices)
  
      $Data::Dumper::Terse = 1;          # don't output names where feasible
      $Data::Dumper::Indent = 0;         # turn off all pretty print
      print Dumper($boo), "\n";
  
      $Data::Dumper::Indent = 1;         # mild pretty print
      print Dumper($boo);
  
      $Data::Dumper::Indent = 3;         # pretty print with array indices
      print Dumper($boo);
  
      $Data::Dumper::Useqq = 1;          # print strings in double quotes
      print Dumper($boo);
  
      $Data::Dumper::Pair = " : ";       # specify hash key/value separator
      print Dumper($boo);
  
  
      ########
      # recursive structures
      ########
  
      @c = ('c');
      $c = \@c;
      $b = {};
      $a = [1, $b, $c];
      $b->{a} = $a;
      $b->{b} = $a->[1];
      $b->{c} = $a->[2];
      print Data::Dumper->Dump([$a,$b,$c], [qw(a b c)]);
  
  
      $Data::Dumper::Purity = 1;         # fill in the holes for eval
      print Data::Dumper->Dump([$a, $b], [qw(*a b)]); # print as @a
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]); # print as %b
  
  
      $Data::Dumper::Deepcopy = 1;       # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
  
      $Data::Dumper::Purity = 0;         # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
      ########
      # deep structures
      ########
  
      $a = "pearl";
      $b = [ $a ];
      $c = { 'b' => $b };
      $d = [ $c ];
      $e = { 'd' => $d };
      $f = { 'e' => $e };
      print Data::Dumper->Dump([$f], [qw(f)]);
  
      $Data::Dumper::Maxdepth = 3;       # no deeper than 3 refs down
      print Data::Dumper->Dump([$f], [qw(f)]);
  
  
      ########
      # object-oriented usage
      ########
  
      $d = Data::Dumper->new([$a,$b], [qw(a b)]);
      $d->Seen({'*c' => $c});            # stash a ref without printing it
      $d->Indent(3);
      print $d->Dump;
      $d->Reset->Purity(0);              # empty the seen cache
      print join "----\n", $d->Dump;
  
  
      ########
      # persistence
      ########
  
      package Foo;
      sub new { bless { state => 'awake' }, shift }
      sub Freeze {
          my $s = shift;
  	print STDERR "preparing to sleep\n";
  	$s->{state} = 'asleep';
  	return bless $s, 'Foo::ZZZ';
      }
  
      package Foo::ZZZ;
      sub Thaw {
          my $s = shift;
  	print STDERR "waking up\n";
  	$s->{state} = 'awake';
  	return bless $s, 'Foo';
      }
  
      package Foo;
      use Data::Dumper;
      $a = Foo->new;
      $b = Data::Dumper->new([$a], ['c']);
      $b->Freezer('Freeze');
      $b->Toaster('Thaw');
      $c = $b->Dump;
      print $c;
      $d = eval $c;
      print Data::Dumper->Dump([$d], ['d']);
  
  
      ########
      # symbol substitution (useful for recreating CODE refs)
      ########
  
      sub foo { print "foo speaking\n" }
      *other = \&foo;
      $bar = [ \&other ];
      $d = Data::Dumper->new([\&other,$bar],['*other','bar']);
      $d->Seen({ '*foo' => \&foo });
      print $d->Dump;
  
  
      ########
      # sorting and filtering hash keys
      ########
  
      $Data::Dumper::Sortkeys = \&my_filter;
      my $foo = { map { (ord, "$_$_$_") } 'I'..'Q' };
      my $bar = { %$foo };
      my $baz = { reverse %$foo };
      print Dumper [ $foo, $bar, $baz ];
  
      sub my_filter {
          my ($hash) = @_;
          # return an array ref containing the hash keys to dump
          # in the order that you want them to be dumped
          return [
            # Sort the keys of %$foo in reverse numeric order
              $hash eq $foo ? (sort {$b <=> $a} keys %$hash) :
            # Only dump the odd number keys of %$bar
              $hash eq $bar ? (grep {$_ % 2} keys %$hash) :
            # Sort keys in default order for all other hashes
              (sort keys %$hash)
          ];
      }
  
  =head1 BUGS
  
  Due to limitations of Perl subroutine call semantics, you cannot pass an
  array or hash.  Prepend it with a C<\> to pass its reference instead.  This
  will be remedied in time, now that Perl has subroutine prototypes.
  For now, you need to use the extended usage form, and prepend the
  name with a C<*> to output it as a hash or array.
  
  C<Data::Dumper> cheats with CODE references.  If a code reference is
  encountered in the structure being processed (and if you haven't set
  the C<Deparse> flag), an anonymous subroutine that
  contains the string '"DUMMY"' will be inserted in its place, and a warning
  will be printed if C<Purity> is set.  You can C<eval> the result, but bear
  in mind that the anonymous sub that gets created is just a placeholder.
  Someday, perl will have a switch to cache-on-demand the string
  representation of a compiled piece of code, I hope.  If you have prior
  knowledge of all the code refs that your data structures are likely
  to have, you can use the C<Seen> method to pre-seed the internal reference
  table and make the dumped output point to them, instead.  See L</EXAMPLES>
  above.
  
  The C<Useqq> and C<Deparse> flags makes Dump() run slower, since the
  XSUB implementation does not support them.
  
  SCALAR objects have the weirdest looking C<bless> workaround.
  
  Pure Perl version of C<Data::Dumper> escapes UTF-8 strings correctly
  only in Perl 5.8.0 and later.
  
  =head2 NOTE
  
  Starting from Perl 5.8.1 different runs of Perl will have different
  ordering of hash keys.  The change was done for greater security,
  see L<perlsec/"Algorithmic Complexity Attacks">.  This means that
  different runs of Perl will have different Data::Dumper outputs if
  the data contains hashes.  If you need to have identical Data::Dumper
  outputs from different runs of Perl, use the environment variable
  PERL_HASH_SEED, see L<perlrun/PERL_HASH_SEED>.  Using this restores
  the old (platform-specific) ordering: an even prettier solution might
  be to use the C<Sortkeys> filter of Data::Dumper.
  
  =head1 AUTHOR
  
  Gurusamy Sarathy        gsar@activestate.com
  
  Copyright (c) 1996-98 Gurusamy Sarathy. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 VERSION
  
  Version 2.131  (May 27 2011)
  
  =head1 SEE ALSO
  
  perl(1)
  
  =cut
DARWIN-2LEVEL_DATA_DUMPER

$fatpacked{"darwin-2level/File/Spec.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC

$fatpacked{"darwin-2level/File/Spec/Cygwin.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp' );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_CYGWIN

$fatpacked{"darwin-2level/File/Spec/Epoc.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still work in progress ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_EPOC

$fatpacked{"darwin-2level/File/Spec/Functions.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      *{$meth} = sub {&$sub('File::Spec', @_)};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS

$fatpacked{"darwin-2level/File/Spec/Mac.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR} );
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_MAC

$fatpacked{"darwin-2level/File/Spec/OS2.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $tmpdir = $_[0]->_tmpdir( @d, '/tmp', '/'  );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC_OS2

$fatpacked{"darwin-2level/File/Spec/Unix.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub _tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      my @dirlist = @_;
      {
  	no strict 'refs';
  	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
              require Scalar::Util;
  	    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
  	}
  	elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	    @dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;
  	}
      }
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      return $tmpdir;
  }
  
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" );
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
      my ($path_volume) = $self->splitpath($path, 1);
      my ($base_volume) = $self->splitpath($base, 1);
  
      # Can't relativize across volumes
      return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
      # For UNC paths, the user might give a volume like //foo/bar that
      # strictly speaking has no directory portion.  Treat it as if it
      # had the root directory for that volume.
      if (!length($base_directories) and $self->file_name_is_absolute($base)) {
        $base_directories = $self->rootdir;
      }
      }
      else {
  	my $wd= ($self->splitpath($self->_cwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
DARWIN-2LEVEL_FILE_SPEC_UNIX

$fatpacked{"darwin-2level/File/Spec/VMS.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicity requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
              }
  
  	$sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
  	    $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
  
  	    # Special case for VMS absolute directory specs: these will have
  	    # had device prepended during trip through Unix syntax in
  	    # eliminate_macros(), since Unix syntax has no way to express
  	    # "absolute from the top of this device's directory tree".
  	    if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
                  } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
              } else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
  		$rslt = $self->eliminate_macros($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $file : vmsify($file);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      my $self = shift @_;
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
          return $tmpdir;
      }
  
      $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /:[^<\[]/);
  }
  
  =item splitpath (override)
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
          my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
          $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
            $dir = vmspath($dir);
        }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
          if grep m{/}, @_;
  
      my($path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
          if ($path =~ m/\//) {
  	    $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
  		       ? vmspath($path)             # whether it's a directory
  		       : vmsify($path) );
          }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
              $sep = '.'
                  if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                       $path_directories =~ m{^[^.\[<]}s
                  ) ;
              $base_directories = "$base_directories$sep$path_directories";
              $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  # eliminate_macros() and fixpath() are MakeMaker-specific methods
  # which are used inside catfile() and catdir().  MakeMaker has its own
  # copies as of 6.06_03 which are the canonical ones.  We leave these
  # here, in peace, so that File::Spec continues to work with MakeMakers
  # prior to 6.06_03.
  # 
  # Please consider these two methods deprecated.  Do not patch them,
  # patch the ones in ExtUtils::MM_VMS instead.
  #
  # Update:  MakeMaker 6.48 is still using these routines on VMS.
  # so they need to be kept up to date with ExtUtils::MM_VMS.
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless (defined $path) && ($path ne '');
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my $npath = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  # Deprecated.  See the note above for eliminate_macros().
  
  # Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  # in any directory specification, in order to avoid juxtaposing two
  # VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  # are all macro, so that we can tell how long the expansion is, and avoid
  # overrunning DCL's command buffer when MM[KS] is running.
  
  # fixpath() checks to see whether the result matches the name of a
  # directory in the current default directory and returns a directory or
  # file specification accordingly.  C<$is_dir> can be set to true to
  # force fixpath() to consider the path to be a directory or false to force
  # it to be a file.
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /\s/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /\s+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
      $fixedpath;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_VMS

$fatpacked{"darwin-2level/File/Spec/Win32.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
DARWIN-2LEVEL_FILE_SPEC_WIN32

$fatpacked{"darwin-2level/Socket.pm"} = <<'DARWIN-2LEVEL_SOCKET';
  package Socket;
  
  use strict;
  { use 5.006001; }
  
  our $VERSION = '2.011';
  
  =head1 NAME
  
  C<Socket> - networking constants and support functions
  
  =head1 SYNOPSIS
  
  C<Socket> a low-level module used by, among other things, the L<IO::Socket>
  family of modules. The following examples demonstrate some low-level uses but
  a practical program would likely use the higher-level API provided by
  C<IO::Socket> or similar instead.
  
   use Socket qw(PF_INET SOCK_STREAM pack_sockaddr_in inet_aton);
  
   socket(my $socket, PF_INET, SOCK_STREAM, 0)
       or die "socket: $!";
  
   my $port = getservbyname "echo", "tcp";
   connect($socket, pack_sockaddr_in($port, inet_aton("localhost")))
       or die "connect: $!";
  
   print $socket "Hello, world!\n";
   print <$socket>;
  
  See also the L</EXAMPLES> section.
  
  =head1 DESCRIPTION
  
  This module provides a variety of constants, structure manipulators and other
  functions related to socket-based networking. The values and functions
  provided are useful when used in conjunction with Perl core functions such as
  socket(), setsockopt() and bind(). It also provides several other support
  functions, mostly for dealing with conversions of network addresses between
  human-readable and native binary forms, and for hostname resolver operations.
  
  Some constants and functions are exported by default by this module; but for
  backward-compatibility any recently-added symbols are not exported by default
  and must be requested explicitly. When an import list is provided to the
  C<use Socket> line, the default exports are not automatically imported. It is
  therefore best practice to always to explicitly list all the symbols required.
  
  Also, some common socket "newline" constants are provided: the constants
  C<CR>, C<LF>, and C<CRLF>, as well as C<$CR>, C<$LF>, and C<$CRLF>, which map
  to C<\015>, C<\012>, and C<\015\012>. If you do not want to use the literal
  characters in your programs, then use the constants provided here. They are
  not exported by default, but can be imported individually, and with the
  C<:crlf> export tag:
  
   use Socket qw(:DEFAULT :crlf);
  
   $sock->print("GET / HTTP/1.0$CRLF");
  
  The entire getaddrinfo() subsystem can be exported using the tag C<:addrinfo>;
  this exports the getaddrinfo() and getnameinfo() functions, and all the
  C<AI_*>, C<NI_*>, C<NIx_*> and C<EAI_*> constants.
  
  =cut
  
  =head1 CONSTANTS
  
  In each of the following groups, there may be many more constants provided
  than just the ones given as examples in the section heading. If the heading
  ends C<...> then this means there are likely more; the exact constants
  provided will depend on the OS and headers found at compile-time.
  
  =cut
  
  =head2 PF_INET, PF_INET6, PF_UNIX, ...
  
  Protocol family constants to use as the first argument to socket() or the
  value of the C<SO_DOMAIN> or C<SO_FAMILY> socket option.
  
  =head2 AF_INET, AF_INET6, AF_UNIX, ...
  
  Address family constants used by the socket address structures, to pass to
  such functions as inet_pton() or getaddrinfo(), or are returned by such
  functions as sockaddr_family().
  
  =head2 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...
  
  Socket type constants to use as the second argument to socket(), or the value
  of the C<SO_TYPE> socket option.
  
  =head2 SOCK_NONBLOCK. SOCK_CLOEXEC
  
  Linux-specific shortcuts to specify the C<O_NONBLOCK> and C<FD_CLOEXEC> flags
  during a C<socket(2)> call.
  
   socket( my $sockh, PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, 0 )
  
  =head2 SOL_SOCKET
  
  Socket option level constant for setsockopt() and getsockopt().
  
  =head2 SO_ACCEPTCONN, SO_BROADCAST, SO_ERROR, ...
  
  Socket option name constants for setsockopt() and getsockopt() at the
  C<SOL_SOCKET> level.
  
  =head2 IP_OPTIONS, IP_TOS, IP_TTL, ...
  
  Socket option name constants for IPv4 socket options at the C<IPPROTO_IP>
  level.
  
  =head2 IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...
  
  Socket option value constants for C<IP_TOS> socket option.
  
  =head2 MSG_BCAST, MSG_OOB, MSG_TRUNC, ...
  
  Message flag constants for send() and recv().
  
  =head2 SHUT_RD, SHUT_RDWR, SHUT_WR
  
  Direction constants for shutdown().
  
  =head2 INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE
  
  Constants giving the special C<AF_INET> addresses for wildcard, broadcast,
  local loopback, and invalid addresses.
  
  Normally equivalent to inet_aton('0.0.0.0'), inet_aton('255.255.255.255'),
  inet_aton('localhost') and inet_aton('255.255.255.255') respectively.
  
  =head2 IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...
  
  IP protocol constants to use as the third argument to socket(), the level
  argument to getsockopt() or setsockopt(), or the value of the C<SO_PROTOCOL>
  socket option.
  
  =head2 TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...
  
  Socket option name constants for TCP socket options at the C<IPPROTO_TCP>
  level.
  
  =head2 IN6ADDR_ANY, IN6ADDR_LOOPBACK
  
  Constants giving the special C<AF_INET6> addresses for wildcard and local
  loopback.
  
  Normally equivalent to inet_pton(AF_INET6, "::") and
  inet_pton(AF_INET6, "::1") respectively.
  
  =head2 IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...
  
  Socket option name constants for IPv6 socket options at the C<IPPROTO_IPV6>
  level.
  
  =cut
  
  # Still undocumented: SCM_*, SOMAXCONN, IOV_MAX, UIO_MAXIOV
  
  =head1 STRUCTURE MANIPULATORS
  
  The following functions convert between lists of Perl values and packed binary
  strings representing structures.
  
  =cut
  
  =head2 $family = sockaddr_family $sockaddr
  
  Takes a packed socket address (as returned by pack_sockaddr_in(),
  pack_sockaddr_un() or the perl builtin functions getsockname() and
  getpeername()). Returns the address family tag. This will be one of the
  C<AF_*> constants, such as C<AF_INET> for a C<sockaddr_in> addresses or
  C<AF_UNIX> for a C<sockaddr_un>. It can be used to figure out what unpack to
  use for a sockaddr of unknown type.
  
  =head2 $sockaddr = pack_sockaddr_in $port, $ip_address
  
  Takes two arguments, a port number and an opaque string (as returned by
  inet_aton(), or a v-string). Returns the C<sockaddr_in> structure with those
  arguments packed in and C<AF_INET> filled in. For Internet domain sockets,
  this structure is normally what you need for the arguments in bind(),
  connect(), and send().
  
  =head2 ($port, $ip_address) = unpack_sockaddr_in $sockaddr
  
  Takes a C<sockaddr_in> structure (as returned by pack_sockaddr_in(),
  getpeername() or recv()). Returns a list of two elements: the port and an
  opaque string representing the IP address (you can use inet_ntoa() to convert
  the address to the four-dotted numeric format). Will croak if the structure
  does not represent an C<AF_INET> address.
  
  In scalar context will return just the IP address.
  
  =head2 $sockaddr = sockaddr_in $port, $ip_address
  
  =head2 ($port, $ip_address) = sockaddr_in $sockaddr
  
  A wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context,
  unpacks its argument and returns a list consisting of the port and IP address.
  In scalar context, packs its port and IP address arguments as a C<sockaddr_in>
  and returns it.
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_in() or unpack_sockaddr_in() explicitly.
  
  =head2 $sockaddr = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]
  
  Takes two to four arguments, a port number, an opaque string (as returned by
  inet_pton()), optionally a scope ID number, and optionally a flow label
  number. Returns the C<sockaddr_in6> structure with those arguments packed in
  and C<AF_INET6> filled in. IPv6 equivalent of pack_sockaddr_in().
  
  =head2 ($port, $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr
  
  Takes a C<sockaddr_in6> structure. Returns a list of four elements: the port
  number, an opaque string representing the IPv6 address, the scope ID, and the
  flow label. (You can use inet_ntop() to convert the address to the usual
  string format). Will croak if the structure does not represent an C<AF_INET6>
  address.
  
  In scalar context will return just the IP address.
  
  =head2 $sockaddr = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]
  
  =head2 ($port, $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr
  
  A wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context,
  unpacks its argument according to unpack_sockaddr_in6(). In scalar context,
  packs its arguments according to pack_sockaddr_in6().
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_in6() or unpack_sockaddr_in6() explicitly.
  
  =head2 $sockaddr = pack_sockaddr_un $path
  
  Takes one argument, a pathname. Returns the C<sockaddr_un> structure with that
  path packed in with C<AF_UNIX> filled in. For C<PF_UNIX> sockets, this
  structure is normally what you need for the arguments in bind(), connect(),
  and send().
  
  =head2 ($path) = unpack_sockaddr_un $sockaddr
  
  Takes a C<sockaddr_un> structure (as returned by pack_sockaddr_un(),
  getpeername() or recv()). Returns a list of one element: the pathname. Will
  croak if the structure does not represent an C<AF_UNIX> address.
  
  =head2 $sockaddr = sockaddr_un $path
  
  =head2 ($path) = sockaddr_un $sockaddr
  
  A wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context,
  unpacks its argument and returns a list consisting of the pathname. In a
  scalar context, packs its pathname as a C<sockaddr_un> and returns it.
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_un() or unpack_sockaddr_un() explicitly.
  
  These are only supported if your system has E<lt>F<sys/un.h>E<gt>.
  
  =head2 $ip_mreq = pack_ip_mreq $multiaddr, $interface
  
  Takes an IPv4 multicast address and optionally an interface address (or
  C<INADDR_ANY>). Returns the C<ip_mreq> structure with those arguments packed
  in. Suitable for use with the C<IP_ADD_MEMBERSHIP> and C<IP_DROP_MEMBERSHIP>
  sockopts.
  
  =head2 ($multiaddr, $interface) = unpack_ip_mreq $ip_mreq
  
  Takes an C<ip_mreq> structure. Returns a list of two elements; the IPv4
  multicast address and interface address.
  
  =head2 $ip_mreq_source = pack_ip_mreq_source $multiaddr, $source, $interface
  
  Takes an IPv4 multicast address, source address, and optionally an interface
  address (or C<INADDR_ANY>). Returns the C<ip_mreq_source> structure with those
  arguments packed in. Suitable for use with the C<IP_ADD_SOURCE_MEMBERSHIP>
  and C<IP_DROP_SOURCE_MEMBERSHIP> sockopts.
  
  =head2 ($multiaddr, $source, $interface) = unpack_ip_mreq_source $ip_mreq
  
  Takes an C<ip_mreq_source> structure. Returns a list of three elements; the
  IPv4 multicast address, source address and interface address.
  
  =head2 $ipv6_mreq = pack_ipv6_mreq $multiaddr6, $ifindex
  
  Takes an IPv6 multicast address and an interface number. Returns the
  C<ipv6_mreq> structure with those arguments packed in. Suitable for use with
  the C<IPV6_ADD_MEMBERSHIP> and C<IPV6_DROP_MEMBERSHIP> sockopts.
  
  =head2 ($multiaddr6, $ifindex) = unpack_ipv6_mreq $ipv6_mreq
  
  Takes an C<ipv6_mreq> structure. Returns a list of two elements; the IPv6
  address and an interface number.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 $ip_address = inet_aton $string
  
  Takes a string giving the name of a host, or a textual representation of an IP
  address and translates that to an packed binary address structure suitable to
  pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved,
  returns C<undef>. For multi-homed hosts (hosts with more than one address),
  the first address found is returned.
  
  For portability do not assume that the result of inet_aton() is 32 bits wide,
  in other words, that it would contain only the IPv4 address in network order.
  
  This IPv4-only function is provided largely for legacy reasons. Newly-written
  code should use getaddrinfo() or inet_pton() instead for IPv6 support.
  
  =head2 $string = inet_ntoa $ip_address
  
  Takes a packed binary address structure such as returned by
  unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4
  address in network order) and translates it into a string of the form
  C<d.d.d.d> where the C<d>s are numbers less than 256 (the normal
  human-readable four dotted number notation for Internet addresses).
  
  This IPv4-only function is provided largely for legacy reasons. Newly-written
  code should use getnameinfo() or inet_ntop() instead for IPv6 support.
  
  =head2 $address = inet_pton $family, $string
  
  Takes an address family (such as C<AF_INET> or C<AF_INET6>) and a string
  containing a textual representation of an address in that family and
  translates that to an packed binary address structure.
  
  See also getaddrinfo() for a more powerful and flexible function to look up
  socket addresses given hostnames or textual addresses.
  
  =head2 $string = inet_ntop $family, $address
  
  Takes an address family and a packed binary address structure and translates
  it into a human-readable textual representation of the address; typically in
  C<d.d.d.d> form for C<AF_INET> or C<hhhh:hhhh::hhhh> form for C<AF_INET6>.
  
  See also getnameinfo() for a more powerful and flexible function to turn
  socket addresses into human-readable textual representations.
  
  =head2 ($err, @result) = getaddrinfo $host, $service, [$hints]
  
  Given both a hostname and service name, this function attempts to resolve the
  host name into a list of network addresses, and the service name into a
  protocol and port number, and then returns a list of address structures
  suitable to connect() to it.
  
  Given just a host name, this function attempts to resolve it to a list of
  network addresses, and then returns a list of address structures giving these
  addresses.
  
  Given just a service name, this function attempts to resolve it to a protocol
  and port number, and then returns a list of address structures that represent
  it suitable to bind() to. This use should be combined with the C<AI_PASSIVE>
  flag; see below.
  
  Given neither name, it generates an error.
  
  If present, $hints should be a reference to a hash, where the following keys
  are recognised:
  
  =over 4
  
  =item flags => INT
  
  A bitfield containing C<AI_*> constants; see below.
  
  =item family => INT
  
  Restrict to only generating addresses in this address family
  
  =item socktype => INT
  
  Restrict to only generating addresses of this socket type
  
  =item protocol => INT
  
  Restrict to only generating addresses for this protocol
  
  =back
  
  The return value will be a list; the first value being an error indication,
  followed by a list of address structures (if no error occurred).
  
  The error value will be a dualvar; comparable to the C<EI_*> error constants,
  or printable as a human-readable error message string. If no error occurred it
  will be zero numerically and an empty string.
  
  Each value in the results list will be a hash reference containing the following
  fields:
  
  =over 4
  
  =item family => INT
  
  The address family (e.g. C<AF_INET>)
  
  =item socktype => INT
  
  The socket type (e.g. C<SOCK_STREAM>)
  
  =item protocol => INT
  
  The protocol (e.g. C<IPPROTO_TCP>)
  
  =item addr => STRING
  
  The address in a packed string (such as would be returned by
  pack_sockaddr_in())
  
  =item canonname => STRING
  
  The canonical name for the host if the C<AI_CANONNAME> flag was provided, or
  C<undef> otherwise. This field will only be present on the first returned
  address.
  
  =back
  
  The following flag constants are recognised in the $hints hash. Other flag
  constants may exist as provided by the OS.
  
  =over 4
  
  =item AI_PASSIVE
  
  Indicates that this resolution is for a local bind() for a passive (i.e.
  listening) socket, rather than an active (i.e. connecting) socket.
  
  =item AI_CANONNAME
  
  Indicates that the caller wishes the canonical hostname (C<canonname>) field
  of the result to be filled in.
  
  =item AI_NUMERICHOST
  
  Indicates that the caller will pass a numeric address, rather than a hostname,
  and that getaddrinfo() must not perform a resolve operation on this name. This
  flag will prevent a possibly-slow network lookup operation, and instead return
  an error if a hostname is passed.
  
  =back
  
  =head2 ($err, $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]
  
  Given a packed socket address (such as from getsockname(), getpeername(), or
  returned by getaddrinfo() in a C<addr> field), returns the hostname and
  symbolic service name it represents. $flags may be a bitmask of C<NI_*>
  constants, or defaults to 0 if unspecified.
  
  The return value will be a list; the first value being an error condition,
  followed by the hostname and service name.
  
  The error value will be a dualvar; comparable to the C<EI_*> error constants,
  or printable as a human-readable error message string. The host and service
  names will be plain strings.
  
  The following flag constants are recognised as $flags. Other flag constants may
  exist as provided by the OS.
  
  =over 4
  
  =item NI_NUMERICHOST
  
  Requests that a human-readable string representation of the numeric address be
  returned directly, rather than performing a name resolve operation that may
  convert it into a hostname. This will also avoid potentially-blocking network
  IO.
  
  =item NI_NUMERICSERV
  
  Requests that the port number be returned directly as a number representation
  rather than performing a name resolve operation that may convert it into a
  service name.
  
  =item NI_NAMEREQD
  
  If a name resolve operation fails to provide a name, then this flag will cause
  getnameinfo() to indicate an error, rather than returning the numeric
  representation as a human-readable string.
  
  =item NI_DGRAM
  
  Indicates that the socket address relates to a C<SOCK_DGRAM> socket, for the
  services whose name differs between TCP and UDP protocols.
  
  =back
  
  The following constants may be supplied as $xflags.
  
  =over 4
  
  =item NIx_NOHOST
  
  Indicates that the caller is not interested in the hostname of the result, so
  it does not have to be converted. C<undef> will be returned as the hostname.
  
  =item NIx_NOSERV
  
  Indicates that the caller is not interested in the service name of the result,
  so it does not have to be converted. C<undef> will be returned as the service
  name.
  
  =back
  
  =head1 getaddrinfo() / getnameinfo() ERROR CONSTANTS
  
  The following constants may be returned by getaddrinfo() or getnameinfo().
  Others may be provided by the OS.
  
  =over 4
  
  =item EAI_AGAIN
  
  A temporary failure occurred during name resolution. The operation may be
  successful if it is retried later.
  
  =item EAI_BADFLAGS
  
  The value of the C<flags> hint to getaddrinfo(), or the $flags parameter to
  getnameinfo() contains unrecognised flags.
  
  =item EAI_FAMILY
  
  The C<family> hint to getaddrinfo(), or the family of the socket address
  passed to getnameinfo() is not supported.
  
  =item EAI_NODATA
  
  The host name supplied to getaddrinfo() did not provide any usable address
  data.
  
  =item EAI_NONAME
  
  The host name supplied to getaddrinfo() does not exist, or the address
  supplied to getnameinfo() is not associated with a host name and the
  C<NI_NAMEREQD> flag was supplied.
  
  =item EAI_SERVICE
  
  The service name supplied to getaddrinfo() is not available for the socket
  type given in the $hints.
  
  =back
  
  =cut
  
  =head1 EXAMPLES
  
  =head2 Lookup for connect()
  
  The getaddrinfo() function converts a hostname and a service name into a list
  of structures, each containing a potential way to connect() to the named
  service on the named host.
  
   use IO::Socket;
   use Socket qw(SOCK_STREAM getaddrinfo);
  
   my %hints = (socktype => SOCK_STREAM);
   my ($err, @res) = getaddrinfo("localhost", "echo", \%hints);
   die "Cannot getaddrinfo - $err" if $err;
  
   my $sock;
  
   foreach my $ai (@res) {
       my $candidate = IO::Socket->new();
  
       $candidate->socket($ai->{family}, $ai->{socktype}, $ai->{protocol})
           or next;
  
       $candidate->connect($ai->{addr})
           or next;
  
       $sock = $candidate;
       last;
   }
  
   die "Cannot connect to localhost:echo" unless $sock;
  
   $sock->print("Hello, world!\n");
   print <$sock>;
  
  Because a list of potential candidates is returned, the C<while> loop tries
  each in turn until it finds one that succeeds both the socket() and connect()
  calls.
  
  This function performs the work of the legacy functions gethostbyname(),
  getservbyname(), inet_aton() and pack_sockaddr_in().
  
  In practice this logic is better performed by L<IO::Socket::IP>.
  
  =head2 Making a human-readable string out of an address
  
  The getnameinfo() function converts a socket address, such as returned by
  getsockname() or getpeername(), into a pair of human-readable strings
  representing the address and service name.
  
   use IO::Socket::IP;
   use Socket qw(getnameinfo);
  
   my $server = IO::Socket::IP->new(LocalPort => 12345, Listen => 1) or
       die "Cannot listen - $@";
  
   my $socket = $server->accept or die "accept: $!";
  
   my ($err, $hostname, $servicename) = getnameinfo($socket->peername);
   die "Cannot getnameinfo - $err" if $err;
  
   print "The peer is connected from $hostname\n";
  
  Since in this example only the hostname was used, the redundant conversion of
  the port number into a service name may be omitted by passing the
  C<NIx_NOSERV> flag.
  
   use Socket qw(getnameinfo NIx_NOSERV);
  
   my ($err, $hostname) = getnameinfo($socket->peername, 0, NIx_NOSERV);
  
  This function performs the work of the legacy functions unpack_sockaddr_in(),
  inet_ntoa(), gethostbyaddr() and getservbyport().
  
  In practice this logic is better performed by L<IO::Socket::IP>.
  
  =head2 Resolving hostnames into IP addresses
  
  To turn a hostname into a human-readable plain IP address use getaddrinfo()
  to turn the hostname into a list of socket structures, then getnameinfo() on
  each one to make it a readable IP address again.
  
   use Socket qw(:addrinfo SOCK_RAW);
  
   my ($err, @res) = getaddrinfo($hostname, "", {socktype => SOCK_RAW});
   die "Cannot getaddrinfo - $err" if $err;
  
   while( my $ai = shift @res ) {
       my ($err, $ipaddr) = getnameinfo($ai->{addr}, NI_NUMERICHOST, NIx_NOSERV);
       die "Cannot getnameinfo - $err" if $err;
  
       print "$ipaddr\n";
   }
  
  The C<socktype> hint to getaddrinfo() filters the results to only include one
  socket type and protocol. Without this most OSes return three combinations,
  for C<SOCK_STREAM>, C<SOCK_DGRAM> and C<SOCK_RAW>, resulting in triplicate
  output of addresses. The C<NI_NUMERICHOST> flag to getnameinfo() causes it to
  return a string-formatted plain IP address, rather than reverse resolving it
  back into a hostname.
  
  This combination performs the work of the legacy functions gethostbyname()
  and inet_ntoa().
  
  =head2 Accessing socket options
  
  The many C<SO_*> and other constants provide the socket option names for
  getsockopt() and setsockopt().
  
   use IO::Socket::INET;
   use Socket qw(SOL_SOCKET SO_RCVBUF IPPROTO_IP IP_TTL);
  
   my $socket = IO::Socket::INET->new(LocalPort => 0, Proto => 'udp')
       or die "Cannot create socket: $@";
  
   $socket->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or
       die "setsockopt: $!";
  
   print "Receive buffer is ", $socket->getsockopt(SOL_SOCKET, SO_RCVBUF),
       " bytes\n";
  
   print "IP TTL is ", $socket->getsockopt(IPPROTO_IP, IP_TTL), "\n";
  
  As a convenience, L<IO::Socket>'s setsockopt() method will convert a number
  into a packed byte buffer, and getsockopt() will unpack a byte buffer of the
  correct size back into a number.
  
  =cut
  
  =head1 AUTHOR
  
  This module was originally maintained in Perl core by the Perl 5 Porters.
  
  It was extracted to dual-life on CPAN at version 1.95 by
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  use Carp;
  use warnings::register;
  
  require Exporter;
  require XSLoader;
  our @ISA = qw(Exporter);
  
  # <@Nicholas> you can't change @EXPORT without breaking the implicit API
  # Please put any new constants in @EXPORT_OK!
  
  # List re-ordered to match documentation above. Try to keep the ordering
  # consistent so it's easier to see which ones are or aren't documented.
  our @EXPORT = qw(
  	PF_802 PF_AAL PF_APPLETALK PF_CCITT PF_CHAOS PF_CTF PF_DATAKIT
  	PF_DECnet PF_DLI PF_ECMA PF_GOSIP PF_HYLINK PF_IMPLINK PF_INET PF_INET6
  	PF_ISO PF_KEY PF_LAST PF_LAT PF_LINK PF_MAX PF_NBS PF_NIT PF_NS PF_OSI
  	PF_OSINET PF_PUP PF_ROUTE PF_SNA PF_UNIX PF_UNSPEC PF_USER PF_WAN
  	PF_X25
  
  	AF_802 AF_AAL AF_APPLETALK AF_CCITT AF_CHAOS AF_CTF AF_DATAKIT
  	AF_DECnet AF_DLI AF_ECMA AF_GOSIP AF_HYLINK AF_IMPLINK AF_INET AF_INET6
  	AF_ISO AF_KEY AF_LAST AF_LAT AF_LINK AF_MAX AF_NBS AF_NIT AF_NS AF_OSI
  	AF_OSINET AF_PUP AF_ROUTE AF_SNA AF_UNIX AF_UNSPEC AF_USER AF_WAN
  	AF_X25
  
  	SOCK_DGRAM SOCK_RAW SOCK_RDM SOCK_SEQPACKET SOCK_STREAM
  
  	SOL_SOCKET
  
  	SO_ACCEPTCONN SO_ATTACH_FILTER SO_BACKLOG SO_BROADCAST SO_CHAMELEON
  	SO_DEBUG SO_DETACH_FILTER SO_DGRAM_ERRIND SO_DOMAIN SO_DONTLINGER
  	SO_DONTROUTE SO_ERROR SO_FAMILY SO_KEEPALIVE SO_LINGER SO_OOBINLINE
  	SO_PASSCRED SO_PASSIFNAME SO_PEERCRED SO_PROTOCOL SO_PROTOTYPE
  	SO_RCVBUF SO_RCVLOWAT SO_RCVTIMEO SO_REUSEADDR SO_REUSEPORT
  	SO_SECURITY_AUTHENTICATION SO_SECURITY_ENCRYPTION_NETWORK
  	SO_SECURITY_ENCRYPTION_TRANSPORT SO_SNDBUF SO_SNDLOWAT SO_SNDTIMEO
  	SO_STATE SO_TYPE SO_USELOOPBACK SO_XOPEN SO_XSE
  
  	IP_OPTIONS IP_HDRINCL IP_TOS IP_TTL IP_RECVOPTS IP_RECVRETOPTS
  	IP_RETOPTS
  
  	MSG_BCAST MSG_BTAG MSG_CTLFLAGS MSG_CTLIGNORE MSG_CTRUNC MSG_DONTROUTE
  	MSG_DONTWAIT MSG_EOF MSG_EOR MSG_ERRQUEUE MSG_ETAG MSG_FIN
  	MSG_MAXIOVLEN MSG_MCAST MSG_NOSIGNAL MSG_OOB MSG_PEEK MSG_PROXY MSG_RST
  	MSG_SYN MSG_TRUNC MSG_URG MSG_WAITALL MSG_WIRE
  
  	SHUT_RD SHUT_RDWR SHUT_WR
  
  	INADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE
  
  	SCM_CONNECT SCM_CREDENTIALS SCM_CREDS SCM_RIGHTS SCM_TIMESTAMP
  
  	SOMAXCONN
  
  	IOV_MAX
  	UIO_MAXIOV
  
  	sockaddr_family
  	pack_sockaddr_in  unpack_sockaddr_in  sockaddr_in
  	pack_sockaddr_in6 unpack_sockaddr_in6 sockaddr_in6
  	pack_sockaddr_un  unpack_sockaddr_un  sockaddr_un 
  
  	inet_aton inet_ntoa
  );
  
  # List re-ordered to match documentation above. Try to keep the ordering
  # consistent so it's easier to see which ones are or aren't documented.
  our @EXPORT_OK = qw(
  	CR LF CRLF $CR $LF $CRLF
  
  	SOCK_NONBLOCK SOCK_CLOEXEC
  
  	IP_ADD_MEMBERSHIP IP_ADD_SOURCE_MEMBERSHIP IP_DROP_MEMBERSHIP
  	IP_DROP_SOURCE_MEMBERSHIP IP_MULTICAST_IF IP_MULTICAST_LOOP
  	IP_MULTICAST_TTL
  
  	IPPROTO_IP IPPROTO_IPV6 IPPROTO_RAW IPPROTO_ICMP IPPROTO_TCP
  	IPPROTO_UDP
  
  	IPTOS_LOWDELAY IPTOS_THROUGHPUT IPTOS_RELIABILITY IPTOS_MINCOST
  
  	TCP_CONGESTION TCP_CONNECTIONTIMEOUT TCP_CORK TCP_DEFER_ACCEPT TCP_INFO
  	TCP_INIT_CWND TCP_KEEPALIVE TCP_KEEPCNT TCP_KEEPIDLE TCP_KEEPINTVL
  	TCP_LINGER2 TCP_MAXRT TCP_MAXSEG TCP_MD5SIG TCP_NODELAY TCP_NOOPT
  	TCP_NOPUSH TCP_QUICKACK TCP_SACK_ENABLE TCP_STDURG TCP_SYNCNT
  	TCP_WINDOW_CLAMP
  
  	IN6ADDR_ANY IN6ADDR_LOOPBACK
  
  	IPV6_ADD_MEMBERSHIP IPV6_DROP_MEMBERSHIP IPV6_JOIN_GROUP
  	IPV6_LEAVE_GROUP IPV6_MTU IPV6_MTU_DISCOVER IPV6_MULTICAST_HOPS
  	IPV6_MULTICAST_IF IPV6_MULTICAST_LOOP IPV6_UNICAST_HOPS IPV6_V6ONLY
  
  	pack_ip_mreq unpack_ip_mreq pack_ip_mreq_source unpack_ip_mreq_source
  
  	pack_ipv6_mreq unpack_ipv6_mreq
  
  	inet_pton inet_ntop
  
  	getaddrinfo getnameinfo
  
  	AI_ADDRCONFIG AI_ALL AI_CANONIDN AI_CANONNAME AI_IDN
  	AI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES AI_NUMERICHOST
  	AI_NUMERICSERV AI_PASSIVE AI_V4MAPPED
  
  	NI_DGRAM NI_IDN NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES
  	NI_NAMEREQD NI_NOFQDN NI_NUMERICHOST NI_NUMERICSERV
  
  	NIx_NOHOST NIx_NOSERV
  
  	EAI_ADDRFAMILY EAI_AGAIN EAI_BADFLAGS EAI_BADHINTS EAI_FAIL EAI_FAMILY
  	EAI_NODATA EAI_NONAME EAI_PROTOCOL EAI_SERVICE EAI_SOCKTYPE EAI_SYSTEM
  );
  
  our %EXPORT_TAGS = (
      crlf     => [qw(CR LF CRLF $CR $LF $CRLF)],
      addrinfo => [qw(getaddrinfo getnameinfo), grep m/^(?:AI|NI|NIx|EAI)_/, @EXPORT_OK],
      all      => [@EXPORT, @EXPORT_OK],
  );
  
  BEGIN {
      sub CR   () {"\015"}
      sub LF   () {"\012"}
      sub CRLF () {"\015\012"}
  
      # These are not gni() constants; they're extensions for the perl API
      # The definitions in Socket.pm and Socket.xs must match
      sub NIx_NOHOST() {1 << 0}
      sub NIx_NOSERV() {1 << 1}
  }
  
  *CR   = \CR();
  *LF   = \LF();
  *CRLF = \CRLF();
  
  sub sockaddr_in {
      if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die
  	my($af, $port, @quad) = @_;
  	warnings::warn "6-ARG sockaddr_in call is deprecated" 
  	    if warnings::enabled();
  	pack_sockaddr_in($port, inet_aton(join('.', @quad)));
      } elsif (wantarray) {
  	croak "usage:   (port,iaddr) = sockaddr_in(sin_sv)" unless @_ == 1;
          unpack_sockaddr_in(@_);
      } else {
  	croak "usage:   sin_sv = sockaddr_in(port,iaddr))" unless @_ == 2;
          pack_sockaddr_in(@_);
      }
  }
  
  sub sockaddr_in6 {
      if (wantarray) {
  	croak "usage:   (port,in6addr,scope_id,flowinfo) = sockaddr_in6(sin6_sv)" unless @_ == 1;
  	unpack_sockaddr_in6(@_);
      }
      else {
  	croak "usage:   sin6_sv = sockaddr_in6(port,in6addr,[scope_id,[flowinfo]])" unless @_ >= 2 and @_ <= 4;
  	pack_sockaddr_in6(@_);
      }
  }
  
  sub sockaddr_un {
      if (wantarray) {
  	croak "usage:   (filename) = sockaddr_un(sun_sv)" unless @_ == 1;
          unpack_sockaddr_un(@_);
      } else {
  	croak "usage:   sun_sv = sockaddr_un(filename)" unless @_ == 1;
          pack_sockaddr_un(@_);
      }
  }
  
  XSLoader::load(__PACKAGE__, $VERSION);
  
  my %errstr;
  
  if( defined &getaddrinfo ) {
      # These are not part of the API, nothing uses them, and deleting them
      # reduces the size of %Socket:: by about 12K
      delete $Socket::{fake_getaddrinfo};
      delete $Socket::{fake_getnameinfo};
  } else {
      require Scalar::Util;
  
      *getaddrinfo = \&fake_getaddrinfo;
      *getnameinfo = \&fake_getnameinfo;
  
      # These numbers borrowed from GNU libc's implementation, but since
      # they're only used by our emulation, it doesn't matter if the real
      # platform's values differ
      my %constants = (
  	AI_PASSIVE     => 1,
  	AI_CANONNAME   => 2,
  	AI_NUMERICHOST => 4,
  	AI_V4MAPPED    => 8,
  	AI_ALL         => 16,
  	AI_ADDRCONFIG  => 32,
  	# RFC 2553 doesn't define this but Linux does - lets be nice and
  	# provide it since we can
  	AI_NUMERICSERV => 1024,
  
  	EAI_BADFLAGS   => -1,
  	EAI_NONAME     => -2,
  	EAI_NODATA     => -5,
  	EAI_FAMILY     => -6,
  	EAI_SERVICE    => -8,
  
  	NI_NUMERICHOST => 1,
  	NI_NUMERICSERV => 2,
  	NI_NOFQDN      => 4,
  	NI_NAMEREQD    => 8,
  	NI_DGRAM       => 16,
  
  	# Constants we don't support. Export them, but croak if anyone tries to
  	# use them
  	AI_IDN                      => 64,
  	AI_CANONIDN                 => 128,
  	AI_IDN_ALLOW_UNASSIGNED     => 256,
  	AI_IDN_USE_STD3_ASCII_RULES => 512,
  	NI_IDN                      => 32,
  	NI_IDN_ALLOW_UNASSIGNED     => 64,
  	NI_IDN_USE_STD3_ASCII_RULES => 128,
  
  	# Error constants we'll never return, so it doesn't matter what value
  	# these have, nor that we don't provide strings for them
  	EAI_SYSTEM   => -11,
  	EAI_BADHINTS => -1000,
  	EAI_PROTOCOL => -1001
      );
  
      foreach my $name ( keys %constants ) {
  	my $value = $constants{$name};
  
  	no strict 'refs';
  	defined &$name or *$name = sub () { $value };
      }
  
      %errstr = (
  	# These strings from RFC 2553
  	EAI_BADFLAGS()   => "invalid value for ai_flags",
  	EAI_NONAME()     => "nodename nor servname provided, or not known",
  	EAI_NODATA()     => "no address associated with nodename",
  	EAI_FAMILY()     => "ai_family not supported",
  	EAI_SERVICE()    => "servname not supported for ai_socktype",
      );
  }
  
  # The following functions are used if the system does not have a
  # getaddrinfo(3) function in libc; and are used to emulate it for the AF_INET
  # family
  
  # Borrowed from Regexp::Common::net
  my $REGEXP_IPv4_DECIMAL = qr/25[0-5]|2[0-4][0-9]|1?[0-9][0-9]{1,2}/;
  my $REGEXP_IPv4_DOTTEDQUAD = qr/$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL/;
  
  sub fake_makeerr
  {
      my ( $errno ) = @_;
      my $errstr = $errno == 0 ? "" : ( $errstr{$errno} || $errno );
      return Scalar::Util::dualvar( $errno, $errstr );
  }
  
  sub fake_getaddrinfo
  {
      my ( $node, $service, $hints ) = @_;
  
      $node = "" unless defined $node;
  
      $service = "" unless defined $service;
  
      my ( $family, $socktype, $protocol, $flags ) = @$hints{qw( family socktype protocol flags )};
  
      $family ||= Socket::AF_INET(); # 0 == AF_UNSPEC, which we want too
      $family == Socket::AF_INET() or return fake_makeerr( EAI_FAMILY() );
  
      $socktype ||= 0;
  
      $protocol ||= 0;
  
      $flags ||= 0;
  
      my $flag_passive     = $flags & AI_PASSIVE();     $flags &= ~AI_PASSIVE();
      my $flag_canonname   = $flags & AI_CANONNAME();   $flags &= ~AI_CANONNAME();
      my $flag_numerichost = $flags & AI_NUMERICHOST(); $flags &= ~AI_NUMERICHOST();
      my $flag_numericserv = $flags & AI_NUMERICSERV(); $flags &= ~AI_NUMERICSERV();
  
      # These constants don't apply to AF_INET-only lookups, so we might as well
      # just ignore them. For AI_ADDRCONFIG we just presume the host has ability
      # to talk AF_INET. If not we'd have to return no addresses at all. :)
      $flags &= ~(AI_V4MAPPED()|AI_ALL()|AI_ADDRCONFIG());
  
      $flags & (AI_IDN()|AI_CANONIDN()|AI_IDN_ALLOW_UNASSIGNED()|AI_IDN_USE_STD3_ASCII_RULES()) and
  	croak "Socket::getaddrinfo() does not support IDN";
  
      $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );
  
      $node eq "" and $service eq "" and return fake_makeerr( EAI_NONAME() );
  
      my $canonname;
      my @addrs;
      if( $node ne "" ) {
  	return fake_makeerr( EAI_NONAME() ) if( $flag_numerichost and $node !~ m/^$REGEXP_IPv4_DOTTEDQUAD$/ );
  	( $canonname, undef, undef, undef, @addrs ) = gethostbyname( $node );
  	defined $canonname or return fake_makeerr( EAI_NONAME() );
  
  	undef $canonname unless $flag_canonname;
      }
      else {
  	$addrs[0] = $flag_passive ? Socket::inet_aton( "0.0.0.0" )
  				  : Socket::inet_aton( "127.0.0.1" );
      }
  
      my @ports; # Actually ARRAYrefs of [ socktype, protocol, port ]
      my $protname = "";
      if( $protocol ) {
  	$protname = getprotobynumber( $protocol );
      }
  
      if( $service ne "" and $service !~ m/^\d+$/ ) {
  	return fake_makeerr( EAI_NONAME() ) if( $flag_numericserv );
  	getservbyname( $service, $protname ) or return fake_makeerr( EAI_SERVICE() );
      }
  
      foreach my $this_socktype ( Socket::SOCK_STREAM(), Socket::SOCK_DGRAM(), Socket::SOCK_RAW() ) {
  	next if $socktype and $this_socktype != $socktype;
  
  	my $this_protname = "raw";
  	$this_socktype == Socket::SOCK_STREAM() and $this_protname = "tcp";
  	$this_socktype == Socket::SOCK_DGRAM()  and $this_protname = "udp";
  
  	next if $protname and $this_protname ne $protname;
  
  	my $port;
  	if( $service ne "" ) {
  	    if( $service =~ m/^\d+$/ ) {
  		$port = "$service";
  	    }
  	    else {
  		( undef, undef, $port, $this_protname ) = getservbyname( $service, $this_protname );
  		next unless defined $port;
  	    }
  	}
  	else {
  	    $port = 0;
  	}
  
  	push @ports, [ $this_socktype, scalar getprotobyname( $this_protname ) || 0, $port ];
      }
  
      my @ret;
      foreach my $addr ( @addrs ) {
  	foreach my $portspec ( @ports ) {
  	    my ( $socktype, $protocol, $port ) = @$portspec;
  	    push @ret, {
  		family    => $family,
  		socktype  => $socktype,
  		protocol  => $protocol,
  		addr      => Socket::pack_sockaddr_in( $port, $addr ),
  		canonname => undef,
  	    };
  	}
      }
  
      # Only supply canonname for the first result
      if( defined $canonname ) {
  	$ret[0]->{canonname} = $canonname;
      }
  
      return ( fake_makeerr( 0 ), @ret );
  }
  
  sub fake_getnameinfo
  {
      my ( $addr, $flags, $xflags ) = @_;
  
      my ( $port, $inetaddr );
      eval { ( $port, $inetaddr ) = Socket::unpack_sockaddr_in( $addr ) }
  	or return fake_makeerr( EAI_FAMILY() );
  
      my $family = Socket::AF_INET();
  
      $flags ||= 0;
  
      my $flag_numerichost = $flags & NI_NUMERICHOST(); $flags &= ~NI_NUMERICHOST();
      my $flag_numericserv = $flags & NI_NUMERICSERV(); $flags &= ~NI_NUMERICSERV();
      my $flag_nofqdn      = $flags & NI_NOFQDN();      $flags &= ~NI_NOFQDN();
      my $flag_namereqd    = $flags & NI_NAMEREQD();    $flags &= ~NI_NAMEREQD();
      my $flag_dgram       = $flags & NI_DGRAM()   ;    $flags &= ~NI_DGRAM();
  
      $flags & (NI_IDN()|NI_IDN_ALLOW_UNASSIGNED()|NI_IDN_USE_STD3_ASCII_RULES()) and
  	croak "Socket::getnameinfo() does not support IDN";
  
      $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );
  
      $xflags ||= 0;
  
      my $node;
      if( $xflags & NIx_NOHOST ) {
  	$node = undef;
      }
      elsif( $flag_numerichost ) {
  	$node = Socket::inet_ntoa( $inetaddr );
      }
      else {
  	$node = gethostbyaddr( $inetaddr, $family );
  	if( !defined $node ) {
  	    return fake_makeerr( EAI_NONAME() ) if $flag_namereqd;
  	    $node = Socket::inet_ntoa( $inetaddr );
  	}
  	elsif( $flag_nofqdn ) {
  	    my ( $shortname ) = split m/\./, $node;
  	    my ( $fqdn ) = gethostbyname $shortname;
  	    $node = $shortname if defined $fqdn and $fqdn eq $node;
  	}
      }
  
      my $service;
      if( $xflags & NIx_NOSERV ) {
  	$service = undef;
      }
      elsif( $flag_numericserv ) {
  	$service = "$port";
      }
      else {
  	my $protname = $flag_dgram ? "udp" : "";
  	$service = getservbyport( $port, $protname );
  	if( !defined $service ) {
  	    $service = "$port";
  	}
      }
  
      return ( fake_makeerr( 0 ), $node, $service );
  }
  
  1;
DARWIN-2LEVEL_SOCKET

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE


use strict;
use Redis;
use FindBin '$Bin';
use File::Spec;
use File::Path qw/rmtree mkpath/;
use MIME::Base64;
use JSON::PP;
use YAML::Tiny;
use Storable;
use Encode;
use DateTime::Tiny;
use File::Copy qw(copy);
use Time::HiRes qw/gettimeofday tv_interval/;
use Capture::Tiny;
use Try::Tiny;
use Term::ANSIColor qw(:constants);

select(STDERR);
$| = 1;
select(STDOUT); 
$| = 1;

our $t0 = [gettimeofday];
our $workerid;
our %conf;
our $id_has_pid = 0;

# logging functions
sub _log { 
    my $elapsed = tv_interval ( $t0 );
    my $msg = $_[0];
    local $main::log_error=1 if $msg=~/^ERROR/;
    my ($pre,$post) =  $main::log_error ? (RED,RESET) 
        : $main::log_warn ? (YELLOW,RESET) 
        : $main::log_debug ? (GREEN,RESET)
        :('','');
    my $ts = _now();
    print $pre, sprintf("[${workerid}%s $ts %0.4f] ", ( $id_has_pid ? '' : " $$"), $elapsed), @_, $post, "\n"; 
    $t0 = [gettimeofday];
}
sub _error { local $main::log_error = 1; _log( @_ ) }
sub _warn { local $main::log_warn = 1; _log( @_ ) }
sub _debug { return unless $conf{verbose}; local $main::log_debug= 1; _log( @_ ) }
sub _now {
    DateTime::Tiny->now(); #time_zone=>_tz);
}

# main command
our $CMD = $ARGV[0] !~ /^-/ ? shift @ARGV : 'start';
$CMD =~ s/-+/_/g;
$CMD='start' unless length $CMD;

# any args?
my $lastopt;
my %ARGV = map { $lastopt=~/^--?/ && $_=~/^--?/ ? (1, $lastopt=$_) : ($lastopt=$_)  } @ARGV;
$ARGV{$lastopt} = 1 if $lastopt =~ /^--?/; # last option does not get 1 otherwise

my %args;  # nice hasheable args
while( my ($k,$v) = each %ARGV ) {
    $k =~ s/^--?//g;
    $k =~ s/-+/_/g;
    $args{$k} = $v;
}

print "Clarive Worker v6.1\n" unless $args{h};

# config
my $server = $ARGV{'--server'} || 'localhost:6379';
my $script_home = Cwd::realpath( $Bin );
my $config_file = $ARGV{'--config'} || File::Spec->catfile($script_home,'cla-worker.conf');

require Sys::Hostname;
#use Config;$Config{intsize},
%conf = (
    host           => Sys::Hostname::hostname(),
    user           => getlogin(),
    started_on     => DateTime::Tiny->now() . '',
    script_home    => $script_home,
    encode_format  => 'yaml',
    os             => $^O,
    arch           => do { $a=`uname -m`; chomp $a; $a }, 
    home           => $script_home,
    pid_dir        => $script_home,
    log_dir        => $script_home,
    pid            => $$,
    verbose        => 0,
    timeout        => 600,
    reconnect_wait => 5,
    chunk_size     => 64 * 1024,
    timeout_file   => 1, # seconds
    daemon         => 0,
);
if( -e $config_file ) {
    print "config_file: $config_file\n" unless $args{h};
    open my $fc,'<:encoding(utf-8)', $config_file or die "ERROR: could not open config file: $!\n";
    local $/;
    my $yaml = <$fc>; 
    %conf = ( %conf, %{ Load( $yaml ) || {} } );
}
# merge args
%conf = ( %conf, %args );
my $conf_json = encode_msg( \%conf );

# globals
#my $choose_defined = sub { defined $_ and return $_ for @_ };
$workerid = $conf{id} || do {
    $id_has_pid = 1;
    sprintf '%s@%s/%d', $conf{user}, $conf{host}, $conf{pid};
};
$conf{id} = $workerid;
( my $workerid_clean = $workerid ) =~ s/[^-_\w]+/_/g;
$workerid_clean =~ s/_+/_/g;
$conf{pid_file} ||= File::Spec->catfile( $conf{pid_dir}, "cla-worker-$workerid_clean.pid" );
$conf{log_file} ||= File::Spec->catfile( $conf{log_dir}, "cla-worker.log" );
our ($reconnect_wait, $timeout_file, $daemon, $pid_file, $log_file, $timeout, $chunk_size ) = 
    @conf{ qw/reconnect_wait timeout_file daemon pid_file log_file timeout chunk_size/ };

our @capabilities;
push @capabilities, "$conf{user}\@$conf{host}";
if( ref $conf{capabilities} eq 'ARRAY' ) {
    push @capabilities, @{ $conf{capabilities} };
}
if( my $cans = $conf{can} ) {
    push @capabilities, split /,/, $conf{can};
}
@capabilities = sort keys %{ +{ map { $_ => undef } @capabilities } };

# usage ?
if( exists $ARGV{'-h'} || exists $ARGV{'--help'} ) {
    usage();
    exit 1;
}

# run command: start, stop
our ($redis, $queue); 
{
    no strict 'refs';
    *{ "main::$CMD" }->();
    exit 0;
}

sub start {
    print "cla-worker starting with id '$workerid', pid $$\n";
    my $recon_count = 1;
    # connect
    CONNECT:
    print "connecting to server $server...";
    $redis = try {
        Redis->new( 
            server=>$server,
            encoding => undef,
            on_connect => sub {
                print "db connected";
            }
        );
    } catch {
        my $err = shift;
        print "\n";
        _error "ERROR connecting to Redis (db): $err";
        my $mult = int log $recon_count;  # wait a little longer logarithmically
        my $wait = $mult > 2 ? $reconnect_wait*$mult : $reconnect_wait;
        _log "Retrying connection in $wait seconds...";
        sleep $wait;
        $recon_count++;
        goto CONNECT;
    };

    $queue = try {
        Redis->new(
            server     => $server,
            encoding   => undef,
            on_connect => sub {
                print ", queue connected.\n";
            }
        );
    } catch {
        my $err = shift;
        print "\n";
        _error "\nERROR connecting to Redis (db): $err";
        my $mult = int log $recon_count;  # wait a little longer logarithmically
        my $wait = $mult > 2 ? $reconnect_wait*$mult : $reconnect_wait;
        _log "Retrying connection in $wait seconds...";
        sleep $wait;
        $recon_count++;
        goto CONNECT;
    };
    
    $recon_count = 1; # reset logarithm 
    
    # check if someone has this id already
    $queue->subscribe("queue:pong:$workerid", sub {
        my ($msg, $topic, $subscribed_topic) = @_;
        my $d = decode_json( $msg ) if $msg;
        return if $$ eq $d->{pid};
        die WHITE ON_RED, "FATAL:", RESET," there's another worker with id `$workerid` in the network (me=$$):\n", Dump($d);
    });
    $redis->publish( "queue:$workerid:ping", '' );
    # wait 1 sec for an answer and unsubscribe?
    $queue->wait_for_messages(1);
    $queue->unsubscribe("queue:pong:$workerid", sub{});  # XXX not working?

    # daemonize?
    if( $daemon ) {
        print "pid_file: $pid_file\n";
        print "log_file: $log_file\n";
        if( -e $pid_file ) {
            my $pid = read_pid( $pid_file );
            # check if proc exists
            if( kill 0 => $pid ) {
                die "FATAL: pid file '$pid_file' already exists.\n" 
            } else {
                unlink $pid_file;
            }
        }
        my $pid = fork();
        die "can't fork: $!" unless defined $pid;
        if( $pid ) {
            print "forked daemon with pid $pid\n"; 
            open my $fp,'>', $pid_file or die "FATAL: could not open pid file '$pid_file': $!\n";
            print $fp $pid;
            close $fp;
            exit 0;
        }
        # child
        require POSIX;
        POSIX::setsid(); 
        log_shorten();
        open STDIN, '/dev/null' or die "Could not redirect STDIN: $!";
        open STDOUT, '>>', $log_file or die sprintf "Could not redirect STDIN to %s: $!", $log_file;
        open STDERR, '>&STDOUT' or die "Could not redirect STDERR: $!";
    }

    # register and announce
    _log "registering worker $workerid";
    $redis->hset( 'queue:workers', $workerid, $conf_json );
    _log "announcing $workerid";
    $redis->publish( 'queue:worker:new', $workerid );

    _log "subscribing to work queue";
    $queue->psubscribe("queue:$workerid:*", sub {
        my ($msg, $topic, $subscribed_topic) = @_;
        _log "got message with topic=$topic";
        # process
        process_message( $msg, $topic, $subscribed_topic );
    });

    # register for capabilities searches
    if( @capabilities ) {
        _log "capabilities announced: " . join ',', @capabilities;
        #my @keys = map { "queue:capability.$_" } @capabilities;
        $queue->psubscribe( 'queue:capability:*', sub {
            my ($msg, $topic, $subscribed_topic) = @_;
            my $reqid = ( split /:/, $topic )[2];
            my $caps = decode_base64( $msg );
            _debug "got request for capabilities: $caps";
            my @caps = split /,/,$caps; 
            my %all_caps = map { $_ => 1 } @capabilities;
            if( scalar( grep {defined} @all_caps{@caps}) == scalar @caps ) {
                # send requester that I'm ok
                _log "responding capable of $caps (reqid=$reqid)";
                #$redis->publish( "queue:capable:$cap", $workerid );
                $redis->rpush( "queue:capable:$reqid", $workerid );
            }
        });
    }

    # loop on messages
    _log "waiting for messages, loop each $timeout seconds";
    while( 1 ) {
        try {
            $queue->wait_for_messages($timeout);
        } catch {
            my $err = shift;
            _log "ERROR waiting for messages: $err";
            if( $err =~ /__try_read_sock/ ) {
                _log "diag: redis server down? Retrying connection in $reconnect_wait seconds...";
                sleep $reconnect_wait;
                goto CONNECT;  # start over
            }
        };
        _log "done waiting, loop again." if $conf{verbose};
    }
}

sub stop {
    my $pid = read_pid( $pid_file );
    print "stopping worker id $workerid with pid $pid...\n";
    my $sig = $conf{sig} || 'HUP';
    my $ret = kill $sig => $pid; 
    print $ret ? "stopped.\n" : "ERROR during shutdown: $!\n";
    unlink $pid_file;
    exit !$ret;
}

sub stop_all {
    print "looking for pid files in $conf{home} and/or $conf{pid_dir}...\n";
    my $rc = 0;
    my $k = 0;
    for my $pf( sort keys %{ +{ map { $_=>1 } <$conf{home}/cla-worker-*.pid $conf{pid_dir}/cla-worker-*.pid> } } )  {
        $k ||= 1;
        print "stopping daemon with pid file $pf...\n";
        my $pid = read_pid( $pf );
        my $sig = $conf{sig} || 'HUP';
        my $ret = kill $sig => $pid; 
        if( $ret ) {
            print "stopped daemon with pid $pid\n";
        } else {
            print "could not stop daemon with pid $pid: $!\n";
        }
        unlink $pf;
        $rc += !$ret;
    }
    print YELLOW, "no pid files found.\n" unless $k;
    exit !$k ? 1 : $rc;
}

sub ps {
    print "cla-worker processes:\n";
    my @ps = `ps -ef`;
    for my $pr ( grep /cla-worker/, @ps ) {
        my @pp = grep { length } split /\s+/, $pr;
        next if $pp[1] == $$;
        print $pr;
    }
    exit 0;
}

sub capabilities {
    print "worker capabilities:\n";
    for my $cap ( @capabilities ) {
        print "   - $cap\n";        
    }
}

sub config {
    print "worker config:\n";
    print Dump( \%conf );
}

###################################

sub log_shorten {
    my ($file) = @_;
    system tail => -1000 => $file => ">$file.new"; 
    unlink $file;
    copy "$file.new" => $file;
}

sub read_pid {
    my ($pid_file) = @_;
    open my $fp, '<', $pid_file or die "FATAL: could not open pid_file $pid_file: $!\n";
    my $pid = join '', <$fp>;
    $pid =~ s/[^0-9]*//g;
    close $fp;
    return $pid; 
}

sub process_message {
    my ($msg, $topic, $subscribed_topic) = @_;
    my ($ns, $workerid, $cmd, $id_msg) = ( split /:/, $topic );
    # send ack
    $redis->publish( "queue:$id_msg:start",'' ); 
        
    # start payload
    _log "start: $topic ($cmd): msg bytes=" . length($msg);  
    _debug "CMD       =$cmd";
    _debug "CMD DATA  =$msg";
    my ($ret, $rc);
    my $t1 = [gettimeofday];
    # run command
    my $output = try {
        Capture::Tiny::tee_merged( sub {
            $ret = run_cmd( $cmd, $workerid, $id_msg, $msg );
            $rc = $?;
        });
    } catch {
        my $err = shift;
        $rc = 99;
        $ret = '';
        $err;
    };
    # finalize
    _debug "CMD RC    =$rc";
    _debug "CMD RET   =$ret";
    _debug "CMD OUTPUT=$output";
    my $result = {
        ret    => $ret,     # ret value from command
        rc     => $rc,      # return code
        output => $output,  # stdout + stderr 
    };
    _log sprintf "$cmd DONE in %0.4fs", tv_interval $t1;
    $redis->set( "queue:$id_msg:result", encode_msg( $result ) );
    $redis->publish( "queue:$id_msg:done", '' );
}

sub run_cmd {
    my ($cmd, $workerid, $id_msg, $msg)=@_;
    #_log "command=$cmd, id_msg=$id_msg";
    $msg = try { decode_json( $msg ) } catch { $msg };
    if( $cmd eq 'eval' ) {
        my ($code,$stash) = ($msg->{code}, $msg->{stash});
        my $ret = eval $code;
        #die $@ if $@;
        return $ret;
    }
    elsif( $cmd eq 'put_file' ) {
        open my $ff, '>:raw', $msg->{filepath};
        my $key = "queue:$id_msg:file";
        my $k = 1;
        while( my $chunk = $redis->blpop( $key, $timeout_file ) ) {
            # chunk 0: key, 1: data
            print $ff decode_base64( $chunk->[1] );
            #print $ff join '', pack 'H*', $chunk->[1]; #decode_base64( $chunk->[1] );
        }
        close $ff;
        my $stat = stat $msg->{filepath};
        return { stat => $stat };
    }
    elsif( $cmd eq 'get_file' ) {
        open my $ff, '<:raw', $msg->{filepath};
        my $chunk = '';
        my $bytes = 0;
        while( sysread $ff, $chunk, $chunk_size ) {
            $redis->rpush( "queue:$id_msg:file", encode_base64($chunk) );
            $bytes += length( $chunk );
        }
        close $ff;
        return $bytes;
    }
    elsif( $cmd eq 'ping' ) {
        $redis->publish( "queue:pong:$workerid", encode_msg( \%conf ) );
    }
    else {
        die "cla-worker: Invalid command: $cmd\n";
    }
}

sub aborted {
    my ($code)=@_;
    print "Aborted (code=$code)\n";
    #print "More info using: tail -200 '$ENV{LOGFILE}'\n";
    exit $code;
}

sub encode_msg {
    my ($d) = @_;
    # json: has problems with utf8, storable: may hit incompatible version binaries
    return $conf{encode_format} eq 'yaml' 
        ? 'yaml:' . Dump( $d )  
        : $conf{encode_format} eq 'stor'
            ? 'stor:' . Storable::freeze( $d )
            : encode_json( $d );
}

exit 0;
########## main end

sub usage {
    print banner();
    print qq{usage: cla-worker command <options>
    
commands available:
        start                starts a new worker
        stops                stops a daemon worker
        stop-all             stops all daemon workers (from *.pid files)
        capabilities         lists capabilities
        config               display worker config
        ps                   lists all worker processes
        
options:
        --server             host and port of the queue server: localhost:6379
        --id                 client id
        --daemon             fork a daemon worker
        --host               hostname to report to queue
        --user               username to report to queue
        --timeout            timeout secs waiting for messages (default=$conf{timeout})
        --reconnect-wait     seconds to wait in between reconnection attempts (default=$conf{reconect_wait})
        --log_file           path to log file
        --pid-file           path to pid file
        --log-file           path to log file
        --sig                signal to kill daemons (default=HUP)
        --can                list of comma separated capabilities

examples:

    cla-worker start --server 192.168.1.2:6379 
    cla-worker stop 
    curl -fsL http://clarive.com/downloads/cla-worker | perl - start --server 192.168.1.2:6379 --id centos
    
};
}

sub tpl_eval {
    my $s = shift;
    $s =~ s/(\<%(.*?)%\>)/eval("$2")/eg;
    return $s;
}

sub banner {
q{

    88888888  888          8888      888888888    88  888      888   8888888   
   888888888  888          88888     8888888888   88  888     888   8888888888 
  888         888         888888     88     888   88   888    888  888     888 
  88          888         888 888    88     888   88   888   888   88       888
 888          888        888  888    8888888888   88    888  888   888888888888
  88          888        888888888   88888888     88    888 888    888888888888
  888         888       8888888888   88    888    88     888888    888         
   888888888  888888888 888     888  88     888   88     88888      8888888888 
    88888888  888888888888      888  88      888  88      8888       888888888 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Clarive Worker v6.2 - Copyright (c) 2015 clarive.com

}
}


